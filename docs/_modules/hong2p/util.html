<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>hong2p.util &mdash; hong2p 0.0.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> hong2p
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../apidoc/modules.html">hong2p</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">hong2p</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>hong2p.util</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for hong2p.util</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Common functions for dealing with Thorlabs software output / stimulus metadata /</span>
<span class="sd">our databases / movies / CNMF output.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="k">import</span> <span class="n">join</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">exists</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">isdir</span><span class="p">,</span> <span class="n">isfile</span><span class="p">,</span> <span class="n">getmtime</span><span class="p">,</span> <span class="n">splitext</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="k">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">platform</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="k">import</span> <span class="n">ModuleType</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="k">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">pprint</span> <span class="k">import</span> <span class="n">pprint</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">hashlib</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Generator</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="k">as</span> <span class="nn">etree</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.ma</span> <span class="k">import</span> <span class="n">MaskedArray</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">import</span> <span class="nn">yaml</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="k">import</span> <span class="n">make_axes_locatable</span>
<span class="kn">import</span> <span class="nn">tifffile</span>

<span class="kn">from</span> <span class="nn">hong2p</span> <span class="k">import</span> <span class="n">matlab</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">thor</span><span class="p">,</span> <span class="n">viz</span><span class="p">,</span> <span class="n">olf</span>
<span class="kn">from</span> <span class="nn">hong2p.types</span> <span class="k">import</span> <span class="p">(</span><span class="n">Pathlike</span><span class="p">,</span> <span class="n">PathPair</span><span class="p">,</span> <span class="n">Datelike</span><span class="p">,</span> <span class="n">FlyNum</span><span class="p">,</span> <span class="n">DateAndFlyNum</span><span class="p">,</span>
    <span class="n">DataFrameOrDataArray</span>
<span class="p">)</span>

<span class="c1"># Note: many imports were pushed down into the beginnings of the functions that</span>
<span class="c1"># use them, to reduce the number of hard dependencies.</span>


<span class="c1"># 1 to indicate computer is an acquisition computer, 0/unset otherwise.</span>
<span class="n">ACQUISITION_ENV_VAR</span> <span class="o">=</span> <span class="s1">&#39;HONG2P_ACQUISITION&#39;</span>

<div class="viewcode-block" id="is_acquisition_host"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.is_acquisition_host">[docs]</a><span class="k">def</span> <span class="nf">is_acquisition_host</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">_is_acquisition_host</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">ACQUISITION_ENV_VAR</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="n">ACQUISITION_ENV_VAR</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span>
            <span class="n">_is_acquisition_host</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">val</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
            <span class="n">_is_acquisition_host</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;invalid value </span><span class="si">{val}</span><span class="s1"> for </span><span class="si">{ACQUISITION_ENV_VAR}</span><span class="s1">. must be &#39;</span>
                <span class="s1">&#39;0 or 1.&#39;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Returns the system/OS name, such as &#39;Linux&#39;,&#39;Darwin&#39;,&#39;Windows&#39;</span>
        <span class="k">if</span> <span class="n">platform</span><span class="o">.</span><span class="n">system</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;Windows&#39;</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;assuming this is an acquisition computer because it is &#39;</span>
                <span class="n">f</span><span class="s1">&#39;windows. set </span><span class="si">{ACQUISITION_ENV_VAR}</span><span class="s1"> to 0/1 to silence this.&#39;</span>
            <span class="p">)</span>
            <span class="n">_is_acquisition_host</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">_is_acquisition_host</span></div>


<span class="c1"># These three environment variables are in priority order (if first defined, it will be</span>
<span class="c1"># the one used).</span>
<span class="n">DATA_ROOT_ENV_VAR</span> <span class="o">=</span> <span class="s1">&#39;HONG2P_DATA&#39;</span>
<span class="n">NAS_PREFIX_ENV_VAR</span> <span class="o">=</span> <span class="s1">&#39;HONG_NAS&#39;</span>

<span class="c1"># If NAS_PREFIX_ENV_VAR is selected (i.e. DATA_ROOT_ENV_VAR is not defined), this is</span>
<span class="c1"># used to find a path on the NAS that would be suiteable as a value for</span>
<span class="c1"># DATA_ROOT_ENV_VAR (it&#39;s where I put my data on the NAS).</span>
<span class="n">NAS_PATH_TO_HONG2P_DATA</span> <span class="o">=</span> <span class="s1">&#39;mb_team&#39;</span>

<span class="c1"># Sets optional faster-storage directory that is checked first (currently just in</span>
<span class="c1"># `raw_fly_dir`).</span>
<span class="n">FAST_DATA_ROOT_ENV_VAR</span> <span class="o">=</span> <span class="s1">&#39;HONG2P_FAST_DATA&#39;</span>

<span class="n">STIMFILE_DIR_ENV_VAR</span> <span class="o">=</span> <span class="s1">&#39;HONG2P_STIMFILE_DIR&#39;</span>

<span class="n">_fast_data_root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Path</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">FAST_DATA_ROOT_ENV_VAR</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">FAST_DATA_ROOT_ENV_VAR</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span> <span class="k">else</span> <span class="kc">None</span>
<span class="p">)</span>
<span class="k">if</span> <span class="n">_fast_data_root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_fast_data_root</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>
    <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{FAST_DATA_ROOT_ENV_VAR}</span><span class="s1"> set but is not a directory&#39;</span><span class="p">)</span>

<span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># TODO maybe move all of these to __init__.py, or at least expose them there?</span>
<span class="c1"># or maybe to a hong2p.py module (maybe importing all of its contents in</span>
<span class="c1"># __init__.py ?)</span>
<span class="c1"># TODO migrate all &#39;prep_date&#39; -&gt; &#39;date&#39;? (seems i already use &#39;date&#39; in a lot</span>
<span class="c1"># of places...)</span>
<span class="n">recording_cols</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;prep_date&#39;</span><span class="p">,</span>
    <span class="s1">&#39;fly_num&#39;</span><span class="p">,</span>
    <span class="s1">&#39;thorimage_id&#39;</span>
<span class="p">]</span>
<span class="n">trial_only_cols</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;comparison&#39;</span><span class="p">,</span>
    <span class="s1">&#39;name1&#39;</span><span class="p">,</span>
    <span class="s1">&#39;name2&#39;</span><span class="p">,</span>
    <span class="s1">&#39;repeat_num&#39;</span>
<span class="p">]</span>
<span class="n">trial_cols</span> <span class="o">=</span> <span class="n">recording_cols</span> <span class="o">+</span> <span class="n">trial_only_cols</span>

<span class="n">date_fmt_str</span> <span class="o">=</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span>
<span class="n">dff_latex</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;$\frac{\Delta F}</span><span class="si">{F}</span><span class="s1">$&#39;</span>


<span class="c1"># Module level cache.</span>
<span class="n">_data_root</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1"># TODO add _fast_data_root setting as kwarg here?</span>
<div class="viewcode-block" id="set_data_root"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.set_data_root">[docs]</a><span class="k">def</span> <span class="nf">set_data_root</span><span class="p">(</span><span class="n">new_data_root</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Sets data root, so future calls to `data_root` will return the input.</span>

<span class="sd">    You may either use this function or set one of the environment variables</span>
<span class="sd">    that the `data_root` function checks.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_data_root</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">isdir</span><span class="p">(</span><span class="n">new_data_root</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{new_data_root}</span><span class="s1"> is not a directory!&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">_data_root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;data_root was already defined. usually set_data_root &#39;</span>
            <span class="s1">&#39;should only need to be called once.&#39;</span>
        <span class="p">)</span>

    <span class="n">_data_root</span> <span class="o">=</span> <span class="n">new_data_root</span></div>


<div class="viewcode-block" id="data_root"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.data_root">[docs]</a><span class="k">def</span> <span class="nf">data_root</span><span class="p">(</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
    <span class="k">global</span> <span class="n">_data_root</span>

    <span class="k">if</span> <span class="n">_data_root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># TODO print priority order of these env vars in any failure below</span>
        <span class="c1"># TODO TODO refactor (to loop, w/ break, probably) to also check if directories</span>
        <span class="c1"># exist before picking one to use?</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">DATA_ROOT_ENV_VAR</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="n">DATA_ROOT_ENV_VAR</span><span class="p">])</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">DATA_ROOT_ENV_VAR</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;found </span><span class="si">{DATA_ROOT_ENV_VAR}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">NAS_PREFIX_ENV_VAR</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="n">NAS_PREFIX_ENV_VAR</span><span class="p">])</span> <span class="o">/</span> <span class="n">NAS_PATH_TO_HONG2P_DATA</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">NAS_PREFIX_ENV_VAR</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;did not find </span><span class="si">{DATA_ROOT_ENV_VAR}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;found </span><span class="si">{NAS_PREFIX_ENV_VAR}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;either set one of the environment variables &#39;</span>
                <span class="n">f</span><span class="s1">&#39;(</span><span class="si">{DATA_ROOT_ENV_VAR}</span><span class="s1"> or </span><span class="si">{NAS_PREFIX_ENV_VAR}</span><span class="s1">) or call &#39;</span>
                <span class="s1">&#39;hong2p.util.set_data_root(&lt;data root&gt;) before this data_root call&#39;</span>
            <span class="p">)</span>

        <span class="n">_data_root</span> <span class="o">=</span> <span class="n">root</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_data_root</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;data root expected at </span><span class="si">{_data_root}</span><span class="s1">, but no directory exists&#39;</span>
                <span class="n">f</span><span class="s1">&#39; there!</span><span class="se">\n</span><span class="s1">Directory chosen from environment variable </span><span class="si">{source}</span><span class="s1">&#39;</span>
            <span class="p">)</span>

    <span class="c1"># TODO err if nothing in data_root, saying which env var to set and how</span>
    <span class="k">return</span> <span class="n">_data_root</span></div>


<div class="viewcode-block" id="check_dir_exists"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.check_dir_exists">[docs]</a><span class="k">def</span> <span class="nf">check_dir_exists</span><span class="p">(</span><span class="n">fn_returning_dir</span><span class="p">):</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">fn_returning_dir</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">optionally_checked_fn_returning_dir</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">create</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">directory</span> <span class="o">=</span> <span class="n">fn_returning_dir</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">isdir</span><span class="p">(</span><span class="n">directory</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">create</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Creating directory </span><span class="si">{directory}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="c1"># This will error if `directory` points to something that exists that</span>
                <span class="c1"># is NOT a directory (as intended).</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">directory</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">check</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;directory </span><span class="si">{directory}</span><span class="s1"> (returned by &#39;</span>
                    <span class="n">f</span><span class="s1">&#39;</span><span class="si">{fn_returning_dir.__name__}</span><span class="s1">) does not exist! check the relevant &#39;</span>
                    <span class="s1">&#39;environment variables are set correctly.&#39;</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">directory</span>

    <span class="k">return</span> <span class="n">optionally_checked_fn_returning_dir</span></div>


<span class="c1"># TODO (for both below) support a local and a remote one ([optional] local copy</span>
<span class="c1"># for faster repeat analysis)?</span>
<span class="c1"># TODO use env var like kc_analysis currently does for prefix after refactoring</span>
<span class="c1"># (include mb_team in that part and rename from data_root?)</span>
<div class="viewcode-block" id="raw_data_root"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.raw_data_root">[docs]</a><span class="nd">@check_dir_exists</span>
<span class="k">def</span> <span class="nf">raw_data_root</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Pathlike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>

    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">data_root</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">root</span> <span class="o">/</span> <span class="s1">&#39;raw_data&#39;</span></div>


<span class="c1"># TODO kwarg / default to makeing dir if not exist (and for similar fns above)?</span>
<div class="viewcode-block" id="analysis_intermediates_root"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.analysis_intermediates_root">[docs]</a><span class="nd">@check_dir_exists</span>
<span class="k">def</span> <span class="nf">analysis_intermediates_root</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
    <span class="c1"># TODO probably prefer using $HONG2P_DATA over os.getcwd() (assuming it&#39;s not on NAS</span>
    <span class="c1"># and it therefore acceptably fast if not instead using $HONG_NAS)</span>
    <span class="k">if</span> <span class="n">_fast_data_root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;environment variable </span><span class="si">{FAST_DATA_ROOT_ENV_VAR}</span><span class="s1"> not set, so &#39;</span>
            <span class="s1">&#39;storing analysis intermediates under current directory&#39;</span>
        <span class="p">)</span>
        <span class="n">intermediates_root_parent</span> <span class="o">=</span> <span class="n">Path</span><span class="o">.</span><span class="n">cwd</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">intermediates_root_parent</span> <span class="o">=</span> <span class="n">_fast_data_root</span>

    <span class="n">intermediates_root</span> <span class="o">=</span> <span class="n">intermediates_root_parent</span> <span class="o">/</span> <span class="s1">&#39;analysis_intermediates&#39;</span>
    <span class="k">return</span> <span class="n">intermediates_root</span></div>


<div class="viewcode-block" id="stimfile_root"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.stimfile_root">[docs]</a><span class="nd">@check_dir_exists</span>
<span class="k">def</span> <span class="nf">stimfile_root</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">STIMFILE_DIR_ENV_VAR</span><span class="p">,</span>
        <span class="n">data_root</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">/</span> <span class="s1">&#39;stimulus_data_files&#39;</span>
    <span class="p">))</span></div>


<span class="c1"># TODO replace this w/ above (need to change kc_natural_mixes / natural_odors, or at</span>
<span class="c1"># least pin an older version of hong2p for them)</span>
<div class="viewcode-block" id="analysis_output_root"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.analysis_output_root">[docs]</a><span class="nd">@check_dir_exists</span>
<span class="k">def</span> <span class="nf">analysis_output_root</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">data_root</span><span class="p">()</span> <span class="o">/</span> <span class="s1">&#39;analysis_output&#39;</span></div>


<div class="viewcode-block" id="IOPerformanceWarning"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.IOPerformanceWarning">[docs]</a><span class="k">class</span> <span class="nc">IOPerformanceWarning</span><span class="p">(</span><span class="ne">Warning</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Warning that data does not seem to be read/written from fast storage</span>
<span class="sd">    &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="format_date"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.format_date">[docs]</a><span class="k">def</span> <span class="nf">format_date</span><span class="p">(</span><span class="n">date</span><span class="p">:</span> <span class="n">Datelike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a pandas Timestamp or something that can be used to construct one</span>
<span class="sd">    and returns a str with the formatted date.</span>

<span class="sd">    Used to name directories by date, etc.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">date</span><span class="p">)</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">date_fmt_str</span><span class="p">)</span></div>


<div class="viewcode-block" id="format_timestamp"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.format_timestamp">[docs]</a><span class="k">def</span> <span class="nf">format_timestamp</span><span class="p">(</span><span class="n">timestamp</span><span class="p">:</span> <span class="n">Datelike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="c1"># TODO example of when this should be used. maybe explicitly say use</span>
    <span class="c1"># `format_date` for dates</span>
    <span class="sd">&quot;&quot;&quot;Returns human-readable str for timestamp accepted by `pd.Timestamp`, to minute.</span>

<span class="sd">    Ex: &#39;2022-04-07 16:53&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">timestamp</span><span class="p">))[:</span><span class="mi">16</span><span class="p">]</span></div>


<span class="c1"># TODO maybe rename to [get_]fly_basedir?</span>
<div class="viewcode-block" id="get_fly_dir"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.get_fly_dir">[docs]</a><span class="k">def</span> <span class="nf">get_fly_dir</span><span class="p">(</span><span class="n">date</span><span class="p">:</span> <span class="n">Datelike</span><span class="p">,</span> <span class="n">fly</span><span class="p">:</span> <span class="n">FlyNum</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns str path fragment as YYYY-MM-DD/&lt;n&gt; for variety of input types</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">date</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">date</span> <span class="o">=</span> <span class="n">format_date</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">fly</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">fly</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">fly</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">Path</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly</span><span class="p">)</span></div>


<div class="viewcode-block" id="raw_fly_dir"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.raw_fly_dir">[docs]</a><span class="k">def</span> <span class="nf">raw_fly_dir</span><span class="p">(</span><span class="n">date</span><span class="p">:</span> <span class="n">Datelike</span><span class="p">,</span> <span class="n">fly</span><span class="p">:</span> <span class="n">FlyNum</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">warn</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">short</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        short: If True, returns in format YYYY-MM-DD/&lt;fly #&gt;/&lt;ThorImage dir&gt;, without</span>
<span class="sd">            the prefix specifying the full path. Intended for creating more readable</span>
<span class="sd">            paths, where absolute paths are not required.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">raw_fly_basedir</span> <span class="o">=</span> <span class="n">get_fly_dir</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly</span><span class="p">)</span>

    <span class="c1"># TODO TODO maybe refactor for more granularity (might need to change a lot of usage</span>
    <span class="c1"># of data_root() and stuff that uses it though... perhaps also functions that</span>
    <span class="c1"># operate on directories like the fn to pair thor dirs)</span>
    <span class="k">if</span> <span class="n">_fast_data_root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fast_raw_fly_dir</span> <span class="o">=</span> <span class="n">raw_data_root</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="n">_fast_data_root</span><span class="p">)</span> <span class="o">/</span> <span class="n">raw_fly_basedir</span>
        <span class="c1"># TODO warn if not using this despite env var being set</span>
        <span class="k">if</span> <span class="n">fast_raw_fly_dir</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">fast_raw_fly_dir</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">warn</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{FAST_DATA_ROOT_ENV_VAR}</span><span class="s1"> set (</span><span class="si">{_fast_data_root}</span><span class="s1">) but &#39;</span>
                    <span class="n">f</span><span class="s1">&#39;raw data directory for fly (</span><span class="si">{date}</span><span class="s1">, </span><span class="si">{fly}</span><span class="s1">) did not exist there&#39;</span><span class="p">,</span>
                    <span class="n">IOPerformanceWarning</span>
                <span class="p">)</span>

    <span class="k">return</span> <span class="n">raw_data_root</span><span class="p">()</span> <span class="o">/</span> <span class="n">raw_fly_basedir</span></div>


<div class="viewcode-block" id="thorimage_dir"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.thorimage_dir">[docs]</a><span class="k">def</span> <span class="nf">thorimage_dir</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly</span><span class="p">,</span> <span class="n">thorimage_id</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">raw_fly_dir</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">/</span> <span class="n">thorimage_id</span></div>


<div class="viewcode-block" id="thorsync_dir"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.thorsync_dir">[docs]</a><span class="k">def</span> <span class="nf">thorsync_dir</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly</span><span class="p">,</span> <span class="n">base_thorsync_dir</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">raw_fly_dir</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">/</span> <span class="n">base_thorsync_dir</span></div>


<div class="viewcode-block" id="thorimage_dir_input"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.thorimage_dir_input">[docs]</a><span class="k">def</span> <span class="nf">thorimage_dir_input</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped_fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">date</span><span class="p">,</span> <span class="n">fly</span><span class="p">,</span> <span class="n">thorimage_id</span> <span class="o">=</span> <span class="n">args</span>

            <span class="n">image_dir</span> <span class="o">=</span> <span class="n">thorimage_dir</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly</span><span class="p">,</span> <span class="n">thorimage_id</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">image_dir</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO maybe just check if dir args[0] exists / if args[0:3] are all</span>
            <span class="c1"># parseable, and then pass thru any remaining args? or would it get too</span>
            <span class="c1"># complicated for too little benefit?</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;functions wrapped with thorimage_dir_input must be &#39;</span>
                <span class="s1">&#39;passed either date, fly_num, thorimage_id OR thorimage_dir&#39;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="n">image_dir</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapped_fn</span></div>


<span class="c1"># TODO use new name in al_pair_grids + also handle fast data dir here.</span>
<span class="c1"># (maybe always returning directories under fast? or kwarg to behave that way?)</span>
<div class="viewcode-block" id="analysis_fly_dir"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.analysis_fly_dir">[docs]</a><span class="k">def</span> <span class="nf">analysis_fly_dir</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">analysis_output_root</span><span class="p">()</span> <span class="o">/</span> <span class="n">get_fly_dir</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly</span><span class="p">)</span></div>


<span class="c1"># TODO maybe this should stay returning a str? i&#39;m assuming a lot of what i do with this</span>
<span class="c1"># is print it / format it? or change to Path to be consistent w/ other path fns now?</span>
<div class="viewcode-block" id="shorten_path"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.shorten_path">[docs]</a><span class="k">def</span> <span class="nf">shorten_path</span><span class="p">(</span><span class="n">full_path</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">,</span> <span class="n">n_parts</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a string containing just the last n_parts (default=3) of input path.</span>

<span class="sd">    For making IDs / easier-to-read paths, when the full path isn&#39;t required.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s1">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="n">full_path</span><span class="p">)</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="n">n_parts</span><span class="p">:])</span></div>


<div class="viewcode-block" id="print_thor_paths"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.print_thor_paths">[docs]</a><span class="k">def</span> <span class="nf">print_thor_paths</span><span class="p">(</span><span class="n">image_dir</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">,</span> <span class="n">sync_dir</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">,</span> <span class="n">print_full_paths</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

    <span class="k">if</span> <span class="n">print_full_paths</span><span class="p">:</span>
        <span class="n">image_dir_toprint</span> <span class="o">=</span> <span class="n">image_dir</span>
        <span class="n">sync_dir_toprint</span> <span class="o">=</span> <span class="n">sync_dir</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">image_dir_toprint</span> <span class="o">=</span> <span class="n">shorten_path</span><span class="p">(</span><span class="n">image_dir</span><span class="p">)</span>
        <span class="n">sync_dir_toprint</span> <span class="o">=</span> <span class="n">shorten_path</span><span class="p">(</span><span class="n">sync_dir</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;thorimage_dir:&#39;</span><span class="p">,</span> <span class="n">image_dir_toprint</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;thorsync_dir:&#39;</span><span class="p">,</span> <span class="n">sync_dir_toprint</span><span class="p">)</span></div>


<span class="c1"># TODO maybe rename suffix here / thor.pair_thor_subdirs(-&gt;_dirs) for</span>
<span class="c1"># consistency. i think i was already thinking consolidating/renaming those two</span>
<span class="c1"># thor functions</span>
<span class="c1"># TODO maybe it would be better to have this return a data frame? maybe add</span>
<span class="c1"># another fn that converts output of this to that?</span>
<span class="c1"># TODO maybe also allow specification of optional third/additional keys to</span>
<span class="c1"># restrict to only some thorimage / thorsync dirs for a subset? or maybe it&#39;d</span>
<span class="c1"># make more sense to add other functions for blacklisting/whitelisting stuff?</span>
<span class="c1"># TODO TODO function like this but that returns everything, with kwargs for only getting</span>
<span class="c1"># stuff between a start and end date (w/ end date not specified as well, for analyzing</span>
<span class="c1"># ongoing experiments)</span>
<div class="viewcode-block" id="date_fly_list2paired_thor_dirs"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.date_fly_list2paired_thor_dirs">[docs]</a><span class="k">def</span> <span class="nf">date_fly_list2paired_thor_dirs</span><span class="p">(</span><span class="n">date_fly_list</span><span class="p">,</span> <span class="n">n_first</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">print_full_paths</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">pair_kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">DateAndFlyNum</span><span class="p">,</span> <span class="n">PathPair</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span>
    <span class="kc">None</span><span class="p">]:</span>
    <span class="c1"># TODO add code example to doc</span>
    <span class="sd">&quot;&quot;&quot;Takes list of (date, fly_num) tuples to pairs of their Thor outputs.</span>

<span class="sd">    Args:</span>
<span class="sd">        date_fly_list (list of (date-like, int)): (date, fly number) tuples</span>

<span class="sd">        n_first (None | int): If passed, only up to this many of pairs are enumerated.</span>
<span class="sd">            Intended for testing on subsets of data.</span>

<span class="sd">        verbose (bool): (default=False) If True, prints the fly/ThorImage/ThorSync</span>
<span class="sd">            directories as they are being iterated over.</span>

<span class="sd">        **pair_kwargs: Passed through to `thor.pair_thor_subdirs`. See arguments to</span>
<span class="sd">            `thor.pair_thor_dirs` (called by `thor.pair_thor_subdirs`) for most of the</span>
<span class="sd">            useful options.</span>

<span class="sd">    Each output is of the form:</span>
<span class="sd">    ((date, fly_num), (thorimage_dir&lt;i&gt;, thorsync_dir&lt;i&gt;))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n_first</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;only returning first </span><span class="si">{n_first}</span><span class="s1"> paired Thor[Image/Sync] outputs&#39;</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">date</span><span class="p">,</span> <span class="n">fly_num</span> <span class="ow">in</span> <span class="n">date_fly_list</span><span class="p">:</span>
        <span class="n">fly_dir</span> <span class="o">=</span> <span class="n">raw_fly_dir</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly_num</span><span class="p">)</span>

        <span class="c1"># TODO if verbose and ignore is in pair_kwargs, maybe thread some other</span>
        <span class="c1"># arguments through such that we can have the inner function print just which</span>
        <span class="c1"># pairs it is ignoring? (or [opt to] return them from pair_thor_subdirs and then</span>
        <span class="c1"># print here?)</span>

        <span class="n">paired_thor_dirs</span> <span class="o">=</span> <span class="n">thor</span><span class="o">.</span><span class="n">pair_thor_subdirs</span><span class="p">(</span><span class="n">fly_dir</span><span class="p">,</span> <span class="o">**</span><span class="n">pair_kwargs</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">image_dir</span><span class="p">,</span> <span class="n">sync_dir</span> <span class="ow">in</span> <span class="n">paired_thor_dirs</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">n_first</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">n_first</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">print_thor_paths</span><span class="p">(</span><span class="n">image_dir</span><span class="p">,</span> <span class="n">sync_dir</span><span class="p">,</span> <span class="n">print_full_paths</span><span class="o">=</span><span class="n">print_full_paths</span><span class="p">)</span>

            <span class="k">yield</span> <span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly_num</span><span class="p">),</span> <span class="p">(</span><span class="n">image_dir</span><span class="p">,</span> <span class="n">sync_dir</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span></div>


<span class="c1"># TODO TODO merge date_fly_list2paired_thor_dirs into this or just delete that and add</span>
<span class="c1"># kwarg here to replace above (too similar)</span>
<div class="viewcode-block" id="paired_thor_dirs"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.paired_thor_dirs">[docs]</a><span class="k">def</span> <span class="nf">paired_thor_dirs</span><span class="p">(</span><span class="n">matching_substrs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">start_date</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Datelike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">end_date</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Datelike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_first</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">skip_redone</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">print_skips</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">print_fast</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">print_full_paths</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">pair_kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">DateAndFlyNum</span><span class="p">,</span> <span class="n">PathPair</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="c1"># TODO add code example to doc</span>
    <span class="sd">&quot;&quot;&quot;Generates tuples of fly metadata and ThorImage output paths, in acquisition order</span>

<span class="sd">    Args:</span>
<span class="sd">        matching_substrs: If passed, only experiments whose ThorImage path contains at</span>
<span class="sd">            least one of these substring will be included.</span>

<span class="sd">        n_first: If passed, only up to this many of pairs are enumerated.</span>
<span class="sd">            Intended for testing on subsets of data.</span>

<span class="sd">        verbose: If True, prints the fly/ThorImage/ThorSync directories as they are</span>
<span class="sd">            being iterated over.</span>

<span class="sd">        **pair_kwargs: Passed through to `thor.pair_thor_subdirs`. See arguments to</span>
<span class="sd">            `thor.pair_thor_dirs` (called by `thor.pair_thor_subdirs`) for most of the</span>
<span class="sd">            useful options.</span>

<span class="sd">    Each output is of the form:</span>
<span class="sd">    ((date, fly_num), (thorimage_dir&lt;i&gt;, thorsync_dir&lt;i&gt;))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n_first</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;only returning first </span><span class="si">{n_first}</span><span class="s1"> paired Thor[Image/Sync] outputs&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">start_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">start_date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">start_date</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">end_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">end_date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">end_date</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">grandchildren</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="c1"># Returns without the trailing &#39;/&#39; glob would normally add using this syntax.</span>
        <span class="c1"># TODO replace join w/ pathlib alternative</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">split</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s1">&#39;*/*/&#39;</span><span class="p">))]</span>

    <span class="k">def</span> <span class="nf">date_fly_parts</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="n">rest</span><span class="p">,</span> <span class="n">fly_part</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">date_part</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">date_part</span><span class="p">,</span> <span class="n">fly_part</span>

    <span class="k">if</span> <span class="n">_fast_data_root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">candidate_grandchildren</span> <span class="o">=</span> <span class="n">grandchildren</span><span class="p">(</span><span class="n">raw_data_root</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="n">_fast_data_root</span><span class="p">))</span>
        <span class="n">fast_parts</span> <span class="o">=</span> <span class="p">{</span><span class="n">date_fly_parts</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">candidate_grandchildren</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">candidate_grandchildren</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Set of tuples representing deepest-level (&quot;leaf&quot;) directories under</span>
        <span class="c1"># `_fast_data_root`.</span>
        <span class="n">fast_parts</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">gs</span> <span class="o">=</span> <span class="n">grandchildren</span><span class="p">(</span><span class="n">raw_data_root</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gs</span><span class="p">:</span>
        <span class="n">date_fly</span> <span class="o">=</span> <span class="n">date_fly_parts</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">date_fly</span> <span class="ow">in</span> <span class="n">fast_parts</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">print_fast</span><span class="p">:</span>
                <span class="c1"># TODO maybe just warn for any we aren&#39;t using fast for (assuming we are</span>
                <span class="c1"># using fast for *any*), and generally don&#39;t print</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;not using </span><span class="si">{g}</span><span class="s1"> because had equivalent fast dir under &#39;</span>
                    <span class="n">f</span><span class="s1">&#39;</span><span class="si">{_fast_data_root}</span><span class="s1">&#39;</span>
                <span class="p">)</span>

            <span class="k">continue</span>
        <span class="n">candidate_grandchildren</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

    <span class="c1"># Sorting on (date, fly) parts (to the extent that&#39;s what they are)</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">candidate_grandchildren</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">g</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]):</span>
        <span class="n">date_part</span><span class="p">,</span> <span class="n">fly_part</span> <span class="o">=</span> <span class="n">date_fly_parts</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">fly_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fly_part</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">print_skips</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;skipping </span><span class="si">{d}</span><span class="s1"> because could not parse fly_num from </span><span class="si">{fly_part}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">continue</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">date_part</span><span class="p">,</span> <span class="n">date_fmt_str</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">print_skips</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;skipping </span><span class="si">{d}</span><span class="s1"> because could not parse date from </span><span class="si">{date_part}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">start_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">date</span> <span class="o">&lt;</span> <span class="n">start_date</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">print_skips</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;skipping </span><span class="si">{d}</span><span class="s1"> because earlier than {format_date(start_date)}&#39;</span><span class="p">)</span>

            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">end_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end_date</span> <span class="o">&lt;</span> <span class="n">date</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">print_skips</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;skipping </span><span class="si">{d}</span><span class="s1"> because later than {format_date(end_date)}&#39;</span><span class="p">)</span>

            <span class="k">continue</span>

        <span class="c1"># TODO if verbose and ignore is in pair_kwargs, maybe thread some other</span>
        <span class="c1"># arguments through such that we can have the inner function print just which</span>
        <span class="c1"># pairs it is ignoring? (or [opt to] return them from pair_thor_subdirs and then</span>
        <span class="c1"># print here?)</span>

        <span class="n">fly_dir</span> <span class="o">=</span> <span class="n">raw_fly_dir</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly_num</span><span class="p">)</span>

        <span class="n">paired_dirs</span> <span class="o">=</span> <span class="n">thor</span><span class="o">.</span><span class="n">pair_thor_subdirs</span><span class="p">(</span><span class="n">fly_dir</span><span class="p">,</span> <span class="o">**</span><span class="n">pair_kwargs</span><span class="p">)</span>

        <span class="c1"># TODO generalize to also match and similarly handle ThorImage-autogenerated</span>
        <span class="c1"># number suffixes that typically mean the same thing (though check the behavior</span>
        <span class="c1"># of diff ThorImage versions is supported)</span>
        <span class="k">if</span> <span class="n">skip_redone</span><span class="p">:</span>
            <span class="n">redo_suffix</span> <span class="o">=</span> <span class="s1">&#39;_redo&#39;</span>
            <span class="n">redone_thorimage_dirs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="c1"># TODO pathlib alternatives for these str ops?</span>
                <span class="n">Path</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ti</span><span class="p">)[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">redo_suffix</span><span class="p">)])</span> <span class="k">for</span> <span class="n">ti</span><span class="p">,</span> <span class="n">td</span> <span class="ow">in</span> <span class="n">paired_dirs</span>
                <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">ti</span><span class="p">)</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">redo_suffix</span><span class="p">)</span>
            <span class="p">}</span>

        <span class="k">for</span> <span class="n">image_dir</span><span class="p">,</span> <span class="n">sync_dir</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">paired_dirs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span>
            <span class="n">thor</span><span class="o">.</span><span class="n">get_thorimage_time</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>

            <span class="k">if</span> <span class="n">matching_substrs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">matching_substrs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">image_dir</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">matching_substrs</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">print_skips</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;skipping </span><span class="si">{image_dir}</span><span class="s1"> because did not contain &gt;=1 of &#39;</span>
                            <span class="n">f</span><span class="s1">&#39;matching_substrs=&quot;</span><span class="si">{matching_substrs}</span><span class="s1">&quot;&#39;</span>
                        <span class="p">)</span>
                    <span class="k">continue</span>

            <span class="k">if</span> <span class="n">skip_redone</span> <span class="ow">and</span> <span class="n">image_dir</span> <span class="ow">in</span> <span class="n">redone_thorimage_dirs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">print_skips</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;skipping </span><span class="si">{image_dir}</span><span class="s1"> because matching redo exists</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">n_first</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">n_first</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">print_thor_paths</span><span class="p">(</span><span class="n">image_dir</span><span class="p">,</span> <span class="n">sync_dir</span><span class="p">,</span> <span class="n">print_full_paths</span><span class="o">=</span><span class="n">print_full_paths</span><span class="p">)</span>

            <span class="k">yield</span> <span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly_num</span><span class="p">),</span> <span class="p">(</span><span class="n">image_dir</span><span class="p">,</span> <span class="n">sync_dir</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span></div>


<span class="k">def</span> <span class="nf">_raw_data_root_grandchildren</span><span class="p">():</span>
    <span class="c1"># TODO replace join w/ pathlib alternative</span>
    <span class="k">return</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">raw_data_root</span><span class="p">(),</span> <span class="s1">&#39;*/*/&#39;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_all_thorimage_dirs</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns list of all ThorImage directories two levels under data root (where</span>
<span class="sd">    they should be given my folder structure conventions).</span>

<span class="sd">    For testing functions on all of the data under the root.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO fix so it&#39;s actually all children of these directories</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">_raw_data_root_grandchildren</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">thor</span><span class="o">.</span><span class="n">is_thorimage_dir</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="p">]</span>


<span class="k">def</span> <span class="nf">_all_thorsync_dirs</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns list of all ThorSync directories two levels under data root (where</span>
<span class="sd">    they should be given my folder structure conventions).</span>

<span class="sd">    For testing functions on all of the data under the root.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO fix so it&#39;s actually all children of these directories</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">_raw_data_root_grandchildren</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">thor</span><span class="o">.</span><span class="n">is_thorsync_dir</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="p">]</span>


<span class="k">def</span> <span class="nf">_all_paired_thor_dirs</span><span class="p">(</span><span class="n">skip_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">PathPair</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of all (ThorImage, ThorSync) directories that can be paired</span>
<span class="sd">    (i.e. determined to come from the same experiment) and that are both</span>
<span class="sd">    immediate children of (the same) one of the directories returned by</span>
<span class="sd">    `_raw_data_root_grandchildren()`.</span>

<span class="sd">    skip_errors (bool): (default=True) if False, will raise any caught</span>
<span class="sd">        `ValueError` rather than skipping results and continuing</span>

<span class="sd">    `kwargs` are passed to `thor.pair_thor_subdirs`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_pairs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">_raw_data_root_grandchildren</span><span class="p">():</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">d_pairs</span> <span class="o">=</span> <span class="n">thor</span><span class="o">.</span><span class="n">pair_thor_subdirs</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">skip_errors</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>

        <span class="n">all_pairs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">d_pairs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">all_pairs</span>


<span class="k">def</span> <span class="nf">_stimfile_dir</span><span class="p">(</span><span class="n">stimfile_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">stimfile_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">stimfile_dir</span> <span class="o">=</span> <span class="n">stimfile_root</span><span class="p">()</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">isdir</span><span class="p">(</span><span class="n">stimfile_dir</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;passed stimfile_dir=</span><span class="si">{stimfile_dir}</span><span class="s1"> is not a directory!&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">stimfile_dir</span>


<div class="viewcode-block" id="shorten_stimfile_path"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.shorten_stimfile_path">[docs]</a><span class="k">def</span> <span class="nf">shorten_stimfile_path</span><span class="p">(</span><span class="n">stimfile_path</span><span class="p">,</span> <span class="n">stimfile_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Shortens absolute stimulus YAML path to one relative to stimfile_dir.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stimfile_dir</span> <span class="o">=</span> <span class="n">_stimfile_dir</span><span class="p">(</span><span class="n">stimfile_dir</span><span class="p">)</span>
    <span class="c1"># TODO convert to a pathlib call</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">stimfile_path</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">stimfile_dir</span><span class="p">))</span>

    <span class="c1"># + 1 to also exclude the os.sep character separating parent dir and relative</span>
    <span class="c1"># stimfile path.</span>
    <span class="c1"># TODO convert to pathlib</span>
    <span class="k">return</span> <span class="n">stimfile_path</span><span class="p">[(</span><span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">stimfile_dir</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):]</span></div>


<div class="viewcode-block" id="stimulus_yaml_from_thorimage"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.stimulus_yaml_from_thorimage">[docs]</a><span class="k">def</span> <span class="nf">stimulus_yaml_from_thorimage</span><span class="p">(</span><span class="n">thorimage_dir_or_xml</span><span class="p">,</span> <span class="n">stimfile_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns absolute path to stimulus YAML file from note field in ThorImage XML.</span>

<span class="sd">    Args:</span>
<span class="sd">        thorimage_dir_or_xml: path to ThorImage output directory or XML Element</span>
<span class="sd">            containing parsed contents of the corresponding Experiment.xml file.</span>

<span class="sd">        stimfile_dir (str): (optional) directory containing stimulus .yaml files.</span>
<span class="sd">            If not passed, `stimfile_root()` is used.</span>

<span class="sd">    Raises:</span>
<span class="sd">        IOError if stimulus file directory does not exist</span>
<span class="sd">        ValueError if multiple or no substrings of note field end with .yaml</span>

<span class="sd">    XML should contain a manually-entered path relative to where the olfactometer code</span>
<span class="sd">    that generated it was run, but assuming it was copied to the appropriate location</span>
<span class="sd">    (directly under `stimfile_dir` if passed or `stimfile_root()` otherwise), this</span>
<span class="sd">    absolute path should exist.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stimfile_dir</span> <span class="o">=</span> <span class="n">_stimfile_dir</span><span class="p">(</span><span class="n">stimfile_dir</span><span class="p">)</span>

    <span class="n">notes</span> <span class="o">=</span> <span class="n">thor</span><span class="o">.</span><span class="n">get_thorimage_notes</span><span class="p">(</span><span class="n">thorimage_dir_or_xml</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">thorimage_dir_or_xml</span><span class="p">,</span> <span class="n">etree</span><span class="o">.</span><span class="n">Element</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">thor</span><span class="o">.</span><span class="n">get_thorimage_name</span><span class="p">(</span><span class="n">thorimage_dir_or_xml</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">thorimage_dir_or_xml</span>

    <span class="n">yaml_path</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">notes</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.yaml&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">yaml_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{name}</span><span class="s1">: encountered multiple *.yaml substrings!&#39;</span><span class="p">)</span>

            <span class="n">yaml_path</span> <span class="o">=</span> <span class="n">p</span>

    <span class="k">if</span> <span class="n">yaml_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{name}</span><span class="s1">: no string ending in .yaml found in ThorImage note &#39;</span>
            <span class="s1">&#39;field&#39;</span>
        <span class="p">)</span>

    <span class="k">assert</span> <span class="n">yaml_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="c1"># TODO change data that has this to expand paths + delete this hack</span>
    <span class="k">if</span> <span class="s1">&#39;&quot;&quot;&#39;</span> <span class="ow">in</span> <span class="n">yaml_path</span><span class="p">:</span>
        <span class="n">date_str</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">yaml_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[:</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">old_yaml_path</span> <span class="o">=</span> <span class="n">yaml_path</span>
        <span class="n">yaml_path</span> <span class="o">=</span> <span class="n">yaml_path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&quot;&quot;&#39;</span><span class="p">,</span> <span class="n">date_str</span><span class="p">)</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{name}</span><span class="s1">: replacing of stimulus YAML path of </span><span class="si">{old_yaml_path}</span><span class="s1"> &#39;</span>
            <span class="n">f</span><span class="s1">&#39;with </span><span class="si">{yaml_path}</span><span class="s1">&#39;</span>
        <span class="p">)</span>
    <span class="c1">#</span>

    <span class="c1"># Since paths copied/pasted within Windows may have &#39;\&#39; as a file</span>
    <span class="c1"># separator character.</span>
    <span class="n">yaml_path</span> <span class="o">=</span> <span class="n">yaml_path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">stimfile_dir</span><span class="p">,</span> <span class="n">yaml_path</span><span class="p">)):</span>
        <span class="n">prefix</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">yaml_path</span><span class="p">)</span>
        <span class="n">yaml_dir</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">prefix</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[:</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">subdir_path</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">stimfile_dir</span><span class="p">,</span> <span class="n">yaml_dir</span><span class="p">,</span> <span class="n">yaml_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">subdir_path</span><span class="p">):</span>
            <span class="n">yaml_path</span> <span class="o">=</span> <span class="n">subdir_path</span>

    <span class="n">yaml_abspath</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">stimfile_dir</span><span class="p">,</span> <span class="n">yaml_path</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">yaml_abspath</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{name}</span><span class="s1"> references </span><span class="si">{yaml_path}</span><span class="s1">, but it did not &#39;</span>
            <span class="n">f</span><span class="s1">&#39;exist under stimfile_dir=</span><span class="si">{stimfile_dir}</span><span class="s1">&#39;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">yaml_abspath</span></div>


<div class="viewcode-block" id="thorimage2yaml_info_and_odor_lists"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.thorimage2yaml_info_and_odor_lists">[docs]</a><span class="k">def</span> <span class="nf">thorimage2yaml_info_and_odor_lists</span><span class="p">(</span><span class="n">thorimage_dir_or_xml</span><span class="p">,</span> <span class="n">stimfile_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns yaml_path, yaml_data, odor_lists</span>

<span class="sd">    Args:</span>
<span class="sd">        thorimage_dir_or_xml: path to ThorImage output directory or XML Element object</span>
<span class="sd">            parsed from corresponding Experiment.xml file</span>

<span class="sd">        stimfile_dir (str): (optional) directory containing stimulus .yaml files.</span>
<span class="sd">            If not passed, `stimfile_root()` is used.</span>

<span class="sd">    Returns:</span>
<span class="sd">        yaml_path (str): path to YAML</span>

<span class="sd">        yaml_data (dict): loaded contents of `yaml_path`</span>

<span class="sd">        odor_lists (list-of-lists-of-dicts): each list this contains is a representation</span>
<span class="sd">            of all the odors presented together on a given trial</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">yaml_path</span> <span class="o">=</span> <span class="n">stimulus_yaml_from_thorimage</span><span class="p">(</span><span class="n">thorimage_dir_or_xml</span><span class="p">,</span>
        <span class="n">stimfile_dir</span><span class="o">=</span><span class="n">stimfile_dir</span>
    <span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">yaml_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">yaml_data</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="n">odor_lists</span> <span class="o">=</span> <span class="n">olf</span><span class="o">.</span><span class="n">yaml_data2odor_lists</span><span class="p">(</span><span class="n">yaml_data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">yaml_path</span><span class="p">,</span> <span class="n">yaml_data</span><span class="p">,</span> <span class="n">odor_lists</span></div>


<div class="viewcode-block" id="most_recent_contained_file_mtime"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.most_recent_contained_file_mtime">[docs]</a><span class="k">def</span> <span class="nf">most_recent_contained_file_mtime</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Recursively find the `os.path.getmtime` of the most recently modified file</span>

<span class="sd">    Testing on Ubuntu, this does not recurse into symlinks to directories, as I want for</span>
<span class="sd">    at least current use case.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO maybe need to actively exclude mtime on symlinks (to directories at least?)</span>
    <span class="c1"># because it will still have an mtime, but i forget whether it tracks the mtime of</span>
    <span class="c1"># the referenced directory, or whether it is just when the link is created...</span>
    <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">rglob</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">is_file</span><span class="p">()]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">getmtime</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">)</span></div>


<span class="c1"># TODO maybe accept dict of names / values? which pd fn to copy the interfact of</span>
<span class="c1"># names/values from (DataFrame creation probably)?</span>
<div class="viewcode-block" id="addlevel"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.addlevel">[docs]</a><span class="k">def</span> <span class="nf">addlevel</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Add level to pandas MultiIndex</span>

<span class="sd">    Intended to be an inverse to pandas.DataFrame.droplevel. pandas.DataFrame.set_index</span>
<span class="sd">    with `append=True` would work *except* that there is no `axis` kwarg to that</span>
<span class="sd">    function, so it does not work for the columns. pandas.DataFrame.unstack is almost</span>
<span class="sd">    what I would want, but it can seemingly arbitrarily change order of rows.</span>

<span class="sd">    Args:</span>
<span class="sd">        df: DataFrame to add MultiIndex levels to</span>
<span class="sd">        names: `str`/sequence-of-`str` name(s) for the new levels</span>
<span class="sd">        values: values for the new levels. If `names` is a sequence, this should be of</span>
<span class="sd">            the same length.</span>
<span class="sd">        axis: 0/&#39;index&#39; or 1/&#39;columns&#39;, defauling to &#39;index&#39; as in pandas</span>

<span class="sd">    Returns: DataFrame with MultiIndex containing names/levels from input</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># https://stackoverflow.com/questions/14744068</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">values</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">values</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">],</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">value</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="is_array_sorted"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.is_array_sorted">[docs]</a><span class="k">def</span> <span class="nf">is_array_sorted</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns whether 1-dimensional np.ndarray is sorted.&quot;&quot;&quot;</span>
    <span class="c1"># could implement an `axis` kwarg if i wanted to support multidimensional</span>
    <span class="c1"># arrays</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;only 1-dimensional arrays supported&#39;</span>
    <span class="c1"># https://stackoverflow.com/questions/47004506</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">array</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span></div>


<div class="viewcode-block" id="print_block_frames"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.print_block_frames">[docs]</a><span class="k">def</span> <span class="nf">print_block_frames</span><span class="p">(</span><span class="n">block_first_frames</span><span class="p">,</span> <span class="n">block_last_frames</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Prints block numbers and the corresponding start / stop frames.</span>

<span class="sd">    For subsetting TIFF in ImageJ / other manual analysis.</span>

<span class="sd">    Prints frame numbers 1-indexed, but takes 0-indexed frames.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Block frames:&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">b_first</span><span class="p">,</span> <span class="n">b_last</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">block_first_frames</span><span class="p">,</span>
        <span class="n">block_last_frames</span><span class="p">)):</span>
        <span class="c1"># Adding one to index frames as in ImageJ.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1"> - </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">b_first</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b_last</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="md5"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.md5">[docs]</a><span class="k">def</span> <span class="nf">md5</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates MD5 hash on file with name `fname`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hash_md5</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">()</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4096</span><span class="p">),</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
            <span class="n">hash_md5</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hash_md5</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span></div>


<span class="c1"># TODO move to project specific repo</span>
<div class="viewcode-block" id="odorset_name"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.odorset_name">[docs]</a><span class="k">def</span> <span class="nf">odorset_name</span><span class="p">(</span><span class="n">df_or_odornames</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns name for set of odors in DataFrame.</span>

<span class="sd">    Looks at odors in original_name1 column. Name used to lookup desired</span>
<span class="sd">    plotting order for the odors in the set.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;original_name1&#39;</span> <span class="ow">in</span> <span class="n">df_or_odornames</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">unique_odornames</span> <span class="o">=</span> <span class="n">df_or_odornames</span><span class="o">.</span><span class="n">original_name1</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            <span class="n">abbreviated</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="s1">&#39;name1&#39;</span> <span class="ow">in</span> <span class="n">df_or_odornames</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> \
                <span class="s1">&#39;need either original_name1 or name1 in df columns&#39;</span>
            <span class="c1"># Assuming abbreviated names now.</span>
            <span class="n">unique_odornames</span> <span class="o">=</span> <span class="n">df_or_odornames</span><span class="o">.</span><span class="n">name1</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            <span class="c1"># maybe don&#39;t assume abbreviated just b/c name1?</span>
            <span class="c1"># (particularly if supporting abbrev/not in iterable input</span>
            <span class="c1"># case, could also check name1 contents)</span>
            <span class="n">abbreviated</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">unique_odornames</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">df_or_odornames</span><span class="p">)</span>
        <span class="c1"># TODO maybe also support abbreviated names in this case?</span>
        <span class="n">abbreviated</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">odor_set</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># TODO TODO derive these diagnostic odors from odor_set2order? would that</span>
    <span class="c1"># still be redundant w/ something else i hardcoded (if so, further</span>
    <span class="c1"># de-dupe)?</span>
    <span class="c1"># TODO at least lookup abbreviations from full names?</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">abbreviated</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;ethyl butyrate&#39;</span> <span class="ow">in</span> <span class="n">unique_odornames</span><span class="p">:</span>
            <span class="n">odor_set</span> <span class="o">=</span> <span class="s1">&#39;kiwi&#39;</span>
        <span class="k">elif</span> <span class="s1">&#39;acetoin&#39;</span> <span class="ow">in</span> <span class="n">unique_odornames</span><span class="p">:</span>
            <span class="n">odor_set</span> <span class="o">=</span> <span class="s1">&#39;flyfood&#39;</span>
        <span class="k">elif</span> <span class="s1">&#39;1-octen-3-ol&#39;</span> <span class="ow">in</span> <span class="n">unique_odornames</span><span class="p">:</span>
            <span class="n">odor_set</span> <span class="o">=</span> <span class="s1">&#39;control&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;eb&#39;</span> <span class="ow">in</span> <span class="n">unique_odornames</span><span class="p">:</span>
            <span class="n">odor_set</span> <span class="o">=</span> <span class="s1">&#39;kiwi&#39;</span>
        <span class="k">elif</span> <span class="s1">&#39;atoin&#39;</span> <span class="ow">in</span> <span class="n">unique_odornames</span><span class="p">:</span>
            <span class="n">odor_set</span> <span class="o">=</span> <span class="s1">&#39;flyfood&#39;</span>
        <span class="k">elif</span> <span class="s1">&#39;1o3ol&#39;</span> <span class="ow">in</span> <span class="n">unique_odornames</span><span class="p">:</span>
            <span class="n">odor_set</span> <span class="o">=</span> <span class="s1">&#39;control&#39;</span>

    <span class="k">if</span> <span class="n">odor_set</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;none of diagnostic odors in odor column&#39;</span><span class="p">)</span>

    <span class="c1"># TODO probably just find single odor that satisfies is_mix and derive from</span>
    <span class="c1"># that, for more generality (would only work in original name case)</span>
    <span class="k">return</span> <span class="n">odor_set</span></div>


<div class="viewcode-block" id="load_stimfile"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.load_stimfile">[docs]</a><span class="k">def</span> <span class="nf">load_stimfile</span><span class="p">(</span><span class="n">stimfile_path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Loads odor metadata stored in a pickle.</span>

<span class="sd">    These metadata files are generated by scripts under</span>
<span class="sd">    `ejhonglab/cutpast_arduino_stimuli`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO better check for path already containing stimfile_root?</span>
    <span class="c1"># string prefix check might be too fragile...</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">stimfile_path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">stimfile_root</span><span class="p">()):</span>
        <span class="n">stimfile_path</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">stimfile_root</span><span class="p">(),</span> <span class="n">stimfile_path</span><span class="p">)</span>

    <span class="c1"># TODO also err if not readable / valid</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">stimfile_path</span><span class="p">):</span>
        <span class="n">stimfile_just_fname</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">stimfile_path</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;copy missing stimfile </span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">stimfile_just_fname</span><span class="p">,</span> <span class="n">stimfile_root</span>
        <span class="p">))</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">stimfile_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span></div>


<span class="c1"># TODO either generalize / allow passing additional functions / keys or move to</span>
<span class="c1"># project specific repo</span>
<span class="c1"># TODO delete (subsuming contents into load_experiment) if i&#39;d never want to</span>
<span class="c1"># call this in other circumstances</span>
<span class="c1"># TODO can this be generalized nicely to load YAML files output by my newer</span>
<span class="c1"># olfactometer code?</span>
<div class="viewcode-block" id="load_odor_metadata"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.load_odor_metadata">[docs]</a><span class="k">def</span> <span class="nf">load_odor_metadata</span><span class="p">(</span><span class="n">stimfile_path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns odor metadata loaded from pickle and additional computed values.</span>

<span class="sd">    Additional values are added into the dictionary loaded from the pickle.</span>
<span class="sd">    In some cases, this can overwrite the loaded values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">load_stimfile</span><span class="p">(</span><span class="n">stimfile_path</span><span class="p">)</span>
    <span class="c1"># TODO infer from data if no stimfile and not specified in</span>
    <span class="c1"># metadata (is there actually any value in this? maybe if we have</span>
    <span class="c1"># a sufficient amount of other data about the odor order in metadata</span>
    <span class="c1"># yaml (though this is not supported now...)?)</span>

    <span class="c1"># TODO delete this hack (which is currently just using new pickle</span>
    <span class="c1"># format as a proxy for the experiment being a supermixture experiment)</span>
    <span class="k">if</span> <span class="s1">&#39;odor_lists&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">pair_case</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># The 3 is because 3 odors are compared in each repeat for the</span>
        <span class="c1"># natural_odors odor-pair experiments.</span>
        <span class="n">presentations_per_repeat</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">odor_list</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;odor_pair_list&#39;</span><span class="p">]</span>

        <span class="c1"># could delete eventually. b/c originally i was casting to int,</span>
        <span class="c1"># though it&#39;s likely it was always int anyway...</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_repeats&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">int</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pair_case</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">n_expected_real_blocks</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">odor_list</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;odor_lists&#39;</span><span class="p">]</span>
        <span class="c1"># because of &quot;block&quot; def in arduino / get_stiminfo code</span>
        <span class="c1"># not matching def in randomizer / stimfile code</span>
        <span class="c1"># (scopePin pulses vs. randomization units, depending on settings)</span>
        <span class="n">presentations_per_repeat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">odor_list</span><span class="p">)</span> <span class="o">//</span> <span class="n">n_expected_real_blocks</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">odor_list</span><span class="p">)</span> <span class="o">%</span> <span class="n">n_expected_real_blocks</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="c1"># Hardcode to break up into more blocks, to align defs of blocks.</span>
        <span class="c1"># TODO (maybe just for experiments on 2019-07-25 ?) or change block</span>
        <span class="c1"># handling in here? make more flexible?</span>

        <span class="c1"># Will overwrite existing value.</span>
        <span class="k">assert</span> <span class="s1">&#39;n_repeats&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_repeats&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># TODO check that overwriting of presentations_per_block with newest</span>
        <span class="c1"># data in this case is still accurate (post fixing some of the values</span>
        <span class="c1"># in pickle data) (also check similar values)</span>

    <span class="n">presentations_per_block</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_repeats&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">presentations_per_repeat</span>

    <span class="c1"># Overwriting exisiting value.</span>
    <span class="k">assert</span> <span class="s1">&#39;presentations_per_block&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;presentations_per_block&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">presentations_per_block</span>

    <span class="c1"># NOT overwriting an existing value.</span>
    <span class="k">assert</span> <span class="s1">&#39;pair_case&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;pair_case&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pair_case</span>

    <span class="c1"># NOT overwriting existing value.</span>
    <span class="k">assert</span> <span class="s1">&#39;presentations_per_repeat&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;presentations_per_repeat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">presentations_per_repeat</span>

    <span class="c1"># NOT overwriting an existing value.</span>
    <span class="k">assert</span> <span class="s1">&#39;odor_list&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;odor_list&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">odor_list</span>

    <span class="k">return</span> <span class="n">data</span></div>


<span class="c1"># TODO maybe break into a kc_mix_analysis repo (or something else appropriately</span>
<span class="c1"># project specific)</span>
<div class="viewcode-block" id="print_trial_odors"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.print_trial_odors">[docs]</a><span class="k">def</span> <span class="nf">print_trial_odors</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">odor_onset_frames</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    data should be as the output of `load_odor_metadata`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">chemutils</span> <span class="k">as</span> <span class="nn">cu</span>

    <span class="n">n_repeats</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_repeats&#39;</span><span class="p">]</span>
    <span class="n">odor_list</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;odor_list&#39;</span><span class="p">]</span>
    <span class="n">presentations_per_block</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;presentations_per_block&#39;</span><span class="p">]</span>
    <span class="n">pair_case</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;pair_case&#39;</span><span class="p">]</span>

    <span class="n">n_blocks</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">odor_list</span><span class="p">),</span> <span class="n">presentations_per_block</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">remainder</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="c1"># TODO add extra input data / add extra values to `data` in fn that already</span>
    <span class="c1"># augments that as necessary, for all values used below to still be defined</span>
    <span class="k">if</span> <span class="n">pair_case</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> comparisons ({{A, B, A+B}} in random order x &#39;</span> <span class="o">+</span>
            <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> repeats)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_blocks</span><span class="p">,</span> <span class="n">n_repeats</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mix_names</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">odor_list</span> <span class="k">if</span> <span class="s1">&#39;@&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">x</span><span class="p">}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mix_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">mix_name</span> <span class="o">=</span> <span class="n">mix_names</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> randomized blocks of &quot;</span><span class="si">{}</span><span class="s1">&quot; and its components&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">n_blocks</span><span class="p">,</span> <span class="n">mix_name</span>
            <span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">mix_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No mixtures, so presumably this is a calibration experiment&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{n_blocks}</span><span class="s1"> randomized blocks&#39;</span><span class="p">)</span>

    <span class="c1"># TODO maybe print this in tabular form?</span>
    <span class="n">trial</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_blocks</span><span class="p">):</span>
        <span class="n">p_start</span> <span class="o">=</span> <span class="n">presentations_per_block</span> <span class="o">*</span> <span class="n">i</span>
        <span class="n">p_end</span> <span class="o">=</span> <span class="n">presentations_per_block</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">cline</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="n">odor_strings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">odor_list</span><span class="p">[</span><span class="n">p_start</span><span class="p">:</span><span class="n">p_end</span><span class="p">]:</span>
            <span class="c1"># TODO maybe always have odor_list hold str repr?</span>
            <span class="c1"># or unify str repr generation -&gt; don&#39;t handle use odor_lists</span>
            <span class="c1"># for str representation in supermixture case?</span>
            <span class="c1"># would also be a good time to unify name + *concentration*</span>
            <span class="c1"># handling</span>
            <span class="k">if</span> <span class="n">pair_case</span><span class="p">:</span>
                <span class="c1"># TODO odor2abbrev here too probably... be more uniform</span>
                <span class="k">if</span> <span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;paraffin&#39;</span><span class="p">:</span>
                    <span class="n">odor_string</span> <span class="o">=</span> <span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">odor_string</span> <span class="o">=</span> <span class="s1">&#39; + &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span>

                <span class="n">parts</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;@&#39;</span><span class="p">)</span>
                <span class="n">odor_name</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="n">abbrev</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">abbrev</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">odor2abbrev</span><span class="p">(</span><span class="n">odor_name</span><span class="p">)</span>
                <span class="c1"># For a chemutils conversion failure.</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">pass</span>

                <span class="k">if</span> <span class="n">abbrev</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">abbrev</span> <span class="o">=</span> <span class="n">odor_name</span>

                <span class="n">odor_string</span> <span class="o">=</span> <span class="n">abbrev</span>
                <span class="c1"># TODO also don&#39;t append stuff if conc is @ 0.0 (log)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                    <span class="n">odor_string</span> <span class="o">+=</span> <span class="s1">&#39; @&#39;</span> <span class="o">+</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Adding one to index frames as in ImageJ.</span>
            <span class="k">if</span> <span class="n">odor_onset_frames</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">odor_string</span> <span class="o">+=</span> <span class="s1">&#39; (</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">odor_onset_frames</span><span class="p">[</span><span class="n">trial</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">trial</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">odor_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">odor_string</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">cline</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">odor_strings</span><span class="p">))</span></div>


<div class="viewcode-block" id="tiff_ijroi_filename"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.tiff_ijroi_filename">[docs]</a><span class="k">def</span> <span class="nf">tiff_ijroi_filename</span><span class="p">(</span><span class="n">tiff</span><span class="p">,</span> <span class="n">confirm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">gui_confirm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">gui_fallback</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">gui</span><span class="o">=</span><span class="s1">&#39;qt5&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a tiff path to corresponding ImageJ ROI file, assuming a certain</span>
<span class="sd">    naming convention and folder structure.</span>

<span class="sd">    Automatic search for ROI will only check same folder as the TIFF passed in.</span>

<span class="sd">    Options for fallback to manual selection / confirmation of appropriate</span>
<span class="sd">    ROI file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">gui_confirm</span> <span class="ow">and</span> <span class="n">confirm</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;only specify either gui_confirm or confirm&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">gui_confirm</span> <span class="ow">or</span> <span class="n">gui_fallback</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">gui</span> <span class="o">==</span> <span class="s1">&#39;qt5&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">PyQt5.QtWidgets</span> <span class="k">import</span> <span class="n">QMessageBox</span><span class="p">,</span> <span class="n">QFileDialog</span>

        <span class="c1"># TODO maybe implement some version w/ a builtin python gui like</span>
        <span class="c1"># tkinter?</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;gui </span><span class="si">{gui}</span><span class="s1"> not supported. see function.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">confirm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">confirm</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">curr_tiff_dir</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">tiff</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># TODO check that *.zip glob still matches in case where it is the empty</span>
    <span class="c1"># string (fix if it doesn&#39;t)</span>
    <span class="n">thorimage_id</span> <span class="o">=</span> <span class="n">tiff_thorimage_id</span><span class="p">(</span><span class="n">tiff</span><span class="p">)</span>
    <span class="n">possible_ijroi_files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">curr_tiff_dir</span><span class="p">,</span>
        <span class="n">thorimage_id</span> <span class="o">+</span> <span class="s1">&#39;*.zip&#39;</span>
    <span class="p">))</span>

    <span class="n">ijroiset_filename</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># TODO fix automatic first choice in _NNN naming convention case</span>
    <span class="c1"># (seemed to not work on 2019-07-25/2/_008)</span>
    <span class="c1"># but actually it did work in */_007 case... so idk what&#39;s happening</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_ijroi_files</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ijroiset_filename</span> <span class="o">=</span> <span class="n">possible_ijroi_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">confirm</span><span class="p">:</span>
            <span class="c1"># TODO factor into a fn to always get a Yy/Nn answer?</span>
            <span class="n">prompt</span> <span class="o">=</span> <span class="p">(</span><span class="n">format_keys</span><span class="p">(</span><span class="o">*</span><span class="n">tiff_filename2keys</span><span class="p">(</span><span class="n">tiff</span><span class="p">)</span> <span class="o">+</span>
                <span class="n">f</span><span class="s1">&#39;: use ImageJ ROIs in </span><span class="si">{ijroiset_filename}</span><span class="s1">? [y/n] &#39;</span>
            <span class="p">))</span>
            <span class="n">response</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">while</span> <span class="n">response</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">):</span>
                <span class="n">response</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">response</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
                <span class="n">ijroiset_filename</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1"># TODO manual text entry of appropriate filename in this case?</span>
                <span class="c1"># ...or maybe just totally unsupport terminal interaction?</span>

        <span class="k">elif</span> <span class="n">gui_confirm</span><span class="p">:</span>
            <span class="n">confirmation_choice</span> <span class="o">=</span> <span class="n">QMessageBox</span><span class="o">.</span><span class="n">question</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Confirm ROI file&#39;</span><span class="p">,</span>
                <span class="n">f</span><span class="s1">&#39;Use ImageJ ROIs in </span><span class="si">{ijroiset_filename}</span><span class="s1">?&#39;</span><span class="p">,</span>
                <span class="n">QMessageBox</span><span class="o">.</span><span class="n">Yes</span> <span class="o">|</span> <span class="n">QMessageBox</span><span class="o">.</span><span class="n">No</span><span class="p">,</span> <span class="n">QMessageBox</span><span class="o">.</span><span class="n">No</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">confirmation_choice</span> <span class="o">!=</span> <span class="n">QMessageBox</span><span class="o">.</span><span class="n">Yes</span><span class="p">:</span>
                <span class="n">ijroiset_filename</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">elif</span> <span class="ow">not</span> <span class="n">gui_fallback</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_ijroi_files</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;too many candidate ImageJ ROI files&#39;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="ow">not</span> <span class="n">gui_fallback</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_ijroi_files</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;no candidate ImageJ ROI files&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">gui_fallback</span> <span class="ow">and</span> <span class="n">ijroiset_filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">options</span> <span class="o">=</span> <span class="n">QFileDialog</span><span class="o">.</span><span class="n">Options</span><span class="p">()</span>
        <span class="n">options</span> <span class="o">|=</span> <span class="n">QFileDialog</span><span class="o">.</span><span class="n">DontUseNativeDialog</span>

        <span class="c1"># TODO restrict *.zip files shown to those also following some</span>
        <span class="c1"># naming convention (to indicate it&#39;s for the currently loaded TIFF,</span>
        <span class="c1"># and not a TIFF from some other experiment on the same fly)?</span>
        <span class="c1"># maybe checkbox / diff option to show all?</span>

        <span class="c1"># TODO need to pass in parent widget (what `self` was) or leave null if</span>
        <span class="c1"># that works? / define in here?</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;see comment above&#39;</span><span class="p">)</span>
        <span class="n">ijroiset_filename</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">QFileDialog</span><span class="o">.</span><span class="n">getOpenFileName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="s1">&#39;Select ImageJ ROI zip...&#39;</span><span class="p">,</span> <span class="n">curr_tiff_dir</span><span class="p">,</span>
            <span class="s1">&#39;ImageJ ROIs (*.zip)&#39;</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span>
        <span class="p">)</span>
        <span class="c1"># TODO (opt?) to not allow no selection? (so downstream code can assume</span>
        <span class="c1"># it&#39;s defined...) (should also probably change confirmation behavior</span>
        <span class="c1"># above)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ijroiset_filename</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No ImageJ ROI zipfile selected.&#39;</span><span class="p">)</span>
            <span class="n">ijroiset_filename</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">ijroiset_filename</span></div>


<span class="c1"># TODO TODO TODO may want to change how this fn operates (so it operates on</span>
<span class="c1"># blocks rather than all of them concatenated + to provide different baselining</span>
<span class="c1"># options)</span>
<div class="viewcode-block" id="calculate_df_over_f"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.calculate_df_over_f">[docs]</a><span class="k">def</span> <span class="nf">calculate_df_over_f</span><span class="p">(</span><span class="n">raw_f</span><span class="p">,</span> <span class="n">trial_start_frames</span><span class="p">,</span> <span class="n">odor_onset_frames</span><span class="p">,</span>
    <span class="n">trial_stop_frames</span><span class="p">):</span>
    <span class="c1"># TODO TODO maybe factor this into some kind of util fn that applies</span>
    <span class="c1"># another fn (perhaps inplace, perhaps onto new array) to each</span>
    <span class="c1"># (cell, block) (or maybe just each block, if smooth_1d can be vectorized,</span>
    <span class="c1"># so it could also apply in frame-shape-preserved case?)</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    for b_start, b_end in zip(block_first_frames, block_last_frames):</span>

<span class="sd">        for c in range(n_footprints):</span>
<span class="sd">            # TODO TODO TODO TODO need to be (b_end + 1) since not</span>
<span class="sd">            # inclusive? (&lt;-fixed) other problems like this elsewhere?????</span>
<span class="sd">            # TODO maybe smooth less now that df/f is being calculated more</span>
<span class="sd">            # sensibly...</span>
<span class="sd">            raw_f[b_start:(b_end + 1), c] = smooth_1d(</span>
<span class="sd">                raw_f[b_start:(b_end + 1), c], window_len=11</span>
<span class="sd">            )</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">df_over_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">raw_f</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">for</span> <span class="n">t_start</span><span class="p">,</span> <span class="n">odor_onset</span><span class="p">,</span> <span class="n">t_end</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">trial_start_frames</span><span class="p">,</span> <span class="n">odor_onset_frames</span><span class="p">,</span>
        <span class="n">trial_stop_frames</span><span class="p">):</span>

        <span class="c1"># TODO TODO maybe use diff way of calculating baseline</span>
        <span class="c1"># (include stuff at end of response? just some percentile over a big</span>
        <span class="c1"># window or something?)</span>
        <span class="c1"># TODO kwargs to control method of calculating baseline</span>

        <span class="c1"># TODO maybe display baseline period on plots for debugging?</span>
        <span class="c1"># maybe frame numbers got shifted?</span>
        <span class="n">baselines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">raw_f</span><span class="p">[</span><span class="n">t_start</span><span class="p">:(</span><span class="n">odor_onset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">trial_f</span> <span class="o">=</span> <span class="n">raw_f</span><span class="p">[</span><span class="n">t_start</span><span class="p">:(</span><span class="n">t_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">:]</span>
        <span class="n">df_over_f</span><span class="p">[</span><span class="n">t_start</span><span class="p">:(</span><span class="n">t_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">trial_f</span> <span class="o">-</span> <span class="n">baselines</span><span class="p">)</span> <span class="o">/</span> <span class="n">baselines</span>

    <span class="c1"># TODO some check that no value in df_over_f are currently NaN?</span>

    <span class="k">return</span> <span class="n">df_over_f</span></div>


<span class="c1"># TODO move to project specific repo</span>
<div class="viewcode-block" id="stimfile_odorset"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.stimfile_odorset">[docs]</a><span class="k">def</span> <span class="nf">stimfile_odorset</span><span class="p">(</span><span class="n">stimfile_path</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">load_stimfile</span><span class="p">(</span><span class="n">stimfile_path</span><span class="p">)</span>

    <span class="c1"># TODO did i use some other indicator elsewhere? anything more robust than</span>
    <span class="c1"># this?</span>
    <span class="k">if</span> <span class="s1">&#39;odor_pair_list&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="c1"># Just because I don&#39;t believe the pair experiment analysis</span>
        <span class="c1"># made any use of something like an odorset, so trying to</span>
        <span class="c1"># get one from those stimfiles is likely a mistake.</span>
        <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
            <span class="c1"># TODO maybe this err should happen whether or not strict is</span>
            <span class="c1"># true...?</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;trying to get complex mixture odor set &#39;</span>
                <span class="s1">&#39;from old pair experiment stimfile&#39;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="n">odors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;odor_lists&#39;</span><span class="p">])</span>
    <span class="c1"># TODO TODO TODO what caused this error where some fields were empty?</span>
    <span class="c1"># this corrupt or test data / not intended to be saved?</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">odors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;empty odor lists in </span><span class="si">{stimfile_path}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;odor_lists&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">str</span>

    <span class="c1"># TODO TODO TODO fix how stimfile generation stuff doesn&#39;t save</span>
    <span class="c1"># hardcoded real stuff into odors (+ maybe other vars?)</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    print(len(odors))</span>
<span class="sd">    pprint(odors)</span>
<span class="sd">    print(len(set(data[&#39;odors2pins&#39;].keys())))</span>
<span class="sd">    pprint(set(data[&#39;odors2pins&#39;].keys()))</span>
<span class="sd">    print(len(set(data[&#39;pins2odors&#39;].values())))</span>
<span class="sd">    pprint(set(data[&#39;pins2odors&#39;].values()))</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">#assert odors == set(data[&#39;odors&#39;])</span>
    <span class="k">assert</span> <span class="n">odors</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;odors2pins&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">assert</span> <span class="n">odors</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pins2odors&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="c1"># Not this accessor syntax, because .name is a property of all pandas</span>
    <span class="c1"># objects.</span>
    <span class="n">odor_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">split_odor_w_conc</span><span class="p">(</span><span class="n">oc</span><span class="p">)[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">oc</span> <span class="ow">in</span> <span class="n">odors</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">odorset_name</span><span class="p">(</span><span class="n">odor_names</span><span class="p">)</span></div>


<div class="viewcode-block" id="print_all_stimfile_odorsets"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.print_all_stimfile_odorsets">[docs]</a><span class="k">def</span> <span class="nf">print_all_stimfile_odorsets</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">stimfiles</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">stimfile_root</span><span class="p">(),</span> <span class="s1">&#39;*.p&#39;</span><span class="p">)))</span>
    <span class="n">stimfile_odorsets</span> <span class="o">=</span> <span class="p">[</span><span class="n">stimfile_odorset</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sf</span> <span class="ow">in</span> <span class="n">stimfiles</span>
    <span class="p">]</span>
    <span class="c1"># TODO maybe print grouped by day</span>
    <span class="n">pprint</span><span class="p">([(</span><span class="n">split</span><span class="p">(</span><span class="n">f</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">stimfiles</span><span class="p">,</span> <span class="n">stimfile_odorsets</span><span class="p">)</span> <span class="k">if</span> <span class="n">s</span>
    <span class="p">])</span></div>


<span class="c1"># TODO TODO move all of this kc mix stuff to project specific repo</span>
<span class="n">solvents</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;pfo&#39;</span><span class="p">,</span> <span class="s1">&#39;water&#39;</span><span class="p">)</span>
<span class="n">natural</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;kiwi&#39;</span><span class="p">,</span> <span class="s1">&#39;fly food&#39;</span><span class="p">)</span>
<span class="c1"># TODO maybe load (on demand) + cache the abbreviated versions of these, if</span>
<span class="c1"># chemutils is available?</span>
<span class="n">odor_set2order</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;kiwi&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;pfo&#39;</span><span class="p">,</span>
        <span class="s1">&#39;ethyl butyrate&#39;</span><span class="p">,</span>
        <span class="s1">&#39;ethyl acetate&#39;</span><span class="p">,</span>
        <span class="s1">&#39;isoamyl acetate&#39;</span><span class="p">,</span>
        <span class="s1">&#39;isoamyl alcohol&#39;</span><span class="p">,</span>
        <span class="s1">&#39;ethanol&#39;</span><span class="p">,</span>
        <span class="c1"># TODO check that changing the order of these last two hasn&#39;t broken</span>
        <span class="c1"># stuff...</span>
        <span class="s1">&#39;kiwi approx.&#39;</span><span class="p">,</span>
        <span class="s1">&#39;d3 kiwi&#39;</span>
    <span class="p">],</span>
    <span class="s1">&#39;control&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;pfo&#39;</span><span class="p">,</span>
        <span class="s1">&#39;1-octen-3-ol&#39;</span><span class="p">,</span>
        <span class="s1">&#39;furfural&#39;</span><span class="p">,</span>
        <span class="s1">&#39;valeric acid&#39;</span><span class="p">,</span>
        <span class="s1">&#39;methyl salicylate&#39;</span><span class="p">,</span>
        <span class="s1">&#39;2-heptanone&#39;</span><span class="p">,</span>
        <span class="c1"># Only one of these will actually be present, they just take the same</span>
        <span class="c1"># place in the order.</span>
        <span class="s1">&#39;control mix 1&#39;</span><span class="p">,</span>
        <span class="s1">&#39;control mix 2&#39;</span>
    <span class="p">],</span>
    <span class="s1">&#39;flyfood&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;water&#39;</span><span class="p">,</span>
        <span class="s1">&#39;propanoic acid&#39;</span><span class="p">,</span>
        <span class="s1">&#39;isobutyric acid&#39;</span><span class="p">,</span>
        <span class="s1">&#39;acetic acid&#39;</span><span class="p">,</span>
        <span class="s1">&#39;acetoin&#39;</span><span class="p">,</span>
        <span class="s1">&#39;ethanol&#39;</span><span class="p">,</span>
        <span class="s1">&#39;fly food approx.&#39;</span><span class="p">,</span>
        <span class="s1">&#39;fly food b&#39;</span>
    <span class="p">]</span>
<span class="p">}</span>
<div class="viewcode-block" id="df_to_odor_order"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.df_to_odor_order">[docs]</a><span class="k">def</span> <span class="nf">df_to_odor_order</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">observed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_name1</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes a complex-mixture DataFrame to odor names in desired plot order.</span>

<span class="sd">    Args:</span>
<span class="sd">    df (pd.DataFrame): should have a &#39;original_name1&#39; column, with names of</span>
<span class="sd">        odors from complex mixture experiments we have pre-defined odor orders</span>
<span class="sd">        for.</span>

<span class="sd">    observed (bool): (optional, default=True) If True, only return odor names</span>
<span class="sd">        in `df`.</span>

<span class="sd">    return_name1 (bool): (optional, default=False) If True, corresponding</span>
<span class="sd">        values in &#39;name1&#39; will be returned for each value in &#39;original_name1&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO might need to use name1 if original_name1 not there...</span>
    <span class="c1"># (for gui case)</span>
    <span class="n">odor_set</span> <span class="o">=</span> <span class="n">odorset_name</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">odor_set2order</span><span class="p">[</span><span class="n">odor_set</span><span class="p">]</span>
    <span class="n">observed_odors</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">original_name1</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">observed</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">order</span> <span class="k">if</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">observed_odors</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># TODO maybe just handle this externally (force all data w/in some</span>
        <span class="c1"># analysis to only have one or the other control mix) and then delete</span>
        <span class="c1"># this special casing</span>
        <span class="n">cm1</span> <span class="o">=</span> <span class="s1">&#39;control mix 1&#39;</span>
        <span class="n">cm2</span> <span class="o">=</span> <span class="s1">&#39;control mix 2&#39;</span>
        <span class="n">have_cm1</span> <span class="o">=</span> <span class="n">cm1</span> <span class="ow">in</span> <span class="n">observed_odors</span>
        <span class="n">have_cm2</span> <span class="o">=</span> <span class="n">cm2</span> <span class="ow">in</span> <span class="n">observed_odors</span>
        <span class="n">order</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">order</span> <span class="k">if</span> <span class="n">o</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">cm1</span><span class="p">,</span> <span class="n">cm2</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">have_cm1</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">have_cm2</span><span class="p">,</span> <span class="s1">&#39;df should only have either cm1 or cm2&#39;</span>
            <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cm1</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">have_cm2</span><span class="p">:</span>
            <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cm2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_name1</span><span class="p">:</span>
        <span class="n">o2n</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;original_name1&#39;</span><span class="p">,</span><span class="s1">&#39;name1&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span>
            <span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;original_name1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">name1</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">o2n</span><span class="p">[</span><span class="n">order</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">order</span></div>


<span class="c1"># TODO maybe also allow using GID from file?</span>
<div class="viewcode-block" id="gsheet_csv_export_link"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.gsheet_csv_export_link">[docs]</a><span class="k">def</span> <span class="nf">gsheet_csv_export_link</span><span class="p">(</span><span class="n">file_with_edit_link</span><span class="p">,</span> <span class="n">gid</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">no_append_gid</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a gsheet link copied from browser while editing it, and returns a</span>
<span class="sd">    URL suitable for reading it as a CSV into a DataFrame.</span>

<span class="sd">    GID seems to default to 0 for the first sheet, but seems unpredictable for further</span>
<span class="sd">    sheets in the same document, though you can extract it from the URL in those cases.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO make expectations on URL consistent whether from file or not</span>
    <span class="k">if</span> <span class="n">file_with_edit_link</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;http&#39;</span><span class="p">):</span>
        <span class="n">base_url</span> <span class="o">=</span> <span class="n">file_with_edit_link</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pkg_data_dir</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">dirs_to_try</span> <span class="o">=</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">pkg_data_dir</span><span class="p">)</span>
        <span class="c1"># .txt file containing link</span>
        <span class="n">link_filename</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dirs_to_try</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">file_with_edit_link</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
                <span class="n">link_filename</span> <span class="o">=</span> <span class="n">fname</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">link_filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{file_with_edit_link}</span><span class="s1"> not found in any of </span><span class="si">{dirs_to_try}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">link_filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">base_url</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/edit&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">gsheet_link</span> <span class="o">=</span> <span class="n">base_url</span> <span class="o">+</span> <span class="s1">&#39;/export?format=csv&amp;gid=&#39;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">no_append_gid</span><span class="p">:</span>
        <span class="n">gsheet_link</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">gid</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">gsheet_link</span></div>


<div class="viewcode-block" id="gsheet_to_frame"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.gsheet_to_frame">[docs]</a><span class="k">def</span> <span class="nf">gsheet_to_frame</span><span class="p">(</span><span class="n">file_with_edit_link</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">gid</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bool_fillna_false</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">convert_date_col</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">drop_trailing_bools</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">restore_ints</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">normalize_col_names</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        bool_fillna_false (bool): whether to replace missing values in columns that</span>
<span class="sd">            otherwise only contain True/False with False. will convert column dtype to</span>
<span class="sd">            &#39;bool&#39; as well.</span>

<span class="sd">        convert_date_col (bool): whether to convert the contents of any columns named</span>
<span class="sd">            &#39;date&#39; (case insensitive) to `pd.Timestamp`</span>

<span class="sd">        drop_trailing_bools (bool): whether to drop blocks of False in bool columns</span>
<span class="sd">            beyond the last row where all non-bool columns have any non-NaN values.</span>

<span class="sd">            If a column has data validation for a boolean, the frame will have values</span>
<span class="sd">            (False as I&#39;ve seen it so far) through to the end of the validation range,</span>
<span class="sd">            despite the fact that no data has been entered.</span>

<span class="sd">        restore_ints (bool): whether to convert columns parsed as floats (because</span>
<span class="sd">            missing data in rows where only default values for bool cols are present)</span>
<span class="sd">            to an integer type. Requires that drop_trailing_bools actually gets rid of</span>
<span class="sd">            all the NaN values in the columns to be converted to ints (float columns</span>
<span class="sd">            with only whole number / NaN values).</span>

<span class="sd">        normalize_col_names (bool): (default=False) whether to rename columns using the</span>
<span class="sd">            `hong2p.util.to_filename` (with `period=False` to that function) as well as</span>
<span class="sd">            lowercasing.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">gsheet_link</span> <span class="o">=</span> <span class="n">gsheet_csv_export_link</span><span class="p">(</span><span class="n">file_with_edit_link</span><span class="p">,</span> <span class="n">gid</span><span class="o">=</span><span class="n">gid</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">gsheet_link</span><span class="p">)</span>

    <span class="n">bool_col_unique_vals</span> <span class="o">=</span> <span class="p">{</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">}</span>
    <span class="c1"># TODO may want to change issubset call to exclude cols where there is somehow only</span>
    <span class="c1"># NaN with dtype is still being &#39;object&#39; (shouldn&#39;t be possible though, at least as</span>
    <span class="c1"># long as this is the first step?)</span>
    <span class="n">bool_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;bool&#39;</span> <span class="ow">or</span>
        <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;object&#39;</span> <span class="ow">and</span> <span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">bool_col_unique_vals</span><span class="p">))</span>
    <span class="p">]</span>

    <span class="k">if</span> <span class="n">bool_fillna_false</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">bool_cols</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>

    <span class="c1"># Could consider replacing this w/ just parse_dates [+ infer_datetime_format] kwargs</span>
    <span class="c1"># to pd.read_csv</span>
    <span class="k">if</span> <span class="n">convert_date_col</span><span class="p">:</span>
        <span class="n">date_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;date&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">date_cols</span><span class="p">:</span>
           <span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">drop_trailing_bools</span><span class="p">:</span>
        <span class="n">nonbool_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bool_cols</span><span class="p">]</span>
        <span class="n">nonbool_cols_some_data</span> <span class="o">=</span> <span class="o">~</span> <span class="n">df</span><span class="p">[</span><span class="n">nonbool_cols</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>

        <span class="n">last_row_with_data_idx</span> <span class="o">=</span> <span class="n">nonbool_cols_some_data</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nonbool_cols_some_data</span>
            <span class="p">)</span><span class="o">.</span><span class="n">last_valid_index</span><span class="p">()</span>

        <span class="n">will_be_dropped</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[(</span><span class="n">last_row_with_data_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):]</span>

        <span class="c1"># We expect all bool_cols beyond last data in non-bool cols to be False</span>
        <span class="c1"># (default value as I currently have the data validation for those columns in</span>
        <span class="c1"># most / all Gsheets where I use them)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">will_be_dropped</span><span class="p">[</span><span class="n">bool_cols</span><span class="p">]</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">len_before</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

        <span class="c1"># TODO still works if last row actually does have data, right?</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:(</span><span class="n">last_row_with_data_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">assert</span> <span class="n">len_before</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">will_be_dropped</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">restore_ints</span><span class="p">:</span>
        <span class="c1"># (works for &#39;float64&#39; at least, presumably all float types)</span>
        <span class="n">float_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;float&#39;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">float_cols</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>

            <span class="c1"># If dropping trailing NaN values didn&#39;t get rid of all the NaN, we can&#39;t</span>
            <span class="c1"># change the dtype of the column to a numpy integer type.</span>
            <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">continue</span>

            <span class="n">mod1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># TODO actually a risk of floats not exactly having mod 1 of 0 if input is</span>
            <span class="c1"># indeed an integer for all of them? assuming no for now.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">mod1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">normalize_col_names</span><span class="p">:</span>
        <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">to_filename</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<span class="c1"># TODO TODO for this and other stuff that depends on network access (if not</span>
<span class="c1"># cached), fallback to cache (unless explicitly prevented?), and warn</span>
<span class="c1"># that we are doing so (unless cached version explicitly requested)</span>
<span class="n">_mb_team_gsheet</span> <span class="o">=</span> <span class="kc">None</span>
<div class="viewcode-block" id="mb_team_gsheet"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.mb_team_gsheet">[docs]</a><span class="k">def</span> <span class="nf">mb_team_gsheet</span><span class="p">(</span><span class="n">use_cache</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">natural_odors_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">drop_nonexistant_dirs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show_inferred_paths</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">print_excluded_on_disk</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Returns a pandas.DataFrame with data on flies and MB team recordings.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">global</span> <span class="n">_mb_team_gsheet</span>
    <span class="k">if</span> <span class="n">_mb_team_gsheet</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_mb_team_gsheet</span>

    <span class="n">gsheet_cache_file</span> <span class="o">=</span> <span class="s1">&#39;.gsheet_cache.p&#39;</span>
    <span class="k">if</span> <span class="n">use_cache</span> <span class="ow">and</span> <span class="n">exists</span><span class="p">(</span><span class="n">gsheet_cache_file</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Loading MB team sheet data from cache at </span><span class="si">{gsheet_cache_file}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">gsheet_cache_file</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">sheets</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># TODO TODO maybe env var pointing to this? or w/ link itself?</span>
        <span class="c1"># TODO maybe just get relative path from __file__ w/ /.. or something?</span>
        <span class="c1"># TODO TODO TODO give this an [add_]default_gid=True (set to False here)</span>
        <span class="c1"># so other code of mine can use this function</span>
        <span class="n">gsheet_link</span> <span class="o">=</span> <span class="n">gsheet_csv_export_link</span><span class="p">(</span><span class="s1">&#39;mb_team_sheet_link.txt&#39;</span><span class="p">,</span>
            <span class="n">no_append_gid</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># If you want to add more sheets, when you select the new sheet in your</span>
        <span class="c1"># browser, the GID will be at the end of the URL in the address bar.</span>
        <span class="n">sheet_gids</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;fly_preps&#39;</span><span class="p">:</span> <span class="s1">&#39;269082112&#39;</span><span class="p">,</span>
            <span class="s1">&#39;recordings&#39;</span><span class="p">:</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span>
            <span class="s1">&#39;daily_settings&#39;</span><span class="p">:</span> <span class="s1">&#39;229338960&#39;</span>
        <span class="p">}</span>

        <span class="n">sheets</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">df_name</span><span class="p">,</span> <span class="n">gid</span> <span class="ow">in</span> <span class="n">sheet_gids</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">gsheet_link</span> <span class="o">+</span> <span class="n">gid</span><span class="p">)</span>

            <span class="c1"># TODO convert any other dtypes?</span>
            <span class="k">if</span> <span class="s1">&#39;date&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">])</span>

            <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Unnamed: &#39;</span><span class="p">)],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="s1">&#39;fly_num&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">last_with_fly_num</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">fly_num</span><span class="o">.</span><span class="n">notnull</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()</span>
                <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[(</span><span class="n">last_with_fly_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):]</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">sheets</span><span class="p">[</span><span class="n">df_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>

        <span class="n">boolean_columns</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;attempt_analysis&#39;</span><span class="p">,</span>
            <span class="s1">&#39;raw_data_discarded&#39;</span><span class="p">,</span>
            <span class="s1">&#39;raw_data_lost&#39;</span>
        <span class="p">}</span>
        <span class="n">na_cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sheets</span><span class="p">[</span><span class="s1">&#39;recordings&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">-</span> <span class="n">boolean_columns</span><span class="p">)</span>
        <span class="n">sheets</span><span class="p">[</span><span class="s1">&#39;recordings&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="n">na_cols</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">gsheet_cache_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">sheets</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

    <span class="c1"># TODO maybe make df some merge of the three sheets?</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">sheets</span><span class="p">[</span><span class="s1">&#39;recordings&#39;</span><span class="p">]</span>

    <span class="c1"># TODO TODO maybe flag to disable path inference / rethink how it should</span>
    <span class="c1"># interact w/ timestamp based correspondence between thorsync/image and</span>
    <span class="c1"># mapping that to the recordings in the gsheet</span>
    <span class="c1"># TODO should inference that reads the metadata happen in this fn?</span>
    <span class="c1"># maybe yes, but still factor it out and just call here?</span>

    <span class="c1"># TODO maybe start by not filling in fully-empty groups / flagging</span>
    <span class="c1"># them for later -&gt; preferring to infer those from local files -&gt;</span>
    <span class="c1"># then inferring fully-empty groups from default numbering as before</span>

    <span class="c1"># TODO try to replace w/ central key definition (module level)</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">,</span> <span class="s1">&#39;fly_num&#39;</span><span class="p">]</span>
    <span class="c1"># These should happen before rows start being dropped, because the dropped</span>
    <span class="c1"># rows might have the information needed to ffill.</span>
    <span class="c1"># This should NOT ffill a fly_past a change in date.</span>

    <span class="c1"># Assuming that if date changes, even if fly_nums keep going up, that was</span>
    <span class="c1"># intentional.</span>
    <span class="n">df</span><span class="o">.</span><span class="n">date</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;ffill&#39;</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">fly_num</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;date&#39;</span><span class="p">)[</span><span class="s1">&#39;fly_num&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">ffill</span><span class="p">()</span><span class="o">.</span><span class="n">bfill</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="c1"># This will only apply to groups (dates) where there are ONLY missing</span>
    <span class="c1"># fly_nums, given filling logic above.</span>
    <span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;fly_num&#39;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">df</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>

    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;stimulus_data_file&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;stimulus_data_file&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;ffill&#39;</span><span class="p">)</span>

    <span class="n">df</span><span class="o">.</span><span class="n">raw_data_discarded</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">raw_data_discarded</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># TODO say when this happens?</span>
    <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">raw_data_discarded</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># TODO TODO warn if &#39;attempt_analysis&#39; and either discard / lost is checked</span>

    <span class="c1"># Not sure where there were any NaN here anyway...</span>
    <span class="n">df</span><span class="o">.</span><span class="n">raw_data_lost</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">raw_data_lost</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">raw_data_lost</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># TODO as per note below, any thorimage/thorsync dirs entered in spreadsheet</span>
    <span class="c1"># should probably cause warning/err if either of above rejection reason</span>
    <span class="c1"># is checked</span>

    <span class="c1"># This happens after data is dropped for the above two reasons, because</span>
    <span class="c1"># generally those mistakes do not consume any of our sequential filenames.</span>
    <span class="c1"># They should not have files associated with them, and the Google sheet</span>
    <span class="c1"># information on them is just for tracking problems / efficiency.</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;recording_num&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span><span class="o">.</span><span class="n">cumcount</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">show_inferred_paths</span><span class="p">:</span>
        <span class="n">missing_thorimage</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">thorimage_dir</span><span class="p">)</span>
        <span class="n">missing_thorsync</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">thorsync_dir</span><span class="p">)</span>

    <span class="n">my_project</span> <span class="o">=</span> <span class="s1">&#39;natural_odors&#39;</span>

    <span class="c1"># TODO TODO fix current behavior where key groups that have nothing filled</span>
    <span class="c1"># in on gsheet (for dirs) will default to old format.  misbehaving for</span>
    <span class="c1"># 8-27/1 and all of 11-21, for example. (fixed?)</span>

    <span class="n">check_and_set</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">gn</span><span class="p">,</span> <span class="n">gdf</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">project</span> <span class="o">==</span> <span class="n">my_project</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">gdf</span><span class="p">[[</span><span class="s1">&#39;thorimage_dir&#39;</span><span class="p">,</span><span class="s1">&#39;thorsync_dir&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">fly_dir</span> <span class="o">=</span> <span class="n">raw_fly_dir</span><span class="p">(</span><span class="o">*</span><span class="n">gn</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">fly_dir</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">fly_dir</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Since we are disabling check that ThorImage nums (from naming</span>
                <span class="c1"># convention) are unique, we must check this before</span>
                <span class="c1"># mb_team_gsheet returns.</span>
                <span class="n">image_and_sync_pairs</span> <span class="o">=</span> <span class="n">thor</span><span class="o">.</span><span class="n">pair_thor_subdirs</span><span class="p">(</span><span class="n">fly_dir</span><span class="p">,</span>
                     <span class="n">check_against_naming_conv</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">check_unique_thorimage_nums</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pairs:&#39;</span><span class="p">)</span>
                    <span class="n">pprint</span><span class="p">(</span><span class="n">image_and_sync_pairs</span><span class="p">)</span>

            <span class="c1"># TODO TODO should ValueError actually be caught?</span>
            <span class="c1"># (from comments in other fns) it seems it will only be raised</span>
            <span class="c1"># when they are not 1:1, which should maybe cause failure in the way</span>
            <span class="c1"># AssertionErrors do now...</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">gn_str</span> <span class="o">=</span> <span class="n">format_keys</span><span class="p">(</span><span class="o">*</span><span class="n">gn</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;For </span><span class="si">{gn_str}</span><span class="s1">:&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;could not pair thor dirs automatically!&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;(</span><span class="si">{e}</span><span class="s1">)</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># could maybe try to sort things into &quot;prep checking&quot; / real</span>
            <span class="c1"># experiment based on time length or something (and maybe try</span>
            <span class="c1"># to fall back to just pairing w/ real experiments? and extending</span>
            <span class="c1"># condition below to # real experiments in gdf)</span>
            <span class="n">n_matched</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">image_and_sync_pairs</span><span class="p">)</span>
            <span class="n">ng</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span>
            <span class="c1"># TODO should this be an error (was previously just a</span>
            <span class="c1"># print + continue)?</span>
            <span class="k">if</span> <span class="n">n_matched</span> <span class="o">&lt;</span> <span class="n">ng</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;more rows for (date, fly) pair than matched outputs&#39;</span>
                    <span class="n">f</span><span class="s1">&#39; (</span><span class="si">{n_matched}</span><span class="s1"> &lt; </span><span class="si">{ng}</span><span class="s1">)&#39;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="c1">#print(msg)</span>
                <span class="c1">#continue</span>

            <span class="n">all_group_in_old_dir_fmt</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">group_tids</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">group_tsds</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">tid</span><span class="p">,</span> <span class="n">tsd</span> <span class="ow">in</span> <span class="n">image_and_sync_pairs</span><span class="p">:</span>
                <span class="n">tid</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">tid</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">thor</span><span class="o">.</span><span class="n">old_fmt_thorimage_num</span><span class="p">(</span><span class="n">tid</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{tid}</span><span class="s1"> not in old format&#39;</span><span class="p">)</span>
                    <span class="n">all_group_in_old_dir_fmt</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="n">group_tids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tid</span><span class="p">)</span>
                <span class="n">group_tsds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">tsd</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Not immediately setting df in this case, so that I can check</span>
            <span class="c1"># these results against the old way of doing things.</span>
            <span class="k">if</span> <span class="n">all_group_in_old_dir_fmt</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;all in old dir format&#39;</span><span class="p">)</span>

                <span class="n">check_and_set</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">gn</span><span class="p">,</span> <span class="n">gdf</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">group_tids</span><span class="p">,</span> <span class="n">group_tsds</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;filling in b/c not (all) in old dir format&#39;</span><span class="p">)</span>

                <span class="c1"># TODO is it ok to modify df used to create groupby while</span>
                <span class="c1"># iterating over groupby?</span>
                <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gdf</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;thorimage_dir&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_tids</span>
                <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gdf</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;thorsync_dir&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_tsds</span>

    <span class="k">if</span> <span class="n">print_excluded_on_disk</span><span class="p">:</span>
        <span class="c1"># So that we can exclude these directories when printing stuff on disk</span>
        <span class="c1"># (but not in df) later, to reduce noise (because of course other</span>
        <span class="c1"># project stuff is dropped and will not be mentioned in df).</span>
        <span class="n">ti_from_other_projects</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">ts_from_other_projects</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">gn</span><span class="p">,</span> <span class="n">gdf</span> <span class="ow">in</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">project</span> <span class="o">!=</span> <span class="n">my_project</span><span class="p">]</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
            <span class="n">fly_dir</span> <span class="o">=</span> <span class="n">raw_fly_dir</span><span class="p">(</span><span class="o">*</span><span class="n">gn</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">fly_dir</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">gdf_ti</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">thorimage_dir</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="n">fly_dir</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="n">gdf_ts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">thorsync_dir</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="n">fly_dir</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
            <span class="p">)</span>

            <span class="n">ti_from_other_projects</span> <span class="o">|=</span> <span class="n">gdf_ti</span>
            <span class="n">ts_from_other_projects</span> <span class="o">|=</span> <span class="n">gdf_ts</span>

    <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">project</span> <span class="o">!=</span> <span class="n">my_project</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># TODO TODO implement option to (at least) also keep prep checking that</span>
    <span class="c1"># preceded natural_odors (or maybe just that was on the same day)</span>
    <span class="c1"># (so that i can get all that ethyl acetate data for use as a reference</span>
    <span class="c1"># odor)</span>

    <span class="c1"># TODO display stuff inferred from files separately from stuff inferred</span>
    <span class="c1"># from combination of gsheet info and convention</span>

    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;thorimage_num&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">thorimage_dir</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">thor</span><span class="o">.</span><span class="n">old_fmt_thorimage_num</span><span class="p">)</span>
    <span class="c1"># TODO TODO should definition of consistency be changed to just check that</span>
    <span class="c1"># the ranking of the two are the same?</span>
    <span class="c1"># (maybe just if the group is all new format (which will have first real</span>
    <span class="c1"># experiments start w/ thorimage_num zero more often, b/c fn / fn_0000</span>
    <span class="c1"># thing)</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;numbering_consistent&#39;</span><span class="p">]</span> <span class="o">=</span> \
        <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">thorimage_num</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">thorimage_num</span> <span class="o">==</span> <span class="n">df</span><span class="o">.</span><span class="n">recording_num</span><span class="p">)</span>

    <span class="c1"># TODO unit test this</span>
    <span class="c1"># TODO TODO check that, if there are mismatches here, that they *never*</span>
    <span class="c1"># happen when recording num will be used for inference in rows in the group</span>
    <span class="c1"># *after* the mismatch (?)</span>
    <span class="n">gkeys</span> <span class="o">=</span> <span class="n">keys</span> <span class="o">+</span> <span class="p">[</span>
        <span class="s1">&#39;thorimage_dir&#39;</span><span class="p">,</span>
        <span class="s1">&#39;thorsync_dir&#39;</span><span class="p">,</span>
        <span class="s1">&#39;thorimage_num&#39;</span><span class="p">,</span>
        <span class="s1">&#39;recording_num&#39;</span><span class="p">,</span>
        <span class="s1">&#39;numbering_consistent&#39;</span>
    <span class="p">]</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">group_df</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
        <span class="c1"># TODO maybe refactor above so case 3 collapses into case 1?</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Case 1: all consistent</span>
<span class="sd">        Case 2: not all consistent, but all thorimage_dir filled in</span>
<span class="sd">        Case 3: not all consistent, but just because thorimage_dir was null</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#print(group_df[gkeys])</span>

        <span class="c1"># TODO check that first_mismatch based approach includes this case</span>
        <span class="c1">#if pd.notnull(group_df.thorimage_dir).all():</span>
        <span class="c1">#    continue</span>

        <span class="n">mismatches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="o">~</span> <span class="n">group_df</span><span class="o">.</span><span class="n">numbering_consistent</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mismatches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">first_mismatch_idx</span> <span class="o">=</span> <span class="n">mismatches</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#print(&#39;first_mismatch:\n&#39;, group_df[gkeys].iloc[first_mismatch_idx])</span>

        <span class="c1"># TODO test case where the first mismatch is last</span>
        <span class="n">following_thorimage_dirs</span> <span class="o">=</span> \
            <span class="n">group_df</span><span class="o">.</span><span class="n">thorimage_dir</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">first_mismatch_idx</span><span class="p">:]</span>
        <span class="c1">#print(&#39;checking these are not null:\n&#39;, following_thorimage_dirs)</span>
        <span class="k">assert</span> <span class="n">pd</span><span class="o">.</span><span class="n">notnull</span><span class="p">(</span><span class="n">following_thorimage_dirs</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

    <span class="n">df</span><span class="o">.</span><span class="n">thorsync_dir</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">thorimage_num</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;SyncData</span><span class="si">{:03d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">))),</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>

    <span class="c1"># Leaving recording_num because it might be prettier to use that for</span>
    <span class="c1"># IDs in figure than whatever Thor output directory naming convention.</span>
    <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;thorimage_num&#39;</span><span class="p">,</span><span class="s1">&#39;numbering_consistent&#39;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># TODO TODO check for conditions in which we might need to renumber</span>
    <span class="c1"># recording num? (dupes / any entered numbers along the way that are</span>
    <span class="c1"># inconsistent w/ recording_num results)</span>
    <span class="c1"># TODO update to handle case where thorimage dir does not start w/</span>
    <span class="c1"># _ and is not just 3 digits after that?</span>
    <span class="c1"># (see what format other stuff from day is?)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">thorimage_dir</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">recording_num</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;_</span><span class="si">{:03d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">))),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">thorsync_dir</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">recording_num</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;SyncData</span><span class="si">{:03d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">))),</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>

    <span class="k">for</span> <span class="n">gn</span><span class="p">,</span> <span class="n">gidx</span><span class="p">,</span> <span class="n">gtids</span><span class="p">,</span> <span class="n">gtsds</span> <span class="ow">in</span> <span class="n">check_and_set</span><span class="p">:</span>
        <span class="c1"># Since some stuff may have been dropped (prep checking stuff, etc).</span>
        <span class="n">still_in_idx</span> <span class="o">=</span> <span class="n">gidx</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="c1"># No group w/ files on NAS should have been dropped completely.</span>
        <span class="k">assert</span> <span class="n">still_in_idx</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">f</span><span class="s1">&#39;group </span><span class="si">{gn}</span><span class="s1"> dropped completely&#39;</span>

        <span class="n">gidx</span> <span class="o">=</span> <span class="n">gidx</span><span class="p">[</span><span class="n">still_in_idx</span><span class="p">]</span>
        <span class="n">gtids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gtids</span><span class="p">)[</span><span class="n">still_in_idx</span><span class="p">]</span>
        <span class="n">gtsds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gtsds</span><span class="p">)[</span><span class="n">still_in_idx</span><span class="p">]</span>

        <span class="n">from_gsheet</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gidx</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;thorimage_dir&#39;</span><span class="p">,</span> <span class="s1">&#39;thorsync_dir&#39;</span><span class="p">]]</span>
        <span class="n">from_thor</span> <span class="o">=</span> <span class="p">[</span><span class="n">gtids</span><span class="p">,</span> <span class="n">gtsds</span><span class="p">]</span>
        <span class="n">consistent</span> <span class="o">=</span> <span class="p">(</span><span class="n">from_gsheet</span> <span class="o">==</span> <span class="n">from_thor</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">consistent</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Inconsistency between path infererence methods!&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">gn</span><span class="p">)))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Derived from Google sheet:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">from_gsheet</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;From matching Thor output files:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">from_gsheet</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">from_thor</span><span class="p">))</span>
                <span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;inconsistent rankings w/ old format&#39;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">df</span><span class="o">.</span><span class="n">fly_num</span><span class="o">.</span><span class="n">notnull</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">astype</span><span class="p">({</span><span class="s1">&#39;fly_num&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">})</span>

    <span class="n">cols</span> <span class="o">=</span> <span class="n">keys</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;thorimage_dir&#39;</span><span class="p">,</span> <span class="s1">&#39;thorsync_dir&#39;</span><span class="p">,</span> <span class="s1">&#39;attempt_analysis&#39;</span><span class="p">]</span>
    <span class="c1"># TODO flag to do this only for stuff marked attempt_analysis</span>
    <span class="k">if</span> <span class="n">show_inferred_paths</span><span class="p">:</span>
        <span class="c1"># TODO only do this if any actually *were* inferred</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Inferred ThorImage directories:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">missing_thorimage</span><span class="p">,</span> <span class="n">cols</span><span class="p">]</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Inferred ThorSync directories:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">missing_thorsync</span><span class="p">,</span> <span class="n">cols</span><span class="p">]</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="n">duped_thorimage</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="n">keys</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;thorimage_dir&#39;</span><span class="p">],</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">duped_thorsync</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="n">keys</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;thorsync_dir&#39;</span><span class="p">],</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">duped_thorimage</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">duped_thorsync</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Duplicated ThorImage directories after path inference:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">duped_thorimage</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Duplicated ThorSync directories after path inference:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">duped_thorsync</span><span class="p">])</span>
        <span class="k">raise</span>

    <span class="n">flies</span> <span class="o">=</span> <span class="n">sheets</span><span class="p">[</span><span class="s1">&#39;fly_preps&#39;</span><span class="p">]</span>
    <span class="n">flies</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">flies</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;ffill&#39;</span><span class="p">)</span>
    <span class="n">flies</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">,</span><span class="s1">&#39;fly_num&#39;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># TODO maybe flag to not update database? or just don&#39;t?</span>
    <span class="c1"># TODO groups all inserts into transactions across tables, and as few as</span>
    <span class="c1"># possible (i.e. only do this later)?</span>
    <span class="n">db</span><span class="o">.</span><span class="n">to_sql_with_duplicates</span><span class="p">(</span><span class="n">flies</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="s1">&#39;prep_date&#39;</span><span class="p">}),</span> <span class="s1">&#39;flies&#39;</span>
    <span class="p">)</span>

    <span class="c1"># For manual sanity checking that important data isn&#39;t being excluded</span>
    <span class="c1"># inappropriately.</span>
    <span class="k">if</span> <span class="n">print_excluded_on_disk</span><span class="p">:</span>
        <span class="n">ti_ondisk_not_in_df</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">ts_ondisk_not_in_df</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">gn</span><span class="p">,</span> <span class="n">gdf</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
            <span class="n">fly_dir</span> <span class="o">=</span> <span class="n">raw_fly_dir</span><span class="p">(</span><span class="o">*</span><span class="n">gn</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">fly_dir</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Need them somewhat absolute (w/ date + fly info at least), so that</span>
            <span class="c1"># set operations on directories across (date, fly) combinations are</span>
            <span class="c1"># meaningful.</span>
            <span class="n">gdf_ti</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">thorimage_dir</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="n">fly_dir</span><span class="p">,</span> <span class="n">d</span><span class="p">)))</span>
            <span class="n">gdf_ts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">thorsync_dir</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="n">fly_dir</span><span class="p">,</span> <span class="n">d</span><span class="p">)))</span>

            <span class="n">thorimage_dirs</span><span class="p">,</span> <span class="n">thorsync_dirs</span> <span class="o">=</span> <span class="n">thor</span><span class="o">.</span><span class="n">thor_subdirs</span><span class="p">(</span><span class="n">fly_dir</span><span class="p">)</span>
            <span class="n">ti_ondisk_not_in_df</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">thorimage_dirs</span><span class="p">)</span> <span class="o">-</span> <span class="n">gdf_ti</span>
            <span class="n">ts_ondisk_not_in_df</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">thorsync_dirs</span><span class="p">)</span> <span class="o">-</span> <span class="n">gdf_ts</span>

        <span class="c1"># Excluding other-project stuff that was dropped from df earlier.</span>
        <span class="n">ti_ondisk_not_in_df</span> <span class="o">-=</span> <span class="n">ti_from_other_projects</span>
        <span class="n">ts_ondisk_not_in_df</span> <span class="o">-=</span> <span class="n">ts_from_other_projects</span>

        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> directories on disk but not in DataFrame (from gsheet):&#39;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ti_ondisk_not_in_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;ThorImage&#39;</span><span class="p">))</span>
            <span class="n">pprint</span><span class="p">(</span><span class="n">ti_ondisk_not_in_df</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ts_ondisk_not_in_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;ThorSync&#39;</span><span class="p">))</span>
            <span class="n">pprint</span><span class="p">(</span><span class="n">ts_ondisk_not_in_df</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="n">fly_dirs</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">raw_fly_dir</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">date</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">fly_num</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">abs_thorimage_dirs</span> <span class="o">=</span> <span class="n">fly_dirs</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">others</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">thorimage_dir</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
    <span class="n">abs_thorsync_dirs</span> <span class="o">=</span> <span class="n">fly_dirs</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">others</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">thorsync_dir</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
    <span class="n">thorimage_exists</span> <span class="o">=</span> <span class="n">abs_thorimage_dirs</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">isdir</span><span class="p">)</span>
    <span class="n">thorsync_exists</span> <span class="o">=</span> <span class="n">abs_thorsync_dirs</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">isdir</span><span class="p">)</span>
    <span class="n">any_dir_missing</span> <span class="o">=</span> <span class="o">~</span> <span class="p">(</span><span class="n">thorimage_exists</span> <span class="o">&amp;</span> <span class="n">thorsync_exists</span><span class="p">)</span>

    <span class="n">any_missing_marked_attempt</span> <span class="o">=</span> <span class="p">(</span><span class="n">any_dir_missing</span> <span class="o">&amp;</span> <span class="n">df</span><span class="o">.</span><span class="n">attempt_analysis</span><span class="p">)</span>
    <span class="c1"># TODO maybe an option to just warn here, rather than failing</span>
    <span class="k">if</span> <span class="n">any_missing_marked_attempt</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Directories marked attempt analysis with missing data:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">any_missing_marked_attempt</span><span class="p">,</span> <span class="n">cols</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">to_string</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;some experiments marked attempt_analysis &#39;</span>
            <span class="s1">&#39;had some data directories missing&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">drop_nonexistant_dirs</span><span class="p">:</span>
        <span class="n">n_to_drop</span> <span class="o">=</span> <span class="n">any_dir_missing</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">n_to_drop</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="n">f</span><span class="s1">&#39;Dropping </span><span class="si">{n_to_drop}</span><span class="s1"> rows because directories did not exist.&#39;</span>
            <span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">any_dir_missing</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># TODO TODO is 2019-08-27 fn_0000 stuff inferred correctly?</span>
    <span class="c1"># (will have same thorimage num as fn) (?)</span>
    <span class="c1"># (not critical apart from value as test case, b/c all stuff used from</span>
    <span class="c1"># that day has explicit paths in gsheet)</span>

    <span class="n">_mb_team_gsheet</span> <span class="o">=</span> <span class="n">df</span>

    <span class="c1"># TODO handle case where database is empty but gsheet cache still exists</span>
    <span class="c1"># (all inserts will probably fail, for lack of being able to reference fly</span>
    <span class="c1"># table)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="arraylike_cols"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.arraylike_cols">[docs]</a><span class="k">def</span> <span class="nf">arraylike_cols</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a list of columns that have only lists or arrays as elements.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="s1">&#39;object&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">o</span><span class="p">:</span>
        <span class="nb">type</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()]</span></div>


<span class="c1"># TODO use in other places that duplicate this functionality</span>
<span class="c1"># (like in natural_odors/kc_analysis ?)</span>
<div class="viewcode-block" id="expand_array_cols"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.expand_array_cols">[docs]</a><span class="k">def</span> <span class="nf">expand_array_cols</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Expands any list/array entries, with new rows for each entry.</span>

<span class="sd">    For any columns in `df` that have all list/array elements (at each row),</span>
<span class="sd">    the column in `out_df` will have the type of single elements from those</span>
<span class="sd">    arrays.</span>

<span class="sd">    The length of `out_df` will be the length of the input `df`, multiplied by</span>
<span class="sd">    the length (should be common in each input row) of each set of list/array</span>
<span class="sd">    elements.</span>

<span class="sd">    Other columns have their values duplicated, to match the lengths of the</span>
<span class="sd">    expanded array values.</span>

<span class="sd">    Args:</span>
<span class="sd">    `df` (pd.DataFrame)</span>

<span class="sd">    Returns:</span>
<span class="sd">    `out_df` (pd.DataFrame)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;numpy repeating may not handle index. &#39;</span>
            <span class="s1">&#39;reset_index first.&#39;</span><span class="p">)</span>

    <span class="c1"># Will be [&#39;raw_f&#39;, &#39;df_over_f&#39;, &#39;from_onset&#39;] in the main way I&#39;m using</span>
    <span class="c1"># this function.</span>
    <span class="n">array_cols</span> <span class="o">=</span> <span class="n">arraylike_cols</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">array_cols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;df did not appear to have any columns with all &#39;</span>
            <span class="s1">&#39;arraylike elements&#39;</span><span class="p">)</span>

    <span class="n">orig_dtypes</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">ac</span> <span class="ow">in</span> <span class="n">array_cols</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="n">ac</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">ac</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">ac</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">ac</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">orig_dtypes</span><span class="p">[</span><span class="n">ac</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">ac</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>

    <span class="n">non_array_cols</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">array_cols</span><span class="p">)</span>

    <span class="c1"># TODO true vectorized way to do this?</span>
    <span class="c1"># is str.len (on either rows/columns) faster (+equiv)?</span>
    <span class="n">array_lengths</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">array_cols</span><span class="p">]</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span><span class="nb">len</span><span class="p">)</span>
    <span class="n">c0</span> <span class="o">=</span> <span class="n">array_lengths</span><span class="p">[</span><span class="n">array_cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">array_cols</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">c0</span><span class="p">,</span> <span class="n">array_lengths</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
    <span class="n">array_lengths</span> <span class="o">=</span> <span class="n">c0</span>

    <span class="c1"># TODO more idiomatic / faster way to do what this loop is doing?</span>
    <span class="n">n_non_array_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_array_cols</span><span class="p">)</span>
    <span class="n">expanded_rows_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">n_repeats</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">non_array_cols</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">array_lengths</span><span class="p">):</span>
        <span class="c1"># could try subok=True if want to use pandas obj as input rather than</span>
        <span class="c1"># stuff from .values?</span>
        <span class="n">expanded_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="p">(</span><span class="n">n_repeats</span><span class="p">,</span> <span class="n">n_non_array_cols</span><span class="p">))</span>
        <span class="n">expanded_rows_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expanded_rows</span><span class="p">)</span>
    <span class="n">nac_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">expanded_rows_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">ac_data</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">array_cols</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">nac_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ac_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">nac_data</span><span class="p">,</span> <span class="n">ac_data</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">new_cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">non_array_cols</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">array_cols</span><span class="p">)</span>
    <span class="c1"># TODO copy=False is fine here, right? measure the time difference?</span>
    <span class="n">out_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">new_cols</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">orig_dtypes</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">out_df</span></div>


<div class="viewcode-block" id="diff_dataframes"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.diff_dataframes">[docs]</a><span class="k">def</span> <span class="nf">diff_dataframes</span><span class="p">(</span><span class="n">df1</span><span class="p">,</span> <span class="n">df2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a DataFrame summarizing input differences.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO do i want df1 and df2 to be allowed to be series?</span>
    <span class="c1"># (is that what they are now? need to modify anything?)</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">df1</span><span class="o">.</span><span class="n">columns</span> <span class="o">==</span> <span class="n">df2</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> \
        <span class="s2">&quot;DataFrame column names are different&quot;</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">df1</span><span class="o">.</span><span class="n">dtypes</span> <span class="o">!=</span> <span class="n">df2</span><span class="o">.</span><span class="n">dtypes</span><span class="p">):</span>
        <span class="s2">&quot;Data Types are different, trying to convert&quot;</span>
        <span class="n">df2</span> <span class="o">=</span> <span class="n">df2</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">df1</span><span class="o">.</span><span class="n">dtypes</span><span class="p">)</span>
    <span class="c1"># TODO is this really necessary? not an empty df in this case anyway?</span>
    <span class="k">if</span> <span class="n">df1</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">df2</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># TODO unit test w/ descrepencies in each of the cases.</span>
        <span class="c1"># TODO also test w/ nan in list / nan in float column (one / both nan)</span>
        <span class="n">floats1</span> <span class="o">=</span> <span class="n">df1</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="n">floats2</span> <span class="o">=</span> <span class="n">df2</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">floats1</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">floats2</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">diff_mask_floats</span> <span class="o">=</span> <span class="o">~</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">floats1</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">df1</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
            <span class="c1"># TODO TODO does this already deal w/ nan correctly?</span>
            <span class="c1"># otherwise, this part needs to handle possibility of nan</span>
            <span class="c1"># (it does not. need to handle.)</span>
            <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">floats1</span><span class="p">,</span> <span class="n">floats2</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">diff_mask_floats</span> <span class="o">=</span> <span class="p">(</span><span class="n">diff_mask_floats</span> <span class="o">&amp;</span>
            <span class="o">~</span><span class="p">(</span><span class="n">floats1</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">floats2</span><span class="o">.</span><span class="n">isnull</span><span class="p">()))</span>

        <span class="c1"># Just assuming, for now, that array-like cols are same across two dfs.</span>
        <span class="n">arr_cols</span> <span class="o">=</span> <span class="n">arraylike_cols</span><span class="p">(</span><span class="n">df1</span><span class="p">)</span>
        <span class="c1"># Also assuming, for now, that no elements of these lists / arrays will</span>
        <span class="c1"># be nan (which is currently true).</span>
        <span class="n">diff_mask_arr</span> <span class="o">=</span> <span class="o">~</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">arr_cols</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">df1</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">)(</span><span class="n">df1</span><span class="p">[</span><span class="n">arr_cols</span><span class="p">],</span> <span class="n">df2</span><span class="p">[</span><span class="n">arr_cols</span><span class="p">])</span>
        <span class="p">)</span>

        <span class="n">other_cols</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">df1</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">floats1</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">arr_cols</span><span class="p">)</span>
        <span class="n">other_diff_mask</span> <span class="o">=</span> <span class="n">df1</span><span class="p">[</span><span class="n">other_cols</span><span class="p">]</span> <span class="o">!=</span> <span class="n">df2</span><span class="p">[</span><span class="n">other_cols</span><span class="p">]</span>

        <span class="n">diff_mask</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span>
            <span class="n">diff_mask_floats</span><span class="p">,</span>
            <span class="n">diff_mask_arr</span><span class="p">,</span>
            <span class="n">other_diff_mask</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">diff_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">ne_stacked</span> <span class="o">=</span> <span class="n">diff_mask</span><span class="o">.</span><span class="n">stack</span><span class="p">()</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="n">ne_stacked</span><span class="p">[</span><span class="n">ne_stacked</span><span class="p">]</span>
        <span class="c1"># TODO are these what i want? prob change id (basically just to index?)?</span>
        <span class="c1"># TODO get id from index name of input dfs? and assert only one index</span>
        <span class="c1"># (assuming this wouldn&#39;t work w/ multiindex w/o modification)?</span>
        <span class="n">changed</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;col&#39;</span><span class="p">]</span>
        <span class="n">difference_locations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diff_mask</span><span class="p">)</span>
        <span class="n">changed_from</span> <span class="o">=</span> <span class="n">df1</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">difference_locations</span><span class="p">]</span>
        <span class="n">changed_to</span> <span class="o">=</span> <span class="n">df2</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">difference_locations</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;from&#39;</span><span class="p">:</span> <span class="n">changed_from</span><span class="p">,</span> <span class="s1">&#39;to&#39;</span><span class="p">:</span> <span class="n">changed_to</span><span class="p">},</span>
                            <span class="n">index</span><span class="o">=</span><span class="n">changed</span><span class="o">.</span><span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="first_group"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.first_group">[docs]</a><span class="k">def</span> <span class="nf">first_group</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">group_cols</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns key tuple and df of first group, grouping df on group_cols.</span>

<span class="sd">    Just for ease of interactively testing out functions on DataFrames of a</span>
<span class="sd">    groupby.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gb</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">group_cols</span><span class="p">)</span>
    <span class="n">first_group_tuple</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gb</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gb</span><span class="o">.</span><span class="n">get_group</span><span class="p">(</span><span class="n">first_group_tuple</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">first_group_tuple</span><span class="p">,</span> <span class="n">gdf</span></div>


<div class="viewcode-block" id="git_hash"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.git_hash">[docs]</a><span class="k">def</span> <span class="nf">git_hash</span><span class="p">(</span><span class="n">repo_file</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes any file in a git directory and returns current hash.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">git</span>
    <span class="n">repo</span> <span class="o">=</span> <span class="n">git</span><span class="o">.</span><span class="n">Repo</span><span class="p">(</span><span class="n">repo_file</span><span class="p">,</span> <span class="n">search_parent_directories</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">current_hash</span> <span class="o">=</span> <span class="n">repo</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">hexsha</span>
    <span class="k">return</span> <span class="n">current_hash</span></div>


<span class="c1"># TODO TODO maybe check that remote seems to be valid, and fail if not.</span>
<span class="c1"># don&#39;t want to assume we have an online (backed up) record of git repo when we</span>
<span class="c1"># don&#39;t...</span>
<div class="viewcode-block" id="version_info"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.version_info">[docs]</a><span class="k">def</span> <span class="nf">version_info</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">used_for</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">force_git</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes module or string path to file in Git repo to a dict with version</span>
<span class="sd">    information (with keys and values the database will accept).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">git</span>
    <span class="kn">import</span> <span class="nn">pkg_resources</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">module_or_path</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">module_or_path</span> <span class="o">=</span> <span class="vm">__file__</span>
        <span class="n">force_git</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;too many arguments&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module_or_path</span><span class="p">,</span> <span class="n">ModuleType</span><span class="p">):</span>
        <span class="n">module</span> <span class="o">=</span> <span class="n">module_or_path</span>
        <span class="n">pkg_path</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="vm">__file__</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">module_or_path</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;must path either a Python module or str path&#39;</span><span class="p">)</span>
        <span class="n">pkg_path</span> <span class="o">=</span> <span class="n">module_or_path</span>
        <span class="n">module</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">repo</span> <span class="o">=</span> <span class="n">git</span><span class="o">.</span><span class="n">Repo</span><span class="p">(</span><span class="n">pkg_path</span><span class="p">,</span> <span class="n">search_parent_directories</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">repo</span><span class="o">.</span><span class="n">working_tree_dir</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">remote_urls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">repo</span><span class="o">.</span><span class="n">remotes</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">urls</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">remote_urls</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">remote_url</span> <span class="o">=</span> <span class="n">remote_urls</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">current_hash</span> <span class="o">=</span> <span class="n">repo</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">hexsha</span>

        <span class="n">index</span> <span class="o">=</span> <span class="n">repo</span><span class="o">.</span><span class="n">index</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">create_patch</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">changes</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">diff</span><span class="p">:</span>
            <span class="n">changes</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
            <span class="s1">&#39;used_for&#39;</span><span class="p">:</span> <span class="n">used_for</span><span class="p">,</span>
            <span class="s1">&#39;git_remote&#39;</span><span class="p">:</span> <span class="n">remote_url</span><span class="p">,</span>
            <span class="s1">&#39;git_hash&#39;</span><span class="p">:</span> <span class="n">current_hash</span><span class="p">,</span>
            <span class="s1">&#39;git_uncommitted_changes&#39;</span><span class="p">:</span> <span class="n">changes</span>
        <span class="p">}</span>

    <span class="k">except</span> <span class="n">git</span><span class="o">.</span><span class="n">exc</span><span class="o">.</span><span class="n">InvalidGitRepositoryError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">force_git</span><span class="p">:</span>
            <span class="k">raise</span>

        <span class="k">if</span> <span class="n">module</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># TODO try to find module from str</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s1">&#39;pass module for non-source installations&#39;</span><span class="p">)</span>

        <span class="c1"># There may be circumstances in which module name isn&#39;t the right name</span>
        <span class="c1"># to use here, but assuming we won&#39;t encounter that for now.</span>
        <span class="n">version</span> <span class="o">=</span> <span class="n">pkg_resources</span><span class="o">.</span><span class="n">get_distribution</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span><span class="o">.</span><span class="n">version</span>

        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s1">&#39;used_for&#39;</span><span class="p">:</span> <span class="n">used_for</span><span class="p">,</span> <span class="s1">&#39;version&#39;</span><span class="p">:</span> <span class="n">version</span><span class="p">}</span></div>


<div class="viewcode-block" id="motion_corrected_tiff_filename"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.motion_corrected_tiff_filename">[docs]</a><span class="k">def</span> <span class="nf">motion_corrected_tiff_filename</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly_num</span><span class="p">,</span> <span class="n">thorimage_id</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes vars identifying recording to the name of a motion corrected TIFF</span>
<span class="sd">    for it. Non-rigid preferred over rigid. Relies on naming convention.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tif_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">analysis_fly_dir</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly_num</span><span class="p">),</span> <span class="s1">&#39;tif_stacks&#39;</span><span class="p">)</span>
    <span class="n">nr_tif</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">tif_dir</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_nr.tif&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">thorimage_id</span><span class="p">))</span>
    <span class="n">rig_tif</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">tif_dir</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_rig.tif&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">thorimage_id</span><span class="p">))</span>
    <span class="n">tif</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">nr_tif</span><span class="p">):</span>
        <span class="n">tif</span> <span class="o">=</span> <span class="n">nr_tif</span>
    <span class="k">elif</span> <span class="n">exists</span><span class="p">(</span><span class="n">rig_tif</span><span class="p">):</span>
        <span class="n">tif</span> <span class="o">=</span> <span class="n">rig_tif</span>

    <span class="k">if</span> <span class="n">tif</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;No motion corrected TIFs found in </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tif_dir</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">tif</span></div>


<span class="c1"># TODO use this in other places that normalize to thorimage_ids</span>
<div class="viewcode-block" id="tiff_thorimage_id"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.tiff_thorimage_id">[docs]</a><span class="k">def</span> <span class="nf">tiff_thorimage_id</span><span class="p">(</span><span class="n">tiff_filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a path to a TIFF and returns ID to identify recording within</span>
<span class="sd">    (date, fly). Relies on naming convention.</span>

<span class="sd">    Works for input that is either a raw TIFF or a motion corrected TIFF,</span>
<span class="sd">    the latter of which should have a conventional suffix indicating the</span>
<span class="sd">    type of motion correction (&#39;_nr&#39; / &#39;_rig&#39;).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Behavior of os.path.split makes this work even if tiff_filename does not</span>
    <span class="c1"># have any directories in it.</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">tiff_filename</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="s1">&#39;.tif&#39;</span><span class="p">)])[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>

    <span class="c1"># Last part of the filename, which I use to indicate the type of motion</span>
    <span class="c1"># correction applied. Should only apply in TIFFs under analysis directory.</span>
    <span class="k">if</span> <span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;nr&#39;</span><span class="p">,</span> <span class="s1">&#39;rig&#39;</span><span class="p">):</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span></div>


<span class="c1"># TODO test that date, fly_num, thorimage_id args still work here after refactoring to</span>
<span class="c1"># use wrapper</span>
<span class="c1"># TODO option to keep this under analysis_dir type tree instead? or just fully switch to</span>
<span class="c1"># that maybe?</span>
<div class="viewcode-block" id="metadata_filename"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.metadata_filename">[docs]</a><span class="nd">@thorimage_dir_input</span>
<span class="k">def</span> <span class="nf">metadata_filename</span><span class="p">(</span><span class="n">thorimage_dir</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns filename of YAML for extra metadata.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO port over any metadata yamls i have in the raw data tree in this old location</span>
    <span class="c1">#return join(raw_fly_dir(date, fly_num), thorimage_id + &#39;_metadata.yaml&#39;)</span>
    <span class="k">return</span> <span class="n">join</span><span class="p">(</span><span class="n">thorimage_dir</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly</span><span class="p">,</span> <span class="n">thorimage_id</span><span class="p">),</span> <span class="s1">&#39;metadata.yaml&#39;</span><span class="p">)</span></div>


<span class="c1"># TODO maybe something to indicate various warnings</span>
<span class="c1"># (like mb team not being able to pair things) should be suppressed?</span>
<span class="c1"># TODO wrap this + read_movie into loading that can also flip according to a key in the</span>
<span class="c1"># yaml (L/R, for more easily comparing data from diff AL sides in flies in the same</span>
<span class="c1"># orientation, for example)</span>
<span class="c1">#def load_metadata(date, fly_num, thorimage_id):</span>
<div class="viewcode-block" id="load_metadata"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.load_metadata">[docs]</a><span class="k">def</span> <span class="nf">load_metadata</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns metadata from YAML, with defaults added.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">metadata_file</span> <span class="o">=</span> <span class="n">metadata_filename</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="c1"># TODO another var specifying number of frames that has *already* been</span>
    <span class="c1"># cropped out of raw tiff (start/end), to resolve any descrepencies wrt</span>
    <span class="c1"># thorsync data</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;flip_lr&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="s1">&#39;drop_first_n_frames&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">metadata_file</span><span class="p">):</span>
        <span class="c1"># TODO also load single odors (or maybe other trial structures) from stuff like</span>
        <span class="c1"># this, so analysis does not need my own pickle based stim format</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">metadata_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mdf</span><span class="p">:</span>
            <span class="n">yaml_metadata</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">mdf</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">metadata</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">yaml_metadata</span><span class="p">:</span>
                <span class="n">metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">yaml_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">metadata</span></div>


<div class="viewcode-block" id="load_movie"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.load_movie">[docs]</a><span class="k">def</span> <span class="nf">load_movie</span><span class="p">(</span><span class="n">thorimage_dir</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Loads movie and pre-processes (e.g. flipping) if metadata requests it.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">movie</span> <span class="o">=</span> <span class="n">thor</span><span class="o">.</span><span class="n">read_movie</span><span class="p">(</span><span class="n">thorimage_dir</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1"># TODO TODO TODO finish implementing</span>
    <span class="c1">#metadata = load_metadata(</span>


<div class="viewcode-block" id="tiff_filename2keys"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.tiff_filename2keys">[docs]</a><span class="k">def</span> <span class="nf">tiff_filename2keys</span><span class="p">(</span><span class="n">tiff_filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes TIFF filename to pd.Series w/ &#39;date&#39;,&#39;fly_num&#39;,&#39;thorimage_id&#39; keys.</span>

<span class="sd">    TIFF must be placed and named according to convention, because the</span>
<span class="sd">    date and fly_num are taken from names of some of the containing directories.</span>

<span class="sd">    Works with TIFFs either under `raw_data_root` or `analysis_output_root`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">tiff_filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)[</span><span class="o">-</span><span class="mi">5</span><span class="p">:]</span>
    <span class="n">date</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parts</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">date_fmt_str</span><span class="p">))</span>
            <span class="n">fly_num_idx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">break</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">if</span> <span class="n">date</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;no date directory found in TIFF path&#39;</span><span class="p">)</span>

    <span class="n">fly_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="n">fly_num_idx</span><span class="p">])</span>
    <span class="n">thorimage_id</span> <span class="o">=</span> <span class="n">tiff_thorimage_id</span><span class="p">(</span><span class="n">tiff_filename</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">({</span>
        <span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="n">date</span><span class="p">,</span> <span class="s1">&#39;fly_num&#39;</span><span class="p">:</span> <span class="n">fly_num</span><span class="p">,</span> <span class="s1">&#39;thorimage_id&#39;</span><span class="p">:</span> <span class="n">thorimage_id</span>
    <span class="p">})</span></div>


<div class="viewcode-block" id="recording_df2keys"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.recording_df2keys">[docs]</a><span class="k">def</span> <span class="nf">recording_df2keys</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="n">dupes</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">recording_cols</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">dupes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dupes</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="list_motion_corrected_tifs"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.list_motion_corrected_tifs">[docs]</a><span class="k">def</span> <span class="nf">list_motion_corrected_tifs</span><span class="p">(</span><span class="n">include_rigid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">attempt_analysis_only</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;List motion corrected TIFFs in conventional directory structure on NAS.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">motion_corrected_tifs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">mb_team_gsheet</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">full_date_dir</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">analysis_output_root</span><span class="p">(),</span> <span class="s1">&#39;**&#39;</span><span class="p">))):</span>
        <span class="k">for</span> <span class="n">full_fly_dir</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">full_date_dir</span><span class="p">,</span> <span class="s1">&#39;**&#39;</span><span class="p">))):</span>
            <span class="n">date_dir</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">full_date_dir</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">fly_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">full_fly_dir</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

                <span class="n">fly_used</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">attempt_analysis</span> <span class="o">&amp;</span>
                    <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">date</span> <span class="o">==</span> <span class="n">date_dir</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">fly_num</span> <span class="o">==</span> <span class="n">fly_num</span><span class="p">)]</span>

                <span class="n">used_thorimage_dirs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">fly_used</span><span class="o">.</span><span class="n">thorimage_dir</span><span class="p">)</span>

                <span class="n">tif_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">full_fly_dir</span><span class="p">,</span> <span class="s1">&#39;tif_stacks&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">tif_dir</span><span class="p">):</span>
                    <span class="n">tif_glob</span> <span class="o">=</span> <span class="s1">&#39;*.tif&#39;</span> <span class="k">if</span> <span class="n">include_rigid</span> <span class="k">else</span> <span class="s1">&#39;*_nr.tif&#39;</span>
                    <span class="n">fly_tifs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">tif_dir</span><span class="p">,</span> <span class="n">tif_glob</span><span class="p">)))</span>

                    <span class="n">used_tifs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">fly_tifs</span> <span class="k">if</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="n">split</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">in</span> <span class="n">used_thorimage_dirs</span><span class="p">]</span>

                    <span class="n">motion_corrected_tifs</span> <span class="o">+=</span> <span class="n">used_tifs</span>

            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">continue</span>

    <span class="k">return</span> <span class="n">motion_corrected_tifs</span></div>


<span class="c1"># TODO still work w/ parens added around initial .+ ? i want to match the parent</span>
<span class="c1"># id...</span>
<span class="n">shared_subrecording_regex</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(.+)_\db\d_from_(nr|rig)&#39;</span>
<div class="viewcode-block" id="is_subrecording"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.is_subrecording">[docs]</a><span class="k">def</span> <span class="nf">is_subrecording</span><span class="p">(</span><span class="n">thorimage_id</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns whether a recording id matches my GUIs naming convention for the</span>
<span class="sd">    &quot;sub-recordings&quot; it can create.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">shared_subrecording_regex</span> <span class="o">+</span> <span class="s1">&#39;$&#39;</span><span class="p">,</span> <span class="n">thorimage_id</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="is_subrecording_tiff"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.is_subrecording_tiff">[docs]</a><span class="k">def</span> <span class="nf">is_subrecording_tiff</span><span class="p">(</span><span class="n">tiff_filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a TIFF filename to whether it matches the GUI&#39;s naming convention for</span>
<span class="sd">    the &quot;sub-recordings&quot; it can create.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO technically, nr|rig should be same across two...</span>
    <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">shared_subrecording_regex</span> <span class="o">+</span> <span class="s1">&#39;_(nr|rig).tif$&#39;</span><span class="p">,</span> <span class="n">tiff_filename</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="subrecording_tiff_blocks"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.subrecording_tiff_blocks">[docs]</a><span class="k">def</span> <span class="nf">subrecording_tiff_blocks</span><span class="p">(</span><span class="n">tiff_filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns tuple of int (start, stop) block numbers subrecording contains.</span>

<span class="sd">    Block numbers start at 0.</span>

<span class="sd">    Requires that is_subrecording_tiff(tiff_filename) would return True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">tiff_filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>

    <span class="n">first_block</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">last_block</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">first_block</span><span class="p">,</span> <span class="n">last_block</span></div>


<div class="viewcode-block" id="subrecording_tiff_blocks_df"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.subrecording_tiff_blocks_df">[docs]</a><span class="k">def</span> <span class="nf">subrecording_tiff_blocks_df</span><span class="p">(</span><span class="n">series</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes a series w/ TIFF name in series.name to (start, stop) block nums.</span>

<span class="sd">    (series.name must be a TIFF path)</span>

<span class="sd">    Same behavior as `subrecording_tiff_blocks`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO maybe fail in this case?</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">series</span><span class="o">.</span><span class="n">is_subrecording</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="n">tiff_filename</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">name</span>
    <span class="n">first_block</span><span class="p">,</span> <span class="n">last_block</span> <span class="o">=</span> <span class="n">subrecording_tiff_blocks</span><span class="p">(</span><span class="n">tiff_filename</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">first_block</span><span class="p">,</span> <span class="n">last_block</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    return {</span>
<span class="sd">        &#39;first_block&#39;: first_block,</span>
<span class="sd">        &#39;last_block&#39;: last_block</span>
<span class="sd">    }</span>
<span class="sd">    &#39;&#39;&#39;</span></div>


<div class="viewcode-block" id="parent_recording_id"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.parent_recording_id">[docs]</a><span class="k">def</span> <span class="nf">parent_recording_id</span><span class="p">(</span><span class="n">tiffname_or_thorimage_id</span><span class="p">):</span>
    <span class="c1"># TODO provide example of naming convention / manipulation in doc</span>
    <span class="sd">&quot;&quot;&quot;Returns recording id for recording subrecording was derived from.</span>

<span class="sd">    Input can be a TIFF filename or recording id.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">last_part</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">tiffname_or_thorimage_id</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">shared_subrecording_regex</span><span class="p">,</span> <span class="n">last_part</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;not a subrecording&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></div>


<span class="c1"># TODO test this works w/ both Path and str input</span>
<div class="viewcode-block" id="write_tiff"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.write_tiff">[docs]</a><span class="k">def</span> <span class="nf">write_tiff</span><span class="p">(</span><span class="n">tiff_filename</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">,</span> <span class="n">movie</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">strict_dtype</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># TODO also handle diff color channels</span>
    <span class="sd">&quot;&quot;&quot;Write a TIFF loading the same as the TIFFs we create with ImageJ.</span>

<span class="sd">    TIFFs are written in big-endian byte order to be readable by `imread_big`</span>
<span class="sd">    from MATLAB file exchange.</span>

<span class="sd">    Dimensions of input should be (t,[z,],y,x).</span>

<span class="sd">    Metadata may not be correct.</span>

<span class="sd">    Args:</span>
<span class="sd">        dims: may or may not have the same meaning as `tifffile.imsave` `axes` kwarg</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">tifffile</span>

    <span class="k">if</span> <span class="n">strict_dtype</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span>
            <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">unsignedinteger</span><span class="p">)):</span>

            <span class="c1"># TODO TODO TODO handle casting from float (for df/f images, for example)</span>
            <span class="c1"># (how does imagej do this type of casting? i would think it would also need</span>
            <span class="c1"># to do something like that?) (at least if not strict_dtype)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;movie must have uint16 dtype&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s1">&#39;|&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;movie must have explicit endianness&#39;</span><span class="p">)</span>

        <span class="c1"># If little-endian, convert to big-endian before saving TIFF, almost</span>
        <span class="c1"># exclusively for the benefit of MATLAB imread_big, which doesn&#39;t seem</span>
        <span class="c1"># able to discern the byteorder.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s1">&#39;&lt;&#39;</span> <span class="ow">or</span>
            <span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s1">&#39;=&#39;</span> <span class="ow">and</span> <span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s1">&#39;little&#39;</span><span class="p">)):</span>
            <span class="n">movie</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="n">byteswap</span><span class="p">()</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">dtype</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s1">&#39;&gt;&#39;</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># To avoid `ValueError: ImageJ does not support data type &#39;d&#39;` from tifffile.py</span>
        <span class="k">if</span> <span class="n">movie</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;float64&#39;</span><span class="p">:</span>
            <span class="n">movie</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>

    <span class="c1"># TODO TODO maybe change so ImageJ considers appropriate dimension the time</span>
    <span class="c1"># dimension (both in 2d x T and 3d x T cases)</span>
    <span class="c1"># TODO TODO TODO convert from thor data to appropriate dimension order (w/</span>
    <span class="c1"># singleton dimensions as necessary) (or keep dimensions + dimension order</span>
    <span class="c1"># of array, and pass metadata={&#39;axes&#39;: &#39;TCXY&#39;}, w/ the value constructed</span>
    <span class="c1"># appropriately? that work w/ imagej=True?) (i dont think it did)</span>

    <span class="c1"># TODO TODO TODO since scipy docs say [their version] of tifffile expects</span>
    <span class="c1"># channels in TZCYXS order</span>
    <span class="c1"># https://scikit-image.org/docs/0.14.x/api/skimage.external.tifffile.html</span>

    <span class="n">imagej_dims</span> <span class="o">=</span> <span class="s1">&#39;TZCYX&#39;</span>

    <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;wrong number of dimensions&#39;</span><span class="p">)</span>

        <span class="n">dims</span> <span class="o">=</span> <span class="n">dims</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">imagej_dims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;dimension </span><span class="si">{c}</span><span class="s1"> not among </span><span class="si">{imagej_dims}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="s1">&#39;TYX&#39;</span>
            <span class="c1"># Z and C</span>
            <span class="c1">#new_dim_indices = (1, 2)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="s1">&#39;TZYX&#39;</span>
            <span class="c1"># C</span>
            <span class="c1">#new_dim_indices = (2,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;unexpected number of dimensions to movie. have &#39;</span>
                <span class="n">f</span><span class="s1">&#39;{len(movie.shape)}. expected 3 (TYX) or 4 (TZYX).&#39;</span>
            <span class="p">)</span>

    <span class="n">n_dims_to_add</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">imagej_dims</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">movie</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">movie</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_dims_to_add</span><span class="p">)))</span>

    <span class="n">new_dims</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">imagej_dims</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">])</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="n">new_dims</span> <span class="o">+</span> <span class="n">dims</span>
    <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">imagej_dims</span><span class="p">)</span>

    <span class="n">movie</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">movie</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="n">dims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">imagej_dims</span><span class="p">])</span>

    <span class="c1"># TODO TODO is &quot;UserWarning: TiffWriter: truncating ImageJ file&quot; actually</span>
    <span class="c1"># something to mind? for example, w/ 2020-04-01/2/fn as input, the .raw is</span>
    <span class="c1"># 8.3GB and the .tif is 5.5GB (w/ 3 flyback frames for each 6 non-flyback</span>
    <span class="c1"># frames -&gt; 8.3 * (2/3) = ~5.53  (~ 5.5...). some docs say bigtiff is not</span>
    <span class="c1"># supported w/ imagej=True, so maybe that wouldn&#39;t be a quick fix if the</span>
    <span class="c1"># warning actually does matter. if not, maybe suppress it somehow?</span>

    <span class="c1"># TODO maybe just always do test from test_readraw here?</span>
    <span class="c1"># (or w/ flag to disable the check)</span>

    <span class="c1"># TODO TODO maybe just don&#39;t save w/ imagej=True? suite2p docs (or maybe it was</span>
    <span class="c1"># caiman docs?) seemed to suggest imagej tiffs might have some potentially-relevant</span>
    <span class="c1"># limitations... super specific i know</span>
    <span class="n">tifffile</span><span class="o">.</span><span class="n">imsave</span><span class="p">(</span><span class="n">tiff_filename</span><span class="p">,</span> <span class="n">movie</span><span class="p">,</span> <span class="n">imagej</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="full_frame_avg_trace"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.full_frame_avg_trace">[docs]</a><span class="k">def</span> <span class="nf">full_frame_avg_trace</span><span class="p">(</span><span class="n">movie</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes a (t,[z,]x,y) movie to t-length vector of frame averages.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Averages all dims but first, which is assumed to be time.</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">movie</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">movie</span><span class="o">.</span><span class="n">ndim</span><span class="p">)))</span></div>


<span class="c1"># TODO TODO switch order of args, and allow passing just coords. if just coords are</span>
<span class="c1"># passed, shift all towards 0 (+ margin). use for e.g. xpix/ypix stats elements in</span>
<span class="c1"># suite2p stat output. corresponding pixel weights in lam output would not need to be</span>
<span class="c1"># modified.</span>
<div class="viewcode-block" id="crop_to_coord_bbox"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.crop_to_coord_bbox">[docs]</a><span class="k">def</span> <span class="nf">crop_to_coord_bbox</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns matrix cropped to bbox of coords and bounds.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">x_min</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">y_min</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> \
        <span class="n">f</span><span class="s1">&#39;mins must be &gt;= 0 (x_min=</span><span class="si">{x_min}</span><span class="s1">, y_min=</span><span class="si">{y_min}</span><span class="s1">)&#39;</span>

    <span class="c1"># NOTE: apparently i had to use &lt;= or else some cases in old use of this function</span>
    <span class="c1"># (e.g. using certain CNMF outputs) would violate this. best to just fix that code</span>
    <span class="c1"># if it ever comes up again though.</span>
    <span class="k">assert</span> <span class="n">x_max</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">y_max</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span>
        <span class="n">f</span><span class="s1">&#39;maxes must be &lt; matrix shape = </span><span class="si">{matrix.shape}</span><span class="s1"> (x_max=</span><span class="si">{x_max}</span><span class="s1">&#39;</span> <span class="o">+</span>
        <span class="n">f</span><span class="s1">&#39;, y_max=</span><span class="si">{y_max}</span><span class="s1">&#39;</span>
    <span class="p">)</span>

    <span class="c1"># Keeping min at 0 to prevent slicing error in that case</span>
    <span class="c1"># (I think it will be empty, w/ -1:2, for instance)</span>
    <span class="c1"># Capping max not necessary to prevent err, but to make behavior of bounds</span>
    <span class="c1"># consistent on both edges.</span>
    <span class="c1"># TODO flag to err if margin would take it past edge? / warn?</span>
    <span class="n">x_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_min</span> <span class="o">-</span> <span class="n">margin</span><span class="p">)</span>
    <span class="n">y_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y_min</span> <span class="o">-</span> <span class="n">margin</span><span class="p">)</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x_max</span> <span class="o">+</span> <span class="n">margin</span><span class="p">,</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">y_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">y_max</span> <span class="o">+</span> <span class="n">margin</span><span class="p">,</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">cropped</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">x_min</span><span class="p">:</span><span class="n">x_max</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y_min</span><span class="p">:</span><span class="n">y_max</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">cropped</span><span class="p">,</span> <span class="p">((</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">),</span> <span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">))</span></div>


<div class="viewcode-block" id="crop_to_nonzero"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.crop_to_nonzero">[docs]</a><span class="k">def</span> <span class="nf">crop_to_nonzero</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a matrix just large enough to contain the non-zero elements of the</span>
<span class="sd">    input, and the bounding box coordinates to embed this matrix in a matrix</span>
<span class="sd">    with indices from (0,0) to the max coordinates in the input matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># nan_to_num will replace nan w/ 0 by default. infinities also converted but not</span>
    <span class="c1"># expected to be in input.</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">crop_to_coord_bbox</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="n">margin</span><span class="p">)</span></div>


<span class="c1"># TODO if these &#39;db_row2*&#39; fns are really just db related, move to db.py, but</span>
<span class="c1"># probably just rename...</span>
<span class="c1"># TODO better name?</span>
<div class="viewcode-block" id="db_row2footprint"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.db_row2footprint">[docs]</a><span class="k">def</span> <span class="nf">db_row2footprint</span><span class="p">(</span><span class="n">db_row</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns dense array w/ footprint from row in cells table.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="k">import</span> <span class="n">coo_matrix</span>
    <span class="n">weights</span><span class="p">,</span> <span class="n">x_coords</span><span class="p">,</span> <span class="n">y_coords</span> <span class="o">=</span> <span class="n">db_row</span><span class="p">[[</span><span class="s1">&#39;weights&#39;</span><span class="p">,</span><span class="s1">&#39;x_coords&#39;</span><span class="p">,</span><span class="s1">&#39;y_coords&#39;</span><span class="p">]]</span>
    <span class="c1"># TODO maybe read shape from db / metadata on disk? / merging w/ other</span>
    <span class="c1"># tables (possible?)?</span>
    <span class="n">footprint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">weights</span><span class="p">,</span> <span class="p">(</span><span class="n">x_coords</span><span class="p">,</span> <span class="n">y_coords</span><span class="p">)),</span>
        <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">todense</span><span class="p">())</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">footprint</span></div>


<div class="viewcode-block" id="db_footprints2array"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.db_footprints2array">[docs]</a><span class="k">def</span> <span class="nf">db_footprints2array</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns footprints in an array of dims (shape + (n_footprints,)).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">db_row2footprint</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()],</span>
        <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span></div>


<span class="c1"># TODO maybe refactor so there is a function does this for single arrays, then concat</span>
<span class="c1"># using xarray functions in here? or if i still want both functions, how to dedupe code?</span>
<span class="c1"># allow this to accept single rois too (without that component of shape)?</span>
<div class="viewcode-block" id="numpy2xarray_rois"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.numpy2xarray_rois">[docs]</a><span class="k">def</span> <span class="nf">numpy2xarray_rois</span><span class="p">(</span><span class="n">rois</span><span class="p">,</span> <span class="n">roi_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes numpy array of shape ([z,]y,x,roi) to labelled xarray.</span>

<span class="sd">    Args:</span>
<span class="sd">        roi_indices (None | dict): values must be iterables of length equal to number of</span>
<span class="sd">            ROIs. &#39;roi_num&#39; will be included as an additional ROI index regardless.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">rois</span><span class="o">.</span><span class="n">shape</span>
    <span class="c1"># TODO check that the fact that i swapped y and x now didn&#39;t break how i was using</span>
    <span class="c1"># this w/ actual ijrois / anything else. wanted to be more consistent w/ how</span>
    <span class="c1"># suite2p, ImageJ, etc seemed to do things.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;roi&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;roi&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;shape must have length 3 or 4&#39;</span><span class="p">)</span>

    <span class="c1"># NOTE: &#39;roi_num&#39; can&#39;t be replaced w/ &#39;roi&#39; b/c conflict w/ name of &#39;roi&#39; dim</span>
    <span class="n">roi_num_name</span> <span class="o">=</span> <span class="s1">&#39;roi_num&#39;</span>
    <span class="n">roi_index_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">roi_num_name</span><span class="p">]</span>
    <span class="n">roi_index_levels</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">rois</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>

    <span class="k">if</span> <span class="n">roi_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># If a &#39;roi_num&#39; level is passed in, it will replace the one that would be added</span>
        <span class="c1"># automatically.</span>
        <span class="k">if</span> <span class="n">roi_num_name</span> <span class="ow">in</span> <span class="n">roi_indices</span><span class="p">:</span>
            <span class="n">roi_index_names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">roi_index_levels</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">n_rois</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">ns</span><span class="p">,</span> <span class="n">xs</span> <span class="ow">in</span> <span class="n">roi_indices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_rois</span>
            <span class="n">roi_index_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span>
            <span class="n">roi_index_levels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>

    <span class="n">roi_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">roi_index_levels</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">roi_index_names</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">rois</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;roi&#39;</span><span class="p">:</span> <span class="n">roi_index</span><span class="p">})</span></div>


<span class="c1"># TODO TODO rename / delete one-or-the-other of this and contour2mask etc</span>
<span class="c1"># (+ accept ijroi[set] filename or something if actually gonna call it this)</span>
<span class="c1"># (ALSO include ijrois2masks in consideration for refactoring. this fn might not be</span>
<span class="c1"># necessary)</span>
<div class="viewcode-block" id="ijroi2mask"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.ijroi2mask">[docs]</a><span class="k">def</span> <span class="nf">ijroi2mask</span><span class="p">(</span><span class="n">roi</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        z (None | int): (optional) z-index ROI was drawn on</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This mask creation was taken from Yusuke N.&#39;s answer here:</span>
    <span class="c1"># https://stackoverflow.com/questions/3654289</span>
    <span class="kn">from</span> <span class="nn">matplotlib.path</span> <span class="k">import</span> <span class="n">Path</span>

    <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;len(shape) == {len(shape)}. must be 2 if z keyword &#39;</span>
                <span class="s1">&#39;argument not passed&#39;</span>
            <span class="p">)</span>

        <span class="c1"># TODO check transpose isn&#39;t necessary...</span>
        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">shape</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;shape must be (z, x, y) if z is passed. shape == </span><span class="si">{shape}</span><span class="s1">&#39;</span>
                <span class="s1">&#39;, which has the wrong length&#39;</span>
            <span class="p">)</span>

        <span class="c1"># TODO check transpose (of x and y) isn&#39;t necessary...</span>
        <span class="n">nz</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="k">if</span> <span class="n">z</span> <span class="o">&gt;=</span> <span class="n">nz</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;z (</span><span class="si">{z}</span><span class="s1">) out of bounds with z size (</span><span class="si">{nz}</span><span class="s1">) from shape[0]&#39;</span><span class="p">)</span>

    <span class="c1"># TODO test + delete</span>
    <span class="c1">#assert nx == ny, &#39;need to check code shoulnt be tranposing these&#39;</span>
    <span class="c1">#</span>

    <span class="c1"># Create vertex coordinates for each grid cell...</span>
    <span class="c1"># (&lt;0,0&gt; is at the top left of the grid in this system)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ny</span><span class="p">))</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

    <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">roi</span><span class="p">)</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">contains_points</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="c1"># Transpose makes this correct in testing on some of YZ&#39;s data</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mask</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vol_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
        <span class="n">vol_mask</span><span class="p">[</span><span class="n">z</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="k">return</span> <span class="n">vol_mask</span></div>


<span class="c1"># TODO TODO add option to translate ijroi labels to pandas index values?</span>
<span class="c1"># (and check trace extraction downstream preserves those!)</span>
<span class="c1"># TODO TODO TODO document type / structure expecations of `ijrois` arg!</span>
<span class="c1"># TODO TODO accept either the input or output of ijroi.read_roi[_zip] for ijrois?</span>
<span class="c1"># read_roi takes file object and read_roi_zip takes filename</span>
<span class="c1"># TODO can ijroi lib be modified to read path to tif things were drawn over (is that</span>
<span class="c1"># data there?), and can that be used to get shape? or can i also accept a path to tiff</span>
<span class="c1"># / thorimage dir / etc for that?</span>
<span class="c1"># TODO TODO option to use one of those scipy sparse arrays for the masks instead?</span>
<span class="c1"># TODO TODO maybe update all of my roi stuff that currently has the roi index as the</span>
<span class="c1"># last index so that it is the first index instead? feels more intuitive...</span>
<span class="c1"># TODO TODO make as_xarray default behavior and remove if other places that use this</span>
<span class="c1"># output don&#39;t break / change them</span>
<span class="c1"># TODO TODO TODO fn to convert suite2p representation of masks to the same [xarray]</span>
<span class="c1"># representation of masks this spits out</span>
<div class="viewcode-block" id="ijrois2masks"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.ijrois2masks">[docs]</a><span class="k">def</span> <span class="nf">ijrois2masks</span><span class="p">(</span><span class="n">ijrois</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">as_xarray</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># TODO be clear on where shape is coming from (just shape of the data in the TIFF</span>
    <span class="c1"># the ROIs were draw in, right?)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transforms ROIs loaded from my ijroi fork to an array full of boolean masks,</span>
<span class="sd">    of dimensions (shape + (n_rois,)).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">ijroi</span>

    <span class="c1"># TODO delete depending on how refactoring the below into xarray fn goes / whether</span>
    <span class="c1"># the non-xarray parts of this fn have the same requirements (which they probably</span>
    <span class="c1"># do...)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;shape must have length 2 or 3&#39;</span><span class="p">)</span>

    <span class="n">masks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">roi_z_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">prefixes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">suffixes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">roi</span> <span class="ow">in</span> <span class="n">ijrois</span><span class="p">:</span>

        <span class="n">z_index</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># Otherwise, it should simply be a numpy array with points.</span>
            <span class="c1"># `points_only=False` to either `read_roi_zip` or `read_roi` should produce</span>
            <span class="c1"># input suitable for this branch.</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">roi</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">z_index</span> <span class="o">=</span> <span class="n">roi</span><span class="o">.</span><span class="n">z</span>

            <span class="c1"># ROI was drawn on an image w/ only 3 dimensions (assuming the non-XY one</span>
            <span class="c1"># was Z)</span>
            <span class="k">elif</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">roi</span><span class="p">,</span> <span class="s1">&#39;position&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">z_index</span> <span class="o">=</span> <span class="n">roi</span><span class="o">.</span><span class="n">position</span>

            <span class="k">if</span> <span class="n">z_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># This should be the same as the `name` this shadows, just without the</span>
                <span class="c1"># &#39;.roi&#39; suffix.</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">roi</span><span class="o">.</span><span class="n">name</span>

                <span class="c1"># TODO eventually delete everything that uses parse_z_from_name.</span>
                <span class="c1"># is there any old code that depends on it?</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">_</span><span class="p">,</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">suffix</span><span class="p">)</span> <span class="o">=</span> <span class="n">ijroi</span><span class="o">.</span><span class="n">parse_z_from_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span>
                        <span class="n">return_unmatched</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">prefix</span> <span class="o">=</span> <span class="n">name</span>
                    <span class="n">suffix</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;trying to parse Z from ROI name. pass points_only=False&#39;</span>
                    <span class="s1">&#39; to ijroi loading function to read Z directly.&#39;</span>
                <span class="p">)</span>
                <span class="n">z_index</span><span class="p">,</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">suffix</span><span class="p">)</span> <span class="o">=</span> <span class="n">ijroi</span><span class="o">.</span><span class="n">parse_z_from_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">return_unmatched</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>

        <span class="n">points</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">roi</span><span class="p">,</span> <span class="s1">&#39;points&#39;</span><span class="p">,</span> <span class="n">roi</span><span class="p">)</span>

        <span class="c1"># TODO may also need to reverse part of shape here, if really was</span>
        <span class="c1"># necessary above (test would probably need to be in asymmetric</span>
        <span class="c1"># case...)</span>
        <span class="n">masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ijroi2mask</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z_index</span><span class="p">))</span>
        <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">roi_z_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z_index</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">suffix</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">suffix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="n">prefixes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
            <span class="n">suffixes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">suffix</span><span class="p">)</span>

    <span class="c1"># This concatenates along the last element of the new shape</span>
    <span class="n">masks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">as_xarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">masks</span>

    <span class="n">roi_index_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;roi_name&#39;</span><span class="p">]</span>
    <span class="n">roi_index_levels</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">roi_index_names</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;roi_z&#39;</span><span class="p">,</span> <span class="s1">&#39;ijroi_prefix&#39;</span><span class="p">,</span> <span class="s1">&#39;ijroi_suffix&#39;</span><span class="p">]</span>
        <span class="n">roi_index_levels</span> <span class="o">+=</span> <span class="p">[</span><span class="n">roi_z_indices</span><span class="p">,</span> <span class="n">prefixes</span><span class="p">,</span> <span class="n">suffixes</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">numpy2xarray_rois</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span>
        <span class="n">roi_indices</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">roi_index_names</span><span class="p">,</span> <span class="n">roi_index_levels</span><span class="p">))</span>
    <span class="p">)</span></div>


<span class="c1"># TODO maybe add a fn to plot single xarray masks for debugging?</span>
<span class="c1"># TODO TODO change `on` default to something like `roi`</span>
<div class="viewcode-block" id="merge_rois"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.merge_rois">[docs]</a><span class="k">def</span> <span class="nf">merge_rois</span><span class="p">(</span><span class="n">rois</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;ijroi_prefix&#39;</span><span class="p">,</span> <span class="n">merge_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">check_no_overlap</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        rois (xarray.DataArray): must have at least dims &#39;x&#39;, &#39;y&#39;, and &#39;roi&#39;.</span>
<span class="sd">            &#39;roi&#39; should be indexed by a MultiIndex and one of the levels should have</span>
<span class="sd">            the name of the `on` argument. Currently expect the dtype to be &#39;bool&#39;.</span>

<span class="sd">        on (str): name of other ROI metadata dimension to merge on</span>

<span class="sd">        label_fn (callable): function mapping the values of the `on` column to labels</span>
<span class="sd">            for the ROIs. Only ROIs created via merging will be given these labels,</span>
<span class="sd">            while unmerged ROIs will recieve unique number labels. Defaults to the</span>
<span class="sd">            identity function.</span>

<span class="sd">        check_no_overlap (bool): (optional, default=False) If True, checks that no</span>
<span class="sd">            merged rois shared any pixels before being merged. If merged ROIs are all</span>
<span class="sd">            on different planes, this should be True because ImageJ ROIs are defined on</span>
<span class="sd">            single planes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO assert bool before this / rename to something like &#39;total_weight&#39; that would</span>
    <span class="c1"># apply in non-boolean-mask case too</span>
    <span class="n">total_weight_before</span> <span class="o">=</span> <span class="n">rois</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="n">n_rois_before</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rois</span><span class="o">.</span><span class="n">roi</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_nonroi_shape</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">n</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s1">&#39;roi&#39;</span><span class="p">}</span>

    <span class="n">nonroi_shape_before</span> <span class="o">=</span> <span class="n">get_nonroi_shape</span><span class="p">(</span><span class="n">rois</span><span class="p">)</span>

    <span class="c1"># TODO maybe i should use sum instead, if i&#39;m not going to make the aggregation</span>
    <span class="c1"># function configurable?</span>
    <span class="c1"># If `on` contains NaN values, the groupby will not include groups for the NaN</span>
    <span class="c1"># values, and there is no argument to configure this (as in pandas). Therefore,</span>
    <span class="c1"># we need to drop things that were merged and then add these to what remains.</span>
    <span class="c1"># TODO do i need to check that nothing else conflicts w/ what i plan on renaming</span>
    <span class="c1"># `on` to (&#39;roi&#39;)?</span>
    <span class="k">if</span> <span class="n">merge_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="n">rois</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">on</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#raise NotImplementedError</span>
        <span class="c1"># TODO maybe try reduce? might need other inputs tho...</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="n">rois</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">on</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">merge_fn</span><span class="p">)</span>

    <span class="c1"># TODO some kind of inplace version of this? or does xarray not really do that?</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="n">on</span><span class="p">:</span> <span class="s1">&#39;roi&#39;</span><span class="p">})</span>

    <span class="k">if</span> <span class="n">label_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">label_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>

    <span class="n">merged_roi_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">label_fn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">merged</span><span class="o">.</span><span class="n">roi</span><span class="o">.</span><span class="n">values</span><span class="p">]</span>
    <span class="c1"># Trying to pass label_fn here instead of calling before didn&#39;t work b/c it seems to</span>
    <span class="c1"># expect a fn that takes a DataArray (and it&#39;s not passing scalar DataArrays either)</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">roi</span><span class="o">=</span><span class="n">merged_roi_labels</span><span class="p">)</span>

    <span class="n">not_merged</span> <span class="o">=</span> <span class="n">rois</span><span class="p">[</span><span class="n">on</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span>
    <span class="n">unmerged</span> <span class="o">=</span> <span class="n">rois</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">not_merged</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="s1">&#39;roi&#39;</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">n_orig_rois_merged</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span> <span class="n">not_merged</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">n_rois_after</span> <span class="o">=</span> <span class="n">n_rois_before</span> <span class="o">-</span> <span class="n">n_orig_rois_merged</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">merged</span><span class="o">.</span><span class="n">roi</span><span class="p">)</span>

    <span class="n">available_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_rois_after</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">merged_roi_labels</span><span class="p">]</span>
    <span class="n">unmerged_roi_labels</span> <span class="o">=</span> <span class="n">available_labels</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">unmerged</span><span class="o">.</span><span class="n">roi</span><span class="p">)]</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">unmerged_roi_labels</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">unmerged</span><span class="o">.</span><span class="n">roi</span><span class="p">)</span>
    <span class="n">unmerged</span> <span class="o">=</span> <span class="n">unmerged</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">roi</span><span class="o">=</span><span class="n">unmerged_roi_labels</span><span class="p">)</span>

    <span class="c1"># The .groupby (seemingly with any function application, as .first() also does it)</span>
    <span class="c1"># and .where both change the dtype to float64 from bool</span>
    <span class="n">was_bool</span> <span class="o">=</span> <span class="n">rois</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;bool&#39;</span>

    <span class="n">rois</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">merged</span><span class="p">,</span> <span class="n">unmerged</span><span class="p">],</span> <span class="s1">&#39;roi&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">was_bool</span><span class="p">:</span>
        <span class="n">rois</span> <span class="o">=</span> <span class="n">rois</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">n_rois_after</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">rois</span><span class="o">.</span><span class="n">roi</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">rois</span><span class="o">.</span><span class="n">roi</span><span class="o">.</span><span class="n">values</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">rois</span><span class="o">.</span><span class="n">roi</span><span class="p">)</span>

    <span class="n">total_weight_after</span> <span class="o">=</span> <span class="n">rois</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">check_no_overlap</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">total_weight_before</span> <span class="o">==</span> <span class="n">total_weight_after</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">total_weight_before</span> <span class="o">&gt;=</span> <span class="n">total_weight_after</span>

    <span class="n">nonroi_shape_after</span> <span class="o">=</span> <span class="n">get_nonroi_shape</span><span class="p">(</span><span class="n">rois</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">nonroi_shape_before</span> <span class="o">==</span> <span class="n">nonroi_shape_after</span>

    <span class="k">return</span> <span class="n">rois</span></div>


<div class="viewcode-block" id="merge_ijroi_masks"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.merge_ijroi_masks">[docs]</a><span class="k">def</span> <span class="nf">merge_ijroi_masks</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        masks (xarray.DataArray): must have at least dims &#39;x&#39;, &#39;y&#39;, and &#39;roi&#39;.</span>
<span class="sd">            &#39;roi&#39; should be indexed by a MultiIndex and one of the levels should have</span>
<span class="sd">            the name of the `on` argument. Currently expect the dtype to be &#39;bool&#39;.</span>

<span class="sd">        label_fn (callable): function mapping the values of the `on` column to labels</span>
<span class="sd">            for the ROIs. Only ROIs created via merging will be given these labels,</span>
<span class="sd">            while unmerged ROIs will recieve unique number labels. Defaults to a</span>
<span class="sd">            function that takes strings, removes trailing/leading underscores, and</span>
<span class="sd">            parses an int from what remains.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO probably assert bool</span>
    <span class="c1"># TODO assert ijroi_prefix in here / accept kwarg on (defaulting to same), and</span>
    <span class="c1"># assert that&#39;s here</span>

    <span class="k">return</span> <span class="n">merge_rois</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;ijroi_prefix&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="c1"># TODO TODO TODO make another function that groups rois based on spatial overlap</span>
<span class="c1"># (params to include [variable-number-of?] dilation steps, fraction of pixels[/weight?]</span>
<span class="c1"># that need to overlap, and correlation of responses required) -&gt; generate appropriate</span>
<span class="c1"># input to [refactored + renamed] merge_ijroi_masks fn below, particularly the `masks`</span>
<span class="c1"># and `on` arguments, and have label_fn be identity</span>

<span class="c1"># TODO TODO how to handle a correlation threshold? pass correlations of some kind in</span>
<span class="c1"># or something to compute them from (probably the former, or make the correlation</span>
<span class="c1"># thresholding a separate step)?</span>
<div class="viewcode-block" id="merge_single_plane_rois"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.merge_single_plane_rois">[docs]</a><span class="k">def</span> <span class="nf">merge_single_plane_rois</span><span class="p">(</span><span class="n">rois</span><span class="p">,</span> <span class="n">min_overlap_frac</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">n_dilations</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For handling single plane ROIs that are on adjacent Z planes, and correspond to the</span>
<span class="sd">    same biological feature. This is to merge the single plane ROIs that suite2p</span>
<span class="sd">    outputs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="kn">import</span> <span class="nn">ipdb</span><span class="p">;</span> <span class="n">ipdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span></div>


<span class="c1"># TODO TODO refactor this + hong2p.suite2p.remerge_suite2p_merged to share core code</span>
<span class="c1"># here! (this initially copied from other fn and then adapted)</span>
<div class="viewcode-block" id="rois2best_planes_only"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.rois2best_planes_only">[docs]</a><span class="k">def</span> <span class="nf">rois2best_planes_only</span><span class="p">(</span><span class="n">rois</span><span class="p">,</span> <span class="n">roi_quality</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Currently assumes input only has non-zero values in a single plane for a given</span>
<span class="sd">    unique combination of ROI identifier variables.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># TODO TODO implement another strategy where as long as the roi_quality are</span>
    <span class="c1"># within some tolerance of the best, they are averaged? or weighted according to</span>
    <span class="c1"># response stat? weight according to variance of response stat (see examples of</span>
    <span class="c1"># weighted averages using something derived from variance for weights online)</span>
    <span class="c1"># TODO maybe also use 2/3rd highest lowest frame / percentile rather than actual min</span>
    <span class="c1"># / max (for picking &#39;best&#39; plane), to gaurd against spiking noise</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    merge_output_roi_nums = np.empty(len(roi_quality.columns)) * np.nan</span>
<span class="sd">    # TODO maybe build up set of seen merge input indices and check they are all seen in</span>
<span class="sd">    # columns of traces by end (that set seen in traces columns is same as set from</span>
<span class="sd">    # unioning all values in merges)</span>
<span class="sd">    for merge_output_roi_num, merge_input_roi_nums in merges.items():</span>

<span class="sd">        #merge_output_roi_nums[traces.columns.isin(merge_input_roi_nums)] = \</span>
<span class="sd">        merge_output_roi_nums[roi_quality.columns.isin(merge_input_roi_nums)] = \</span>
<span class="sd">            merge_output_roi_num</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">roi_quality</span> <span class="o">=</span> <span class="n">roi_quality</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;roi_quality&#39;</span><span class="p">)</span>
    <span class="n">mo_key</span> <span class="o">=</span> <span class="s1">&#39;name&#39;</span>
    <span class="c1">#roi_quality[mo_key] = merge_output_roi_nums</span>
    <span class="n">roi_quality</span><span class="p">[</span><span class="n">mo_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">rois</span><span class="o">.</span><span class="n">roi</span><span class="o">.</span><span class="n">roi_name</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">gb</span> <span class="o">=</span> <span class="n">roi_quality</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">mo_key</span><span class="p">)</span>
    <span class="n">best_per_merge_output</span> <span class="o">=</span> <span class="n">gb</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()</span>

    <span class="c1"># Selecting the only column this DataFrame has (i.e. shape (n, 1))</span>
    <span class="n">best_inputs</span> <span class="o">=</span> <span class="n">best_per_merge_output</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="c1"># The groupby -&gt; idxmax() otherwise would have left this column named</span>
    <span class="c1"># &#39;roi_quality&#39;, which is what we were picking an index to maximize, but the</span>
    <span class="c1"># indices themselves are not response statistics.</span>
    <span class="n">best_inputs</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;roi&#39;</span>

    <span class="n">best</span> <span class="o">=</span> <span class="n">roi_quality</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">best_inputs</span><span class="p">]</span>

    <span class="c1"># TODO delete eventually</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span>
       <span class="n">roi_quality</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">best_inputs</span><span class="o">.</span><span class="n">values</span><span class="p">],</span>
       <span class="n">roi_quality</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">best_inputs</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="c1">#</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span>
        <span class="n">best</span><span class="o">.</span><span class="n">roi_quality</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="n">gb</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">roi_quality</span><span class="o">.</span><span class="n">values</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">by_response</span> <span class="o">=</span> <span class="n">roi_quality</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span>
            <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">swaplevel</span><span class="p">()</span>

    <span class="n">notbest_to_drop</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">best</span><span class="o">.</span><span class="n">itertuples</span><span class="p">():</span>
        <span class="n">merged_name</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">name</span>
        <span class="n">curr_best</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">Index</span>
        <span class="n">curr_notbest</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rois</span><span class="o">.</span><span class="n">roi</span><span class="p">[</span>
            <span class="p">(</span><span class="n">rois</span><span class="o">.</span><span class="n">roi_name</span> <span class="o">==</span> <span class="n">merged_name</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">rois</span><span class="o">.</span><span class="n">roi_num</span> <span class="o">!=</span> <span class="n">curr_best</span><span class="p">)</span>
        <span class="p">]</span><span class="o">.</span><span class="n">roi_num</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="n">notbest_to_drop</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">curr_notbest</span><span class="p">)</span>

        <span class="c1"># only print if multiple inputs (i.e. actually &#39;merging&#39; in some sense)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_notbest</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;merging ROI </span><span class="si">{merged_name}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;selecting input ROI </span><span class="si">{curr_best}</span><span class="s1"> as best plane&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;dropping other input ROIs </span><span class="si">{curr_notbest}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">by_response</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">merged_name</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">()</span>

    <span class="c1"># TODO maybe combine in to one step by just passing subsetted s2p_roi_num to</span>
    <span class="c1"># assign_coords?</span>
    <span class="n">rois</span> <span class="o">=</span> <span class="n">rois</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">roi</span><span class="o">=</span> <span class="o">~</span> <span class="n">rois</span><span class="o">.</span><span class="n">roi_num</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">notbest_to_drop</span><span class="p">))</span>

    <span class="n">roi_nums</span> <span class="o">=</span> <span class="n">rois</span><span class="o">.</span><span class="n">roi_num</span><span class="o">.</span><span class="n">values</span>

    <span class="c1"># TODO should i also include roi_z? would want to also do / use in s2p case for</span>
    <span class="c1"># consistency... also, how to modify this call to accomplish that?</span>
    <span class="n">rois</span> <span class="o">=</span> <span class="n">rois</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">roi</span><span class="o">=</span><span class="n">rois</span><span class="o">.</span><span class="n">roi_name</span><span class="p">)</span>

    <span class="c1"># TODO TODO if i can figure out how to keep multiple levels for the roi dimension,</span>
    <span class="c1"># do that rather than return multiple things</span>
    <span class="k">return</span> <span class="n">roi_nums</span><span class="p">,</span> <span class="n">rois</span></div>


<span class="n">ijroiset_default_basename</span> <span class="o">=</span> <span class="s1">&#39;RoiSet.zip&#39;</span>

<div class="viewcode-block" id="ijroi_filename"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.ijroi_filename">[docs]</a><span class="k">def</span> <span class="nf">ijroi_filename</span><span class="p">(</span><span class="n">ijroiset_dir_or_fname</span><span class="p">,</span> <span class="n">must_exist</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">isdir</span><span class="p">(</span><span class="n">ijroiset_dir_or_fname</span><span class="p">):</span>

        <span class="c1"># TODO if i standardize path to analysis intermediates, update this to look for</span>
        <span class="c1"># RoiSet.zip there?</span>
        <span class="n">ijroiset_fname</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">ijroiset_dir_or_fname</span><span class="p">,</span> <span class="n">ijroiset_default_basename</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">must_exist</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">isfile</span><span class="p">(</span><span class="n">ijroiset_fname</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;directory passed for ijroiset_dir_or_fname, but &#39;</span>
                <span class="n">f</span><span class="s1">&#39;</span><span class="si">{ijroiset_fname}</span><span class="s1"> did not exist&#39;</span>
            <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">ijroiset_fname</span> <span class="o">=</span> <span class="n">ijroiset_dir_or_fname</span>

    <span class="k">return</span> <span class="n">ijroiset_fname</span></div>


<div class="viewcode-block" id="has_ijrois"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.has_ijrois">[docs]</a><span class="k">def</span> <span class="nf">has_ijrois</span><span class="p">(</span><span class="n">ijroiset_dir_or_fname</span><span class="p">):</span>
    <span class="c1"># NOTE: not actually checking it contains any</span>
    <span class="n">ijroiset_fname</span> <span class="o">=</span> <span class="n">ijroi_filename</span><span class="p">(</span><span class="n">ijroiset_dir_or_fname</span><span class="p">,</span> <span class="n">must_exist</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">exists</span><span class="p">(</span><span class="n">ijroiset_fname</span><span class="p">)</span></div>


<div class="viewcode-block" id="ijroi_mtime"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.ijroi_mtime">[docs]</a><span class="k">def</span> <span class="nf">ijroi_mtime</span><span class="p">(</span><span class="n">ijroiset_dir_or_fname</span><span class="p">):</span>
    <span class="n">ijroiset_fname</span> <span class="o">=</span> <span class="n">ijroi_filename</span><span class="p">(</span><span class="n">ijroiset_dir_or_fname</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">getmtime</span><span class="p">(</span><span class="n">ijroiset_fname</span><span class="p">)</span></div>


<div class="viewcode-block" id="ijroi_masks"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.ijroi_masks">[docs]</a><span class="k">def</span> <span class="nf">ijroi_masks</span><span class="p">(</span><span class="n">ijroiset_dir_or_fname</span><span class="p">,</span> <span class="n">thorimage_dir</span><span class="p">,</span> <span class="n">as_xarray</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="c1"># This must be my fork at https://github.com/tom-f-oconnell/ijroi</span>
    <span class="kn">import</span> <span class="nn">ijroi</span>

    <span class="n">ijroiset_fname</span> <span class="o">=</span> <span class="n">ijroi_filename</span><span class="p">(</span><span class="n">ijroiset_dir_or_fname</span><span class="p">)</span>

    <span class="n">name_and_roi_list</span> <span class="o">=</span> <span class="n">ijroi</span><span class="o">.</span><span class="n">read_roi_zip</span><span class="p">(</span><span class="n">ijroiset_fname</span><span class="p">,</span> <span class="n">points_only</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">_</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">z</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span>  <span class="n">thor</span><span class="o">.</span><span class="n">load_thorimage_metadata</span><span class="p">(</span><span class="n">thorimage_dir</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;not tested in case x != y&#39;</span>

    <span class="c1"># From what `thor.read_movie` says the output dimensions are (except the first</span>
    <span class="c1"># dimension, which is time).</span>
    <span class="k">if</span> <span class="n">z</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">movie_shape_without_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">movie_shape_without_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="n">masks</span> <span class="o">=</span> <span class="n">ijrois2masks</span><span class="p">(</span><span class="n">name_and_roi_list</span><span class="p">,</span> <span class="n">movie_shape_without_time</span><span class="p">,</span>
        <span class="n">as_xarray</span><span class="o">=</span><span class="n">as_xarray</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">masks</span></div>

    <span class="c1">## TODO modify check_no_overlap to make sure it&#39;s also erring if two things that</span>
    <span class="c1">## would be merged (by having same name / whatever) are not in the same z-plane</span>
    <span class="c1">## (assuming the intention was to have one per plane, to make a single volumetric</span>
    <span class="c1">## ROI)</span>
    <span class="c1">#merged = merge_ijroi_masks(masks, check_no_overlap=True)</span>
    <span class="c1">#</span>
    <span class="c1">#import ipdb; ipdb.set_trace()</span>
    <span class="c1">#</span>
    <span class="c1">#return merged</span>


<span class="c1"># TODO test / document requirements for type / properties of contour. it&#39;s just a</span>
<span class="c1"># numpy array of points, right? doesn&#39;t need start = end or anything, does it?</span>
<div class="viewcode-block" id="contour2mask"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.contour2mask">[docs]</a><span class="k">def</span> <span class="nf">contour2mask</span><span class="p">(</span><span class="n">contour</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a boolean mask True inside contour and False outside.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO TODO TODO appropriate checking of contour input. i.e. any requirements on</span>
    <span class="c1"># first/last point / order (do some orders imply overlapping edge segments, and if</span>
    <span class="c1"># so, check there are none of those)</span>
    <span class="kn">import</span> <span class="nn">cv2</span>
    <span class="c1"># TODO any checking of contour necessary for it to be well behaved in</span>
    <span class="c1"># opencv?</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

    <span class="c1"># NOTE: at some point i think i needed convexHull in ijroi2mask to get that + this</span>
    <span class="c1"># to work as I expected. AS I THINK CONVEXHULL MIGHT RESULT IN SOME UNEXPECTED</span>
    <span class="c1"># MODIFICATIONS TO CONTOURS, i need to change that code, and that might break some</span>
    <span class="c1"># of this code too</span>
    <span class="c1"># TODO TODO TODO if drawContours truly does need convex hull inputs, need to change</span>
    <span class="c1"># this function to no longer use drawContours</span>
    <span class="c1"># TODO TODO TODO see strategy i recommended to yang recently and consider using it</span>
    <span class="c1"># here instead</span>
    <span class="c1"># TODO draw into a sparse array maybe? or convert after?</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">drawContours</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="p">[</span><span class="n">contour</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># TODO TODO TODO investigate need for this transpose</span>
    <span class="c1"># (imagej contour repr specific? maybe load to contours w/ dims swapped them</span>
    <span class="c1"># call this fn w/o transpose?)</span>
    <span class="c1"># (was it somehow still a product of x_coords / y_coords being swapped in</span>
    <span class="c1"># db?)</span>
    <span class="c1"># not just b/c reshaping to something expecting F order CNMF stuff?</span>
    <span class="c1"># didn&#39;t correct time averaging w/in roi also require this?</span>
    <span class="k">return</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span></div>


<span class="c1"># TODO rename these two to indicate it only works on images (not coordinates)</span>
<span class="c1"># TODO and make + use fns that operate on coordinates?</span>
<div class="viewcode-block" id="imagej2py_coords"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.imagej2py_coords">[docs]</a><span class="k">def</span> <span class="nf">imagej2py_coords</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Since ijroi source seems to have Y as first coord and X as second.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO how does this behave in the 3d case...?</span>
    <span class="c1"># still what i want, or should i exclude the z dimension somehow?</span>
    <span class="c1"># TODO TODO TODO probably just delete any code that actually relied on this?</span>
    <span class="c1"># assuming it doesn&#39;t still make sense...</span>
    <span class="c1">#return array.T</span>
    <span class="k">return</span> <span class="n">array</span></div>


<div class="viewcode-block" id="py2imagej_coords"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.py2imagej_coords">[docs]</a><span class="k">def</span> <span class="nf">py2imagej_coords</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Since ijroi source seems to have Y as first coord and X as second.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO TODO TODO probably just delete any code that actually relied on this?</span>
    <span class="c1"># assuming it doesn&#39;t still make sense...</span>
    <span class="c1">#return array.T</span>
    <span class="k">return</span> <span class="n">array</span></div>


<span class="c1"># TODO maybe move to a submodule for interfacing w/ cnmf?</span>
<span class="c1"># TODO TODO probably make a corresponding fn to do the inverse</span>
<span class="c1"># (or is one of these not necessary? in one dir, is order=&#39;C&#39; and order</span>
<div class="viewcode-block" id="footprints_to_flat_cnmf_dims"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.footprints_to_flat_cnmf_dims">[docs]</a><span class="k">def</span> <span class="nf">footprints_to_flat_cnmf_dims</span><span class="p">(</span><span class="n">footprints</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes array of (x, y[, z], n_footprints) to (n_pixels, n_footprints).</span>

<span class="sd">    There is more than one way this reshaping can be done, and this produces</span>
<span class="sd">    output as CNMF expects it.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">frame_pixels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">footprints</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">n_footprints</span> <span class="o">=</span> <span class="n">footprints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># TODO TODO is this supposed to be order=&#39;F&#39; or order=&#39;C&#39; matter?</span>
    <span class="c1"># wrong setting equivalent to transpose?</span>
    <span class="c1"># what&#39;s the appropriate test (make unit?)?</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">footprints</span><span class="p">,</span> <span class="p">(</span><span class="n">frame_pixels</span><span class="p">,</span> <span class="n">n_footprints</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="extract_traces_bool_masks"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.extract_traces_bool_masks">[docs]</a><span class="k">def</span> <span class="nf">extract_traces_bool_masks</span><span class="p">(</span><span class="n">movie</span><span class="p">,</span> <span class="n">footprints</span><span class="p">,</span>
    <span class="n">footprint_framenums</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Averages the movie within each boolean mask in footprints</span>
<span class="sd">    to make a matrix of traces (n_frames x n_footprints).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">footprints</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;float footprints are not boolean&#39;</span>
    <span class="k">assert</span> <span class="n">footprints</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;footprints not boolean&#39;</span>
    <span class="k">assert</span> <span class="n">footprints</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;footprints not boolean&#39;</span>
    <span class="n">n_spatial_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">footprints</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">spatial_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_spatial_dims</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">footprints</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">spatial_dims</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s1">&#39;some zero footprints&#39;</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="n">n_spatial_dims</span>
    <span class="n">n_frames</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n_footprints</span> <span class="o">=</span> <span class="n">footprints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">traces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_frames</span><span class="p">,</span> <span class="n">n_footprints</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;extracting traces from boolean masks...&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># TODO vectorized way to do this?</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_footprints</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">footprints</span><span class="p">[</span><span class="n">slices</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="p">,)]</span>
        <span class="c1"># TODO compare time of this to sparse matrix dot product?</span>
        <span class="c1"># + time of MaskedArray-&gt;mean w/ mask expanded by n_frames?</span>

        <span class="c1"># TODO TODO is this correct? check</span>
        <span class="c1"># axis=1 because movie[:, mask] only has two dims (frames x pixels)</span>
        <span class="n">trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">movie</span><span class="p">[:,</span> <span class="n">mask</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_frames</span>
        <span class="n">traces</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">trace</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; done&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">traces</span></div>


<div class="viewcode-block" id="exp_decay"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.exp_decay">[docs]</a><span class="k">def</span> <span class="nf">exp_decay</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
    <span class="c1"># TODO is this the usual definition of tau (as in RC time constant?)</span>
    <span class="k">return</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span> <span class="o">/</span> <span class="n">tau</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span></div>


<span class="c1"># TODO call for each odor onset (after fixed onset period?)</span>
<span class="c1"># est onset period? est rise kinetics jointly? how does cnmf do it?</span>
<div class="viewcode-block" id="fit_exp_decay"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.fit_exp_decay">[docs]</a><span class="k">def</span> <span class="nf">fit_exp_decay</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">numerical_scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns fit parameters for an exponential decay in the input signal.</span>

<span class="sd">    Args:</span>
<span class="sd">        signal (1 dimensional np.ndarray): time series, beginning at decay onset</span>
<span class="sd">        sampling_rate (float): sampling rate in Hz</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">curve_fit</span>

    <span class="k">if</span> <span class="n">sampling_rate</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;pass either sampling_rate or times as keyword arg&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sampling_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sampling_interval</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sampling_rate</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
        <span class="n">end_time</span> <span class="o">=</span> <span class="n">n_samples</span> <span class="o">*</span> <span class="n">sampling_interval</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># TODO make sure input is not modified here. copy?</span>
    <span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span> <span class="o">*</span> <span class="n">numerical_scale</span>

    <span class="c1"># TODO constrain params somehow? for example, so scale stays positive</span>
    <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">exp_decay</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span>
        <span class="n">p0</span><span class="o">=</span><span class="p">(</span><span class="mf">1.8</span> <span class="o">*</span> <span class="n">numerical_scale</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="n">numerical_scale</span><span class="p">))</span>

    <span class="c1"># TODO is this correct to scale after converting variance to stddev?</span>
    <span class="n">sigmas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">pcov</span><span class="p">))</span>
    <span class="n">sigmas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigmas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">numerical_scale</span>
    <span class="c1"># skipping tau, which shouldn&#39;t need to change (?)</span>
    <span class="n">sigmas</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigmas</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">numerical_scale</span>

    <span class="c1"># TODO only keep this if signal is modified s.t. it affects calling fn.</span>
    <span class="c1"># in this case, maybe still just copy above?</span>
    <span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span> <span class="o">/</span> <span class="n">numerical_scale</span>

    <span class="n">scale</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">popt</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">scale</span> <span class="o">/</span> <span class="n">numerical_scale</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">offset</span> <span class="o">/</span> <span class="n">numerical_scale</span><span class="p">),</span> <span class="n">sigmas</span></div>


<div class="viewcode-block" id="n_expected_repeats"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.n_expected_repeats">[docs]</a><span class="k">def</span> <span class="nf">n_expected_repeats</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns expected # repeats given DataFrame w/ repeat_num col.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">max_repeat</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">repeat_num</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">max_repeat</span> <span class="o">+</span> <span class="mi">1</span></div>


<span class="c1"># TODO TODO could now probably switch to using block metadata in recording table</span>
<span class="c1"># (n_repeats should be in there)</span>
<span class="c1"># TODO move to project specific repo unless stimulus metadata can be</span>
<span class="c1"># meaningfully generalized</span>
<div class="viewcode-block" id="missing_repeats"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.missing_repeats">[docs]</a><span class="k">def</span> <span class="nf">missing_repeats</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Requires at least recording_from, comparison, name1, name2, and repeat_num</span>
<span class="sd">    columns. Can also take prep_date, fly_num, thorimage_id.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO n_repeats default to 3 or None?</span>
    <span class="k">if</span> <span class="n">n_repeats</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># TODO or should i require input is merged w/ recordings for stimuli</span>
        <span class="c1"># data file paths and then just load for n_repeats and stuff?</span>
        <span class="n">n_repeats</span> <span class="o">=</span> <span class="n">n_expected_repeats</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

    <span class="c1"># Expect repeats to include {0,1,2} for 3 repeat experiments.</span>
    <span class="n">expected_repeats</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_repeats</span><span class="p">))</span>

    <span class="n">repeat_cols</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">opt_repeat_cols</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;prep_date&#39;</span><span class="p">,</span>
        <span class="s1">&#39;fly_num&#39;</span><span class="p">,</span>
        <span class="s1">&#39;thorimage_id&#39;</span>
    <span class="p">]</span>
    <span class="k">for</span> <span class="n">oc</span> <span class="ow">in</span> <span class="n">opt_repeat_cols</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">oc</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">repeat_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oc</span><span class="p">)</span>

    <span class="n">repeat_cols</span> <span class="o">+=</span> <span class="p">[</span>
        <span class="s1">&#39;recording_from&#39;</span><span class="p">,</span>
        <span class="s1">&#39;comparison&#39;</span><span class="p">,</span>
        <span class="s1">&#39;name1&#39;</span><span class="p">,</span>
        <span class="s1">&#39;name2&#39;</span><span class="c1">#,</span>
        <span class="c1">#&#39;log10_conc_vv1&#39;,</span>
        <span class="c1">#&#39;log10_conc_vv2&#39;</span>
    <span class="p">]</span>
    <span class="c1"># TODO some issue created by using float concs as a key?</span>
    <span class="c1"># TODO use odor ids instead?</span>
    <span class="n">missing_repeat_dfs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">gdf</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">repeat_cols</span><span class="p">):</span>
        <span class="n">comparison_n_repeats</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">repeat_num</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

        <span class="n">no_extra_repeats</span> <span class="o">=</span> <span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">repeat_num</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">no_extra_repeats</span>

        <span class="n">missing_repeats</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">expected_repeats</span>
            <span class="k">if</span> <span class="n">r</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">comparison_n_repeats</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_repeats</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">gmeta</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">repeat_cols</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">missing_repeats</span><span class="p">:</span>
            <span class="n">new_row</span> <span class="o">=</span> <span class="n">gmeta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_row</span><span class="p">[</span><span class="s1">&#39;repeat_num&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
            <span class="n">missing_repeat_dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_row</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_repeat_dfs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">missing_repeats_df</span> <span class="o">=</span> \
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="n">r</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">repeat_cols</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;repeat_num&#39;</span><span class="p">]})</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># TODO maybe merge w/ odor info so caller doesn&#39;t have to, if thats the</span>
        <span class="c1"># most useful for troubleshooting?</span>
        <span class="n">missing_repeats_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">missing_repeat_dfs</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">missing_repeats_df</span><span class="o">.</span><span class="n">recording_from</span> <span class="o">=</span> \
        <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">missing_repeats_df</span><span class="o">.</span><span class="n">recording_from</span><span class="p">)</span>

    <span class="c1"># TODO should expected # blocks be passed in?</span>

    <span class="k">return</span> <span class="n">missing_repeats_df</span></div>


<div class="viewcode-block" id="have_all_repeats"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.have_all_repeats">[docs]</a><span class="k">def</span> <span class="nf">have_all_repeats</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if a recording has all blocks gsheet says it has, w/ full</span>
<span class="sd">    number of repeats for each. False otherwise.</span>

<span class="sd">    Requires at least recording_from, comparison, name1, name2, and repeat_num</span>
<span class="sd">    columns. Can also take prep_date, fly_num, thorimage_id.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">missing_repeats_df</span> <span class="o">=</span> <span class="n">missing_repeats</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span><span class="n">n_repeats</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_repeats_df</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="missing_odor_pairs"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.missing_odor_pairs">[docs]</a><span class="k">def</span> <span class="nf">missing_odor_pairs</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Requires at least recording_from, comparison, name1, name2 columns.</span>
<span class="sd">    Can also take prep_date, fly_num, thorimage_id.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO check that for each comparison, both A, B, and A+B are there</span>
    <span class="c1"># (3 combos of name1, name2, or whichever other odor ids)</span>
    <span class="n">comp_cols</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">opt_rec_cols</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;prep_date&#39;</span><span class="p">,</span>
        <span class="s1">&#39;fly_num&#39;</span><span class="p">,</span>
        <span class="s1">&#39;thorimage_id&#39;</span>
    <span class="p">]</span>
    <span class="k">for</span> <span class="n">oc</span> <span class="ow">in</span> <span class="n">opt_rec_cols</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">oc</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">comp_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oc</span><span class="p">)</span>

    <span class="n">comp_cols</span> <span class="o">+=</span> <span class="p">[</span>
        <span class="s1">&#39;recording_from&#39;</span><span class="p">,</span>
        <span class="s1">&#39;comparison&#39;</span>
    <span class="p">]</span>

    <span class="n">odor_cols</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;name1&#39;</span><span class="p">,</span>
        <span class="s1">&#39;name2&#39;</span>
    <span class="p">]</span>

    <span class="n">incomplete_comparison_dfs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">gdf</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">comp_cols</span><span class="p">):</span>
        <span class="n">comp_odor_pairs</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">odor_cols</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_odor_pairs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">incomplete_comparison_dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gdf</span><span class="p">[</span><span class="n">comp_cols</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span>
                <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="c1"># TODO generate expected combinations of name1,name2</span>
        <span class="c1"># TODO possible either odor not in db, in which case, would need extra</span>
        <span class="c1"># information to say which odor is actually missing... (would need</span>
        <span class="c1"># stimulus data)</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        if len(missing_odor_pairs) &gt; 0:</span>
<span class="sd">            gmeta = gdf[comp_cols].drop_duplicates().reset_index(drop=True)</span>

<span class="sd">        for r in missing_odor_pairs:</span>
<span class="sd">            new_row = gmeta.copy()</span>
<span class="sd">            new_row[&#39;repeat_num&#39;] = r</span>
<span class="sd">            missing_odor_pair_dfs.append(new_row)</span>
<span class="sd">        &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">incomplete_comparison_dfs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">incomplete_comparison_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="n">r</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">comp_cols</span><span class="p">})</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">incomplete_comparison_df</span> <span class="o">=</span> \
            <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">incomplete_comparison_dfs</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">incomplete_comparison_df</span><span class="o">.</span><span class="n">recording_from</span> <span class="o">=</span> \
        <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">incomplete_comparison_df</span><span class="o">.</span><span class="n">recording_from</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">incomplete_comparison_df</span></div>


<div class="viewcode-block" id="have_full_comparisons"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.have_full_comparisons">[docs]</a><span class="k">def</span> <span class="nf">have_full_comparisons</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Requires at least recording_from, comparison, name1, name2 columns.</span>
<span class="sd">    Can also take prep_date, fly_num, thorimage_id.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO docstring</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_odor_pairs</span><span class="p">(</span><span class="n">df</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="skipped_comparison_nums"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.skipped_comparison_nums">[docs]</a><span class="k">def</span> <span class="nf">skipped_comparison_nums</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="c1"># TODO doc</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Requires at least recording_from and comparison columns.</span>
<span class="sd">    Can also take prep_date, fly_num, and thorimage_id.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rec_cols</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">opt_rec_cols</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;prep_date&#39;</span><span class="p">,</span>
        <span class="s1">&#39;fly_num&#39;</span><span class="p">,</span>
        <span class="s1">&#39;thorimage_id&#39;</span>
    <span class="p">]</span>
    <span class="k">for</span> <span class="n">oc</span> <span class="ow">in</span> <span class="n">opt_rec_cols</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">oc</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">rec_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oc</span><span class="p">)</span>

    <span class="n">rec_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;recording_from&#39;</span><span class="p">)</span>

    <span class="n">skipped_comparison_dfs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">gdf</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">rec_cols</span><span class="p">):</span>
        <span class="n">max_comp_num</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">comparison</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">min_comp_num</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">comparison</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">skipped_comp_nums</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_comp_num</span><span class="p">,</span> <span class="n">max_comp_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">comparison</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skipped_comp_nums</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">gmeta</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">rec_cols</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">skipped_comp_nums</span><span class="p">:</span>
            <span class="n">new_row</span> <span class="o">=</span> <span class="n">gmeta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_row</span><span class="p">[</span><span class="s1">&#39;comparison&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
            <span class="n">skipped_comparison_dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_row</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skipped_comparison_dfs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">skipped_comparison_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="n">r</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span>
            <span class="n">rec_cols</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;comparison&#39;</span><span class="p">]})</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">skipped_comparison_df</span> <span class="o">=</span> \
            <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">skipped_comparison_dfs</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># TODO move this out of each of these check fns, and put wherever this</span>
    <span class="c1"># columns is generated (in the way that required this cast...)</span>
    <span class="n">skipped_comparison_df</span><span class="o">.</span><span class="n">recording_from</span> <span class="o">=</span> \
        <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">skipped_comparison_df</span><span class="o">.</span><span class="n">recording_from</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">skipped_comparison_df</span></div>


<div class="viewcode-block" id="no_skipped_comparisons"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.no_skipped_comparisons">[docs]</a><span class="k">def</span> <span class="nf">no_skipped_comparisons</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="c1"># TODO doc</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Requires at least recording_from and comparison columns.</span>
<span class="sd">    Can also take prep_date, fly_num, and thorimage_id.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skipped_comparison_nums</span><span class="p">(</span><span class="n">df</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<span class="c1"># TODO also check recording has as many blocks (in df / in db) as it&#39;s supposed</span>
<span class="c1"># to, given what the metadata + gsheet say</span>


<div class="viewcode-block" id="drop_orphaned_presentations"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.drop_orphaned_presentations">[docs]</a><span class="k">def</span> <span class="nf">drop_orphaned_presentations</span><span class="p">():</span>
    <span class="c1"># TODO only stuff that isn&#39;t also most recent response params?</span>
    <span class="c1"># TODO find presentation rows that don&#39;t have response row referring to them</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<span class="c1"># TODO TODO maybe implement check fns above as wrappers around another fn that</span>
<span class="c1"># finds inomplete stuff? (check if len is 0), so that these fns can just wrap</span>
<span class="c1"># the same thing...</span>
<div class="viewcode-block" id="drop_incomplete_presentations"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.drop_incomplete_presentations">[docs]</a><span class="k">def</span> <span class="nf">drop_incomplete_presentations</span><span class="p">():</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="smooth_1d"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.smooth_1d">[docs]</a><span class="k">def</span> <span class="nf">smooth_1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">window_len</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hanning&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;smooth the data using a window with requested size.</span>

<span class="sd">    This method is based on the convolution of a scaled window with the signal.</span>
<span class="sd">    The signal is prepared by introducing reflected copies of the signal</span>
<span class="sd">    (with the window size) in both ends so that transient parts are minimized</span>
<span class="sd">    in the begining and end part of the output signal.</span>

<span class="sd">    input:</span>
<span class="sd">        x: the input signal</span>
<span class="sd">        window_len: the dimension of the smoothing window; should be an odd</span>
<span class="sd">            integer</span>
<span class="sd">        window: the type of window from &#39;flat&#39;, &#39;hanning&#39;, &#39;hamming&#39;,</span>
<span class="sd">            &#39;bartlett&#39;, &#39;blackman&#39; flat window will produce a moving average</span>
<span class="sd">            smoothing.</span>

<span class="sd">    output:</span>
<span class="sd">        the smoothed signal</span>

<span class="sd">    example:</span>

<span class="sd">    t=linspace(-2,2,0.1)</span>
<span class="sd">    x=sin(t)+randn(len(t))*0.1</span>
<span class="sd">    y=smooth_1d(x)</span>

<span class="sd">    see also:</span>

<span class="sd">    numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman, numpy.convolve</span>
<span class="sd">    scipy.signal.lfilter</span>

<span class="sd">    TODO: the window parameter could be the window itself if an array instead of</span>
<span class="sd">    a string</span>
<span class="sd">    NOTE: length(output) != length(input), to correct this: return</span>
<span class="sd">    y[(window_len/2-1):-(window_len/2)] instead of just y.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;smooth_1d only accepts 1 dimension arrays.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">window_len</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input vector needs to be bigger than window size.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">window_len</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">window</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;flat&#39;</span><span class="p">,</span> <span class="s1">&#39;hanning&#39;</span><span class="p">,</span> <span class="s1">&#39;hamming&#39;</span><span class="p">,</span> <span class="s1">&#39;bartlett&#39;</span><span class="p">,</span> <span class="s1">&#39;blackman&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Window is on of &#39;flat&#39;, &#39;hanning&#39;, &quot;</span> <span class="o">+</span>
            <span class="s2">&quot;&#39;hamming&#39;, &#39;bartlett&#39;, &#39;blackman&#39;&quot;</span><span class="p">)</span>

    <span class="c1"># is this necessary?</span>
    <span class="c1">#s = np.r_[x[window_len-1:0:-1],x,x[-2:-window_len-1:-1]]</span>

    <span class="c1">#print(len(s))</span>
    <span class="k">if</span> <span class="n">window</span> <span class="o">==</span> <span class="s1">&#39;flat&#39;</span><span class="p">:</span> <span class="c1">#moving average</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">window_len</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;np.&#39;</span> <span class="o">+</span> <span class="n">window</span> <span class="o">+</span> <span class="s1">&#39;(window_len)&#39;</span><span class="p">)</span>

    <span class="c1">#y = np.convolve(w/w.sum(), s, mode=&#39;valid&#39;)</span>
    <span class="c1"># not sure what to change above to get this to work...</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">x</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span></div>


<span class="c1"># TODO finish translating. was directly translating matlab registration script</span>
<span class="c1"># to python.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">def motion_correct_to_tiffs(image_dir, output_dir):</span>
<span class="sd">    # TODO only read this if at least one motion correction would be run</span>
<span class="sd">    movie = thor.read_movie(image_dir)</span>

<span class="sd">    # TODO do i really want to basically just copy the matlab version?</span>
<span class="sd">    # opportunity for some refactoring?</span>

<span class="sd">    output_subdir = &#39;tif_stacks&#39;</span>

<span class="sd">    _, thorimage_id = split(image_dir)</span>

<span class="sd">    rig_tif = join(output_dir, output_subdir, thorimage_id + &#39;_rig.tif&#39;)</span>
<span class="sd">    avg_rig_tif = join(output_dir, output_subdir, &#39;AVG&#39;, &#39;rigid&#39;,</span>
<span class="sd">        &#39;AVG{}_rig.tif&#39;.format(thorimage_id))</span>

<span class="sd">    nr_tif = join(output_dir, output_subdir, thorimage_id + &#39;_nr.tif&#39;)</span>
<span class="sd">    avg_nr_tif = join(output_dir, output_subdir, &#39;AVG&#39;, &#39;nonrigid&#39;,</span>
<span class="sd">        &#39;AVG{}_nr.tif&#39;.format(thorimage_id))</span>

<span class="sd">    need_rig_tif = not exist(rig_tif)</span>
<span class="sd">    need_avg_rig_tif = not exist(avg_rig_tif)</span>
<span class="sd">    need_nr_tif = not exist(nr_tif)</span>
<span class="sd">    need_avg_nr_tif = not exist(avg_nr_tif)</span>

<span class="sd">    if not (need_rig_tif or need_avg_rig_tif or need_nr_tif or need_avg_nr_tif):</span>
<span class="sd">        print(&#39;All registration already done.&#39;)</span>
<span class="sd">        return</span>

<span class="sd">    # Remy: this seems like it might just be reading in the first frame?</span>
<span class="sd">    ###Y = input_tif_path</span>
<span class="sd">    # TODO maybe can just directly use filename for python version though? raw</span>
<span class="sd">    # even?</span>

<span class="sd">    # rigid moco (normcorre)</span>
<span class="sd">    # TODO just pass filename instead of Y, and compute dimensions or whatever</span>
<span class="sd">    # separately, so that normcorre can (hopefully?) take up less memory</span>
<span class="sd">    if need_rig_tif:</span>
<span class="sd">        MC_rigid = MotionCorrection(Y)</span>

<span class="sd">        options_rigid = NoRMCorreSetParms(&#39;d1&#39;,MC_rigid.dims(1),</span>
<span class="sd">            &#39;d2&#39;,MC_rigid.dims(2),</span>
<span class="sd">            &#39;bin_width&#39;,50,</span>
<span class="sd">            &#39;max_shift&#39;,15,</span>
<span class="sd">            &#39;phase_flag&#39;, 1,</span>
<span class="sd">            &#39;us_fac&#39;, 50,</span>
<span class="sd">            &#39;init_batch&#39;, 100,</span>
<span class="sd">            &#39;plot_flag&#39;, false,</span>
<span class="sd">            &#39;iter&#39;, 2)</span>

<span class="sd">        # TODO so is nothing actually happening in parallel?</span>
<span class="sd">        ## rigid moco</span>
<span class="sd">        MC_rigid.motionCorrectSerial(options_rigid)  # can also try parallel</span>
<span class="sd">        # TODO which (if any) of these do i still want?</span>
<span class="sd">        MC_rigid.computeMean()</span>
<span class="sd">        MC_rigid.correlationMean()</span>
<span class="sd">        #####MC_rigid.crispness()</span>
<span class="sd">        print(&#39;normcorre done&#39;)</span>

<span class="sd">        ## plot shifts</span>
<span class="sd">        #plt.plot(MC_rigid.shifts_x)</span>
<span class="sd">        #plt.plot(MC_rigid.shifts_y)</span>

<span class="sd">        # save .tif</span>
<span class="sd">        M = MC_rigid.M</span>
<span class="sd">        M = uint16(M)</span>
<span class="sd">        tiffoptions.overwrite = true</span>

<span class="sd">        print([&#39;saving tiff to &#39; rig_tif])</span>
<span class="sd">        saveastiff(M, rig_tif, tiffoptions)</span>

<span class="sd">    if need_avg_rig_tif:</span>
<span class="sd">        ##</span>
<span class="sd">        # save average image</span>
<span class="sd">        #AVG = single(mean(MC_rigid.M,3))</span>
<span class="sd">        AVG = single(MC_rigid.template)</span>
<span class="sd">        tiffoptions.overwrite = true</span>

<span class="sd">        print([&#39;saving tiff to &#39; avg_rig_tif])</span>
<span class="sd">        saveastiff(AVG, avg_rig_tif, tiffoptions)</span>

<span class="sd">    if need_nr_tif:</span>
<span class="sd">        MC_nonrigid = MotionCorrection(Y)</span>
<span class="sd">        options_nonrigid = NoRMCorreSetParms(&#39;d1&#39;,MC_nonrigid.dims(1),</span>
<span class="sd">            &#39;d2&#39;,MC_nonrigid.dims(2),</span>
<span class="sd">            &#39;grid_size&#39;,[64,64],</span>
<span class="sd">            &#39;mot_uf&#39;,4,</span>
<span class="sd">            &#39;bin_width&#39;,50,</span>
<span class="sd">            &#39;max_shift&#39;,[15 15],</span>
<span class="sd">            &#39;max_dev&#39;,3,</span>
<span class="sd">            &#39;us_fac&#39;,50,</span>
<span class="sd">            &#39;init_batch&#39;,200,</span>
<span class="sd">            &#39;iter&#39;, 2)</span>

<span class="sd">        MC_nonrigid.motionCorrectParallel(options_nonrigid)</span>
<span class="sd">        MC_nonrigid.computeMean()</span>
<span class="sd">        MC_nonrigid.correlationMean()</span>
<span class="sd">        MC_nonrigid.crispness()</span>
<span class="sd">        print(&#39;non-rigid normcorre done&#39;)</span>

<span class="sd">        # save .tif</span>
<span class="sd">        M = uint16(MC_nonrigid.M)</span>
<span class="sd">        tiffoptions.overwrite  = true</span>
<span class="sd">        print([&#39;saving tiff to &#39; nr_tif])</span>
<span class="sd">        saveastiff(M, nr_tif, tiffoptions)</span>

<span class="sd">    if need_avg_nr_tif:</span>
<span class="sd">        # TODO flag to disable saving this average</span>
<span class="sd">        #AVG = single(mean(MC_nonrigid.M,3))</span>
<span class="sd">        AVG = single(MC_nonrigid.template)</span>
<span class="sd">        tiffoptions.overwrite = true</span>
<span class="sd">        print([&#39;saving tiff to &#39; avg_nr_tif])</span>
<span class="sd">        saveastiff(AVG, avg_nr_tif, tiffoptions)</span>

<span class="sd">    raise NotImplementedError</span>
<span class="sd">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="cell_ids"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.cell_ids">[docs]</a><span class="k">def</span> <span class="nf">cell_ids</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes a DataFrame with &#39;cell&#39; in MultiIndex or columns to unique values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s1">&#39;cell&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">to_series</span><span class="p">()</span>
    <span class="k">elif</span> <span class="s1">&#39;cell&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">cids</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;cell&#39;</span><span class="p">)</span>
        <span class="n">cids</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;cell&#39;</span>
        <span class="k">return</span> <span class="n">cids</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;cell&#39; not in index or columns of DataFrame&quot;</span><span class="p">)</span></div>


<span class="c1"># TODO move to olf / delete</span>
<div class="viewcode-block" id="format_odor_conc"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.format_odor_conc">[docs]</a><span class="k">def</span> <span class="nf">format_odor_conc</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">log10_conc</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes `str` odor name and log10 concentration to a formatted `str`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">log10_conc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">name</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># TODO tex formatting for exponent</span>
        <span class="c1">#return r&#39;{} @ $10^{{&#39;.format(name) + &#39;{:.2f}}}$&#39;.format(log10_conc)</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> @ $10^{{</span><span class="si">{:.2f}</span><span class="s1">}}$&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">log10_conc</span><span class="p">)</span></div>


<span class="c1"># TODO move to olf / delete</span>
<div class="viewcode-block" id="format_mixture"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.format_mixture">[docs]</a><span class="k">def</span> <span class="nf">format_mixture</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns `str` representing 2-component odor mixture.</span>

<span class="sd">    Input can be any of:</span>
<span class="sd">    - 2 `str` names</span>
<span class="sd">    - 2 names and concs (n1, n2, c1, c2)</span>
<span class="sd">    - a pandas.Series / dict with keys `name1`, `name2`, and (optionally)</span>
<span class="sd">      `log10_concvv&lt;1/2&gt;`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">log10_c1</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">log10_c2</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">args</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">log10_c1</span><span class="p">,</span> <span class="n">log10_c2</span> <span class="o">=</span> <span class="n">args</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># TODO maybe refactor to use this fn in viz.plot_odor_corrs fn too</span>
        <span class="k">def</span> <span class="nf">single_var_with_prefix</span><span class="p">(</span><span class="n">prefix</span><span class="p">):</span>
            <span class="n">single_var</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">row</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">single_var</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;multiple vars w/ prefix </span><span class="si">{prefix}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">single_var</span> <span class="o">=</span> <span class="n">v</span>

            <span class="k">if</span> <span class="n">single_var</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;no vars w/ prefix </span><span class="si">{prefix}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">single_var</span>
        <span class="c1">#</span>

        <span class="n">n1</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">single_var_with_prefix</span><span class="p">(</span><span class="s1">&#39;name1&#39;</span><span class="p">)]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">single_var_with_prefix</span><span class="p">(</span><span class="s1">&#39;name2&#39;</span><span class="p">)]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># TODO maybe also use prefix fn here?</span>
        <span class="k">if</span> <span class="s1">&#39;log10_conc_vv1&#39;</span> <span class="ow">in</span> <span class="n">row</span><span class="p">:</span>
            <span class="n">log10_c1</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;log10_conc_vv1&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">n2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">log10_c2</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;log10_conc_vv2&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;incorrect number of args&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n1</span> <span class="o">==</span> <span class="s1">&#39;paraffin&#39;</span><span class="p">:</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">format_odor_conc</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">log10_c2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">n2</span> <span class="o">==</span> <span class="s1">&#39;paraffin&#39;</span> <span class="ow">or</span> <span class="n">n2</span> <span class="o">==</span> <span class="s1">&#39;no_second_odor&#39;</span> <span class="ow">or</span> <span class="n">n2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">format_odor_conc</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">log10_c1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> + </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">format_odor_conc</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">log10_c1</span><span class="p">),</span>
            <span class="n">format_odor_conc</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">log10_c2</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">title</span></div>


<span class="c1"># TODO move to olf / delete</span>
<div class="viewcode-block" id="split_odor_w_conc"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.split_odor_w_conc">[docs]</a><span class="k">def</span> <span class="nf">split_odor_w_conc</span><span class="p">(</span><span class="n">row_or_str</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">odor_w_conc</span> <span class="o">=</span> <span class="n">row_or_str</span><span class="o">.</span><span class="n">odor_w_conc</span>
        <span class="n">include_other_row_data</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">row_or_str</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span>
        <span class="n">odor_w_conc</span> <span class="o">=</span> <span class="n">row_or_str</span>
        <span class="n">include_other_row_data</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">parts</span> <span class="o">=</span> <span class="n">odor_w_conc</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;@&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">log10_conc</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">log10_conc</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="s1">&#39;log10_conc_vv&#39;</span><span class="p">:</span> <span class="n">log10_conc</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">include_other_row_data</span><span class="p">:</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">row_or_str</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>

    <span class="c1"># TODO maybe only return series if include_other_row_data (rename if),</span>
    <span class="c1"># tuple/dict otherwise?</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>


<div class="viewcode-block" id="format_keys"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.format_keys">[docs]</a><span class="k">def</span> <span class="nf">format_keys</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly</span><span class="p">,</span> <span class="o">*</span><span class="n">other_keys</span><span class="p">):</span>
    <span class="n">date</span> <span class="o">=</span> <span class="n">format_date</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
    <span class="n">fly</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">fly</span><span class="p">))</span>
    <span class="n">others</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">other_keys</span><span class="p">]</span>
    <span class="k">return</span> <span class="s1">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">date</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">fly</span><span class="p">]</span> <span class="o">+</span> <span class="n">others</span><span class="p">)</span></div>


<span class="c1"># TODO rename to be inclusive of cases other than pairs</span>
<div class="viewcode-block" id="pair_ordering"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.pair_ordering">[docs]</a><span class="k">def</span> <span class="nf">pair_ordering</span><span class="p">(</span><span class="n">comparison_df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes a df w/ name1 &amp; name2 to a dict of their tuples to order int.</span>

<span class="sd">    Order integers start at 0 and do not skip any numbers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO maybe assert only 3 combinations of name1/name2</span>
    <span class="n">pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="o">.</span><span class="n">name1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">name2</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span>
        <span class="n">comparison_df</span><span class="p">[[</span><span class="s1">&#39;name1&#39;</span><span class="p">,</span><span class="s1">&#39;name2&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">itertuples</span><span class="p">()]</span>

    <span class="c1"># Will define the order in which odor pairs will appear, left-to-right,</span>
    <span class="c1"># in subplots.</span>
    <span class="n">ordering</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="c1"># TODO maybe check that it&#39;s the second element specifically, since right</span>
    <span class="c1"># now, it&#39;s only cause paraffin is abbreviated to pfo (for name1 col)</span>
    <span class="c1"># that complex-mixture experiments go into first branch...</span>
    <span class="n">has_paraffin</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pairs</span> <span class="k">if</span> <span class="s1">&#39;paraffin&#39;</span> <span class="ow">in</span> <span class="n">p</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">has_paraffin</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">chemutils</span> <span class="k">as</span> <span class="nn">cu</span>
        <span class="k">assert</span> <span class="p">{</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">}</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;no_second_odor&#39;</span><span class="p">}</span>
        <span class="n">odors</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">]</span>

        <span class="c1"># TODO change how odorset is identified so it can fail if none should be</span>
        <span class="c1"># detected / return None or something, then call back to just sorting</span>
        <span class="c1"># the odor names here, if no odor set name can be identified</span>
        <span class="c1"># (do we also want to support some case where original_name1 is defined</span>
        <span class="c1"># but the odorset name isn&#39;t necessarily?)</span>
        <span class="k">if</span> <span class="s1">&#39;original_name1&#39;</span> <span class="ow">in</span> <span class="n">comparison_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">original_name_order</span> <span class="o">=</span> <span class="n">df_to_odor_order</span><span class="p">(</span><span class="n">comparison_df</span><span class="p">)</span>
            <span class="n">o2n</span> <span class="o">=</span> <span class="n">comparison_df</span><span class="p">[[</span><span class="s1">&#39;original_name1&#39;</span><span class="p">,</span><span class="s1">&#39;name1&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span>
                <span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;original_name1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">name1</span>
            <span class="c1"># TODO maybe don&#39;t assume &#39;no_second_odor&#39; like this (&amp; below)?</span>
            <span class="n">ordering</span> <span class="o">=</span> <span class="p">{(</span><span class="n">v</span><span class="p">,</span> <span class="s1">&#39;no_second_odor&#39;</span><span class="p">):</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
                <span class="nb">enumerate</span><span class="p">(</span><span class="n">o2n</span><span class="p">[</span><span class="n">original_name_order</span><span class="p">])}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO also support case where there isn&#39;t something we want to</span>
            <span class="c1"># stick at the end like this, for Matt&#39;s case</span>
            <span class="n">last</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">odors</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cu</span><span class="o">.</span><span class="n">odor_is_mix</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">last</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">last</span> <span class="o">=</span> <span class="n">o</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;multiple mixtures in odors to order&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">last</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;expected a mix&#39;</span>
            <span class="n">ordering</span><span class="p">[(</span><span class="n">last</span><span class="p">,</span> <span class="s1">&#39;no_second_odor&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">odors</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">odors</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">o</span> <span class="o">==</span> <span class="n">last</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">ordering</span><span class="p">[(</span><span class="n">o</span><span class="p">,</span> <span class="s1">&#39;no_second_odor&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">no_pfo</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pairs</span> <span class="k">if</span> <span class="s1">&#39;paraffin&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">p</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">no_pfo</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All pairs for this comparison had paraffin.&#39;</span> <span class="o">+</span>
                <span class="s1">&#39; Analysis error? Incomplete recording?&#39;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">no_pfo</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">no_pfo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ordering</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">has_paraffin</span><span class="p">,</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;paraffin&#39;</span> <span class="k">else</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>

            <span class="n">ordering</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

    <span class="c1"># Checks that we order integers start at zero and don&#39;t skip anything.</span>
    <span class="c1"># Important for some ways of using them (e.g. to index axes array).</span>
    <span class="k">assert</span> <span class="p">{</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ordering</span><span class="o">.</span><span class="n">values</span><span class="p">()}</span> <span class="o">==</span> <span class="p">{</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ordering</span><span class="p">))}</span>

    <span class="k">return</span> <span class="n">ordering</span></div>


<span class="c1"># TODO TODO call this in gui / factor into viz.plot_odor_corrs (though it would</span>
<span class="c1"># require accesss to df...) and call that there</span>
<div class="viewcode-block" id="add_missing_odor_cols"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.add_missing_odor_cols">[docs]</a><span class="k">def</span> <span class="nf">add_missing_odor_cols</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">missing_df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO maybe check cols are indeed describing odors in missing_df?</span>

    <span class="c1"># TODO delete / change note to be relevant here. copied from original</span>
    <span class="c1"># implementation in gui</span>
    <span class="c1"># This + pivot_table w/ dropna=False won&#39;t work until this bug:</span>
    <span class="c1"># https://github.com/pandas-dev/pandas/issues/18030 is fixed.</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    window_trial_means = pd.concat([window_trial_means,</span>
<span class="sd">        missing_dff.set_index(window_trial_means.index.names</span>
<span class="sd">        ).df_over_f</span>
<span class="sd">    ])</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">missing_dff</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">df_over_f</span><span class="o">.</span><span class="n">isnull</span><span class="p">()][</span>
        <span class="n">missing_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">names</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="s1">&#39;df_over_f&#39;</span><span class="p">]</span>
    <span class="p">]</span>
    <span class="c1"># Hack to workaround pivot NaN behavior bug mentioned above.</span>
    <span class="k">assert</span> <span class="n">missing_dff</span><span class="o">.</span><span class="n">df_over_f</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="n">missing_dff</span><span class="o">.</span><span class="n">df_over_f</span> <span class="o">=</span> <span class="n">missing_dff</span><span class="o">.</span><span class="n">df_over_f</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">extra_cols</span> <span class="o">=</span> <span class="n">missing_dff</span><span class="o">.</span><span class="n">pivot_table</span><span class="p">(</span>
        <span class="n">index</span><span class="o">=</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="s1">&#39;df_over_f&#39;</span><span class="p">,</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name1&#39;</span><span class="p">,</span><span class="s1">&#39;name2&#39;</span><span class="p">,</span><span class="s1">&#39;repeat_num&#39;</span><span class="p">,</span><span class="s1">&#39;order&#39;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">extra_cols</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">missing_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">())</span> <span class="o">==</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">missing_df</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>

    <span class="n">missing_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">missing_df</span><span class="p">,</span> <span class="n">extra_cols</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">missing_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">())</span> <span class="o">==</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">missing_df</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>

    <span class="n">missing_df</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># end of the hack to workaround pivot NaN behavior</span>

    <span class="k">return</span> <span class="n">missing_df</span></div>


<span class="c1"># TODO test when ax actually is passed in now that I made it a kwarg</span>
<span class="c1"># (also works as optional positional arg, right?)</span>
<span class="c1"># TODO rename to be agnostic to fact mpl is used to implement it + to be more</span>
<span class="c1"># descriptive of function</span>
<div class="viewcode-block" id="closed_mpl_contours"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.closed_mpl_contours">[docs]</a><span class="k">def</span> <span class="nf">closed_mpl_contours</span><span class="p">(</span><span class="n">footprint</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">if_multiple</span><span class="o">=</span><span class="s1">&#39;err&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># TODO doc / delete</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        if_multiple (str): &#39;take_largest&#39;|&#39;join&#39;|&#39;err&#39;</span>
<span class="sd">        **kwargs: passed through to matplotlib `ax.contour` call</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="n">footprint</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">padded_footprint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">))</span>
    <span class="n">padded_footprint</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">)]</span> <span class="o">=</span> <span class="n">footprint</span>

    <span class="c1"># TODO delete</span>
    <span class="c1">#fig = plt.figure()</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

    <span class="n">mpl_contour</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">padded_footprint</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># TODO which of these is actually &gt; 1 in multiple comps case?</span>
    <span class="c1"># handle that one approp w/ err_on_multiple_comps!</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">mpl_contour</span><span class="o">.</span><span class="n">collections</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="n">paths</span> <span class="o">=</span> <span class="n">mpl_contour</span><span class="o">.</span><span class="n">collections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_paths</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">if_multiple</span> <span class="o">==</span> <span class="s1">&#39;err&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;multiple disconnected paths in one footprint&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">if_multiple</span> <span class="o">==</span> <span class="s1">&#39;take_largest&#39;</span><span class="p">:</span>
            <span class="n">largest_sum</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">largest_idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">total_sum</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">)):</span>
                <span class="n">path</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>

                <span class="c1"># TODO TODO TODO maybe replace mpl stuff w/ cv2 drawContours?</span>
                <span class="c1"># (or related...) (fn now in here as contour2mask)</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">footprint</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">footprint</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                    <span class="c1"># TODO TODO not sure why this seems to be transposed, but it</span>
                    <span class="c1"># does (make sure i&#39;m not doing something wrong?)</span>
                    <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">contains_point</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)):</span>
                        <span class="n">mask</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1"># Places where the mask is False are included in the sum.</span>
                <span class="n">path_sum</span> <span class="o">=</span> <span class="n">MaskedArray</span><span class="p">(</span><span class="n">footprint</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="c1"># TODO maybe check that sum of all path_sums == footprint.sum()?</span>
                <span class="c1"># seemed there were some paths w/ 0 sum... cnmf err?</span>
                <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">                print(&#39;mask_sum:&#39;, (~ mask).sum())</span>
<span class="sd">                print(&#39;path_sum:&#39;, path_sum)</span>
<span class="sd">                print(&#39;regularly masked sum:&#39;, footprint[(~ mask)].sum())</span>
<span class="sd">                plt.figure()</span>
<span class="sd">                plt.imshow(mask)</span>
<span class="sd">                plt.figure()</span>
<span class="sd">                plt.imshow(footprint)</span>
<span class="sd">                plt.show()</span>
<span class="sd">                import ipdb; ipdb.set_trace()</span>
<span class="sd">                &#39;&#39;&#39;</span>
                <span class="k">if</span> <span class="n">path_sum</span> <span class="o">&gt;</span> <span class="n">largest_sum</span><span class="p">:</span>
                    <span class="n">largest_sum</span> <span class="o">=</span> <span class="n">path_sum</span>
                    <span class="n">largest_idx</span> <span class="o">=</span> <span class="n">p</span>

                <span class="n">total_sum</span> <span class="o">+=</span> <span class="n">path_sum</span>
            <span class="n">footprint_sum</span> <span class="o">=</span> <span class="n">footprint</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="c1"># TODO float formatting / some explanation as to what this is</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;footprint_sum:&#39;</span><span class="p">,</span> <span class="n">footprint_sum</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;total_sum:&#39;</span><span class="p">,</span> <span class="n">total_sum</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;largest_sum:&#39;</span><span class="p">,</span> <span class="n">largest_sum</span><span class="p">)</span>
            <span class="c1"># TODO is this only failing when stuff is overlapping?</span>
            <span class="c1"># just merge in that case? (wouldn&#39;t even need to dilate or</span>
            <span class="c1"># anything...) (though i guess then the inequality would go the</span>
            <span class="c1"># other way... is it border pixels? just ~dilate by one?)</span>
            <span class="c1"># TODO fix + uncomment</span>
            <span class="c1">######assert np.isclose(total_sum, footprint_sum)</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="n">largest_idx</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">if_multiple</span> <span class="o">==</span> <span class="s1">&#39;join&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># TODO delete</span>
    <span class="c1">#plt.close(fig)</span>
    <span class="c1">#</span>

    <span class="n">contour</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">vertices</span>
    <span class="c1"># Correct index change caused by padding.</span>
    <span class="k">return</span> <span class="n">contour</span> <span class="o">-</span> <span class="mi">1</span></div>


<span class="c1"># TODO worth having min/max as inputs, so that maybe can use vals from</span>
<span class="c1"># either scene or template for the other? i guess point of baselining</span>
<span class="c1"># is to avoid need for stuff like that...</span>
<div class="viewcode-block" id="baselined_normed_u8"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.baselined_normed_u8">[docs]</a><span class="k">def</span> <span class="nf">baselined_normed_u8</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
    <span class="n">u8_max</span> <span class="o">=</span> <span class="mi">255</span>
    <span class="c1"># TODO maybe convert to float64 or something first before some operations,</span>
    <span class="c1"># to minimize rounding errs?</span>
    <span class="n">baselined</span> <span class="o">=</span> <span class="n">img</span> <span class="o">-</span> <span class="n">img</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="n">normed</span> <span class="o">=</span> <span class="n">baselined</span> <span class="o">/</span> <span class="n">baselined</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">u8_max</span> <span class="o">*</span> <span class="n">normed</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span></div>


<span class="c1"># TODO refactor this behind a color=True kwarg baselined_normed_u8 above?</span>
<div class="viewcode-block" id="u8_color"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.u8_color">[docs]</a><span class="k">def</span> <span class="nf">u8_color</span><span class="p">(</span><span class="n">draw_on</span><span class="p">):</span>
    <span class="c1"># TODO figure out why background looks lighter here than in other</span>
    <span class="c1"># imshows of same input (w/o converting manually)</span>
    <span class="n">draw_on</span> <span class="o">=</span> <span class="n">draw_on</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">draw_on</span><span class="p">)</span>
    <span class="n">draw_on</span> <span class="o">=</span> <span class="n">draw_on</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">draw_on</span><span class="p">)</span>
    <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span> <span class="c1">#, lut=256)</span>
    <span class="c1"># (throwing away alpha coord w/ last slice)</span>
    <span class="n">draw_on</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="n">cmap</span><span class="p">(</span><span class="n">draw_on</span><span class="p">)[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="mi">255</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">draw_on</span></div>


<div class="viewcode-block" id="template_match"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.template_match">[docs]</a><span class="k">def</span> <span class="nf">template_match</span><span class="p">(</span><span class="n">scene</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">method_str</span><span class="o">=</span><span class="s1">&#39;cv2.TM_CCOEFF&#39;</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="kn">import</span> <span class="nn">cv2</span>

    <span class="n">vscaled_scene</span> <span class="o">=</span> <span class="n">baselined_normed_u8</span><span class="p">(</span><span class="n">scene</span><span class="p">)</span>
    <span class="c1"># TODO TODO maybe template should only be scaled to it&#39;s usual fraction of</span>
    <span class="c1"># max of the scene? like scaled both wrt orig_scene.max() / max across all</span>
    <span class="c1"># images?</span>
    <span class="n">vscaled_template</span> <span class="o">=</span> <span class="n">baselined_normed_u8</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="c1"># To check how much conversion to u8 (necessary for cv2 template</span>
        <span class="c1"># matching) has reduced the number of pixel levels.</span>
        <span class="n">scene_levels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">scene</span><span class="o">.</span><span class="n">flat</span><span class="p">))</span>
        <span class="n">vs_scene_levels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">vscaled_scene</span><span class="o">.</span><span class="n">flat</span><span class="p">))</span>
        <span class="n">template_levels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">flat</span><span class="p">))</span>
        <span class="n">vs_template_levels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">vscaled_template</span><span class="o">.</span><span class="n">flat</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Number of scene levels BEFORE scaling: </span><span class="si">{scene_levels}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Number of scene levels AFTER scaling: </span><span class="si">{vs_scene_levels}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Number of template levels BEFORE scaling: </span><span class="si">{template_levels}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Number of template levels AFTER scaling: </span><span class="si">{vs_template_levels}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># So you can see that the relative dimensions and scales of each of</span>
        <span class="c1"># these seems reasonable.</span>
        <span class="k">def</span> <span class="nf">compare_template_and_scene</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">scene</span><span class="p">,</span> <span class="n">suptitle</span><span class="p">,</span>
            <span class="n">same_scale</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

            <span class="n">smin</span> <span class="o">=</span> <span class="n">scene</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">smax</span> <span class="o">=</span> <span class="n">scene</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">tmin</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">tmax</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="si">{suptitle}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;scene shape:&#39;</span><span class="p">,</span> <span class="n">scene</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;template shape:&#39;</span><span class="p">,</span> <span class="n">template</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;scene min:&#39;</span><span class="p">,</span> <span class="n">smin</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;scene max:&#39;</span><span class="p">,</span> <span class="n">smax</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;template min:&#39;</span><span class="p">,</span> <span class="n">tmin</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;template max:&#39;</span><span class="p">,</span> <span class="n">tmax</span><span class="p">)</span>

            <span class="c1"># Default, for this fig at least seemed to be (6.4, 4.8)</span>
            <span class="c1"># This has the same aspect ratio.</span>
            <span class="n">fh</span> <span class="o">=</span> <span class="mi">10</span>
            <span class="n">fw</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">fh</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">ncols</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">fw</span><span class="p">,</span> <span class="n">fh</span><span class="p">))</span>

            <span class="n">xlim</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">scene</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">template</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ylim</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">scene</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">template</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">same_scale</span><span class="p">:</span>
                <span class="n">vmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">smin</span><span class="p">,</span> <span class="n">tmin</span><span class="p">)</span>
                <span class="n">vmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">smax</span><span class="p">,</span> <span class="n">tmax</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vmin</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">vmax</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sim</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">scene</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;scene&#39;</span><span class="p">)</span>

            <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">tim</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;template (real scale)&#39;</span><span class="p">)</span>

            <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">btim</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;template (blown up)&#39;</span><span class="p">)</span>

            <span class="c1"># https://stackoverflow.com/questions/31006971</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">axs</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="n">xlim</span><span class="p">,</span> <span class="n">ylim</span><span class="o">=</span><span class="n">ylim</span><span class="p">)</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">template</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">template</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

            <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">suptitle</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">same_scale</span><span class="p">:</span>
                <span class="c1"># l, b, w, h</span>
                <span class="n">cax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.85</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">])</span>
                <span class="n">cb</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
                <span class="n">cb</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">&#39;shared&#39;</span><span class="p">)</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">right</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># l, b, w, h</span>
                <span class="n">cax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.025</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">])</span>
                <span class="n">cb1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax1</span><span class="p">)</span>
                <span class="n">cb1</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">&#39;scene&#39;</span><span class="p">)</span>

                <span class="n">cax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.85</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.025</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">])</span>
                <span class="n">cb2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">tim</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax2</span><span class="p">)</span>
                <span class="n">cb2</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">&#39;template&#39;</span><span class="p">)</span>

                <span class="n">fig</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">right</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

            <span class="n">bins</span> <span class="o">=</span> <span class="mi">50</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">same_scale</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">shistvs</span><span class="p">,</span> <span class="n">sbins</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">scene</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;scene&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency (a.u.)&#39;</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">thitvs</span><span class="p">,</span> <span class="n">tbins</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;template&#39;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{suptitle}</span><span class="se">\n</span><span class="s1">pixel value distributions (</span><span class="si">{bins}</span><span class="s1"> bins)&#39;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">top</span><span class="o">=</span><span class="mf">0.85</span><span class="p">)</span>

        <span class="n">compare_template_and_scene</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">scene</span><span class="p">,</span> <span class="s1">&#39;original&#39;</span><span class="p">,</span>
            <span class="n">same_scale</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">compare_template_and_scene</span><span class="p">(</span><span class="n">vscaled_template</span><span class="p">,</span> <span class="n">vscaled_scene</span><span class="p">,</span>
            <span class="s1">&#39;baselined + scaled&#39;</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">method</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">method_str</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">matchTemplate</span><span class="p">(</span><span class="n">vscaled_scene</span><span class="p">,</span> <span class="n">vscaled_template</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

    <span class="c1"># b/c for sqdiff[_normed], find minima. for others, maxima.</span>
    <span class="k">if</span> <span class="s1">&#39;SQDIFF&#39;</span> <span class="ow">in</span> <span class="n">method_str</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">if</span> <span class="n">hist</span><span class="p">:</span>
        <span class="n">fh</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Matching output values (</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method_str</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="euclidean_dist"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.euclidean_dist">[docs]</a><span class="k">def</span> <span class="nf">euclidean_dist</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
    <span class="c1"># Without the conversions to float 64 (or at least something else signed),</span>
    <span class="c1"># uint inputs lead to wraparound -&gt; big distances occasionally.</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">-</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="p">)</span></div>


<span class="c1"># TODO TODO TODO try updating to take max of two diff match images,</span>
<span class="c1"># created w/ different template scales (try a smaller one + existing),</span>
<span class="c1"># and pack appropriate size at each maxima.</span>
<span class="c1"># TODO make sure match criteria is comparable across scales (one threshold</span>
<span class="c1"># ideally) (possible? using one of normalized metrics sufficient? test this</span>
<span class="c1"># on fake test data?)</span>
<div class="viewcode-block" id="greedy_roi_packing"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.greedy_roi_packing">[docs]</a><span class="k">def</span> <span class="nf">greedy_roi_packing</span><span class="p">(</span><span class="n">match_images</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">radii_px</span><span class="p">,</span> <span class="n">thresholds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">exclusion_radius_frac</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">min_dist2neighbor_px</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">min_neighbors</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">exclusion_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">draw_on</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">draw_bboxes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">draw_circles</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">draw_nums</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">multiscale_strategy</span><span class="o">=</span><span class="s1">&#39;one_order&#39;</span><span class="p">,</span> <span class="n">match_value_weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">radii_px_ps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">subpixel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">_src_img_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">_show_match_images</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">_show_packing_constraints</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">_show_fit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">_initial_single_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">    match_images (np.ndarray / iterable of same): 2-dimensional array of match</span>
<span class="sd">    value higher means better match of that point to template.</span>

<span class="sd">        Shape is determined by the number of possible offsets of the template in</span>
<span class="sd">        the original image, so it is smaller than the original image in each</span>
<span class="sd">        dimension. As an example, for a 3x3 image and a 2x2 template, the</span>
<span class="sd">        template can occupy 4 possible positions in the 3x3 image, and the match</span>
<span class="sd">        image will be 2x2.</span>

<span class="sd">    ds (int / iterable of same): integer width (and height) of square template.</span>
<span class="sd">        related to radius, but differ by margin set outside.</span>

<span class="sd">    radii_px (int / iterable of same): radius of cell in pixels.</span>

<span class="sd">    exclusion_radius_frac (float): approximately 1 - the fraction of two ROI</span>
<span class="sd">        radii that are allowed to overlap.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO move drawing fns for debug to mpl and remove this if not gonna</span>
    <span class="c1"># use for constraints here</span>
    <span class="kn">import</span> <span class="nn">cv2</span>
    <span class="c1">#</span>
    <span class="c1"># Use of either this or KDTree seem to cause pytest ufunc size changed</span>
    <span class="c1"># warning (w/ pytest at least), though it should be harmless.</span>
    <span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="k">import</span> <span class="n">cKDTree</span>

    <span class="k">if</span> <span class="n">subpixel</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">if</span> <span class="n">thresholds</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;specify either thresholds or ns&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">ns</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">thresholds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span>
            <span class="p">(</span><span class="n">ns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">thresholds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;only specify either thresholds or ns&#39;</span><span class="p">)</span>

    <span class="c1"># For multiscale matching, we require (at lesat) multiple radii, so we test</span>
    <span class="c1"># whether it is iterable to determine if we should be using multiscale</span>
    <span class="c1"># matching.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">iter</span><span class="p">(</span><span class="n">radii_px</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">radii_px</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">multiscale</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ds</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">radii_px</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">radii_px</span><span class="p">)</span>
            <span class="n">multiscale</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">multiscale</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># also check most other things are NOT iterable in this case?</span>

        <span class="n">match_images</span> <span class="o">=</span> <span class="p">[</span><span class="n">match_images</span><span class="p">]</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="p">[</span><span class="n">ds</span><span class="p">]</span>
        <span class="n">radii_px</span> <span class="o">=</span> <span class="p">[</span><span class="n">radii_px</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">ns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">total_n</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># TODO maybe delete this test and force thresholds (if-specified)</span>
        <span class="c1"># to have same length. useless if one threshold is never gonna work.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">thresholds</span><span class="p">)</span>
            <span class="c1"># If we have multiple thresholds, we must have as many</span>
            <span class="c1"># as the things above.</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">thresholds</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">radii_px</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">thresholds</span> <span class="o">=</span> <span class="p">[</span><span class="n">thresholds</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">radii_px</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">thresholds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span>
            <span class="c1"># TODO want this behavior ever? maybe delete try/except...</span>
            <span class="c1"># Here, we are specify how many of each size we are looking for.</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">radii_px</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">total_n</span> <span class="o">=</span> <span class="n">ns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ns</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">total_n</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># Here, we specify a target number of cells of any size to find.</span>
            <span class="n">total_n</span> <span class="o">=</span> <span class="n">ns</span>
            <span class="n">ns</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">multiscale</span><span class="p">:</span>
        <span class="n">n_scales</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">radii_px</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_images</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_scales</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_scales</span>

        <span class="k">if</span> <span class="n">multiscale_strategy</span> <span class="o">!=</span> <span class="s1">&#39;one_order&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">match_value_weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;match_value_weights are only &#39;</span>
                <span class="s2">&quot;meaningful in multiscale_strategy=&#39;one_order&#39; case, because &quot;</span>
                <span class="s1">&#39;they do not change match ordering within a single match scale.&#39;</span>
                <span class="s1">&#39; They only help make one ordering across matching scales.&#39;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">multiscale_strategy</span> <span class="o">!=</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">radii_px_ps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;radii_px_ps is only meaningful in &#39;</span>
                <span class="s2">&quot;multiscale_strategy=&#39;random&#39; case&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">multiscale_strategy</span> <span class="o">!=</span> <span class="s1">&#39;fixed_scale_order&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">scale_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;scale_order is only meaningful in &#39;</span>
                <span class="s2">&quot;multiscale_strategy=&#39;fixed_scale_order&#39; case&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">multiscale_strategy</span> <span class="o">==</span> <span class="s1">&#39;one_order&#39;</span><span class="p">:</span>
            <span class="c1"># Can still be None here, that just implies that match values</span>
            <span class="c1"># at different scales will be sorted into one order with no</span>
            <span class="c1"># weighting.</span>
            <span class="k">if</span> <span class="n">match_value_weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_value_weights</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_scales</span>

            <span class="c1"># could also accept callable for each element, if a fn (rather than</span>
            <span class="c1"># linear scalar) would be more useful to make match values</span>
            <span class="c1"># comparable across scales (test for it later, at time-to-use)</span>

        <span class="k">elif</span> <span class="n">multiscale_strategy</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">radii_px_ps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">radii_px_ps</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="n">r</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">radii_px_ps</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">r</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">radii_px_ps</span><span class="p">]):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Some elements of radii_px_ps were 0 or 1. &#39;</span>
                    <span class="s2">&quot;This means using multiscale_strategy=&#39;random&#39; may not make&quot;</span>
                    <span class="s1">&#39; sense.&#39;</span>
                <span class="p">)</span>

        <span class="k">elif</span> <span class="n">multiscale_strategy</span> <span class="o">==</span> <span class="s1">&#39;fixed_scale_order&#39;</span><span class="p">:</span>
            <span class="c1"># could just take elements from other iterables in order passed</span>
            <span class="c1"># in... just erring on side of being explicit</span>
            <span class="k">assert</span> <span class="n">scale_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">scale_order</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">scale_order</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">scale_order</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">radii_px</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;scale_order had elements not usable to &#39;</span>
                        <span class="s1">&#39;index scales&#39;</span>
                    <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;multiscale_strategy </span><span class="si">{multiscale_strategy}</span><span class="s1"> not &#39;</span>
                <span class="s1">&#39;recognized&#39;</span>
            <span class="p">)</span>

        <span class="c1"># Can not assert all match_images have the same shape, because d</span>
        <span class="c1"># affects shape of match image (as you can see from line inverting</span>
        <span class="c1"># this dependence to calculate orig_shape, below)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_scales</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">match_value_weights</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="n">radii_px_ps</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="n">scale_order</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="c1"># somewhat tautological. could delete.</span>
        <span class="k">if</span> <span class="n">thresholds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">total_n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="c1"># TODO optimal non-greedy alg for this problem? (maximize weight of</span>
    <span class="c1"># match_image summed across all assigned ROIs)</span>

    <span class="c1"># TODO do away with this copying if not necessary</span>
    <span class="c1"># (just don&#39;t want to mutate inputs without being clear about it)</span>
    <span class="c1"># (multiplication by match_value_weights below)</span>
    <span class="n">match_images</span> <span class="o">=</span> <span class="p">[</span><span class="n">mi</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">mi</span> <span class="ow">in</span> <span class="n">match_images</span><span class="p">]</span>
    <span class="n">orig_shapes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">match_image</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">match_images</span><span class="p">,</span> <span class="n">ds</span><span class="p">):</span>
        <span class="c1"># Working through example w/ 3x3 src img and 2x2 template -&gt; 2x2 match</span>
        <span class="c1"># image in docstring indicates necessity for - 1 here.</span>
        <span class="n">orig_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">match_image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">orig_shapes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">orig_shape</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">orig_shapes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">orig_shape</span> <span class="o">=</span> <span class="n">orig_shapes</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">_src_img_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">orig_shape</span> <span class="o">==</span> <span class="n">_src_img_shape</span>
        <span class="k">del</span> <span class="n">_src_img_shape</span>

    <span class="k">if</span> <span class="n">draw_on</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># if this fails, just fix shape comparison in next assertion and</span>
        <span class="c1"># then delete this assert</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">draw_on</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">assert</span> <span class="n">draw_on</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">orig_shape</span>

        <span class="n">draw_on</span> <span class="o">=</span> <span class="n">u8_color</span><span class="p">(</span><span class="n">draw_on</span><span class="p">)</span>
        <span class="c1"># upsampling just so cv2 drawing functions look better</span>
        <span class="n">ups</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="n">draw_on</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">draw_on</span><span class="p">,</span>
            <span class="nb">tuple</span><span class="p">([</span><span class="n">ups</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">draw_on</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]])</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">match_value_weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">match_value_weights</span><span class="p">):</span>
            <span class="n">match_images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">match_images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span>

    <span class="k">if</span> <span class="n">debug</span> <span class="ow">and</span> <span class="n">_show_match_images</span><span class="p">:</span>
        <span class="c1"># wanted these as subplots w/ colorbar besides each, but colorbars</span>
        <span class="c1"># seemed to want to go to the side w/ the simplest attempt</span>
        <span class="n">ncols</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">nrows</span> <span class="o">=</span> <span class="n">n_scales</span> <span class="o">%</span> <span class="n">ncols</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">ncols</span><span class="o">=</span><span class="n">ncols</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">nrows</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">multiscale</span> <span class="ow">or</span> <span class="n">multiscale_strategy</span> <span class="o">==</span> <span class="s1">&#39;one_order&#39;</span><span class="p">:</span>
            <span class="n">vmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">mi</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="k">for</span> <span class="n">mi</span> <span class="ow">in</span> <span class="n">match_images</span><span class="p">])</span>
            <span class="n">vmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">mi</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">for</span> <span class="n">mi</span> <span class="ow">in</span> <span class="n">match_images</span><span class="p">])</span>
            <span class="n">same_scale</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vmin</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">vmax</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">same_scale</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">match_image</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span>
            <span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">match_images</span><span class="p">)):</span>

            <span class="n">to_show</span> <span class="o">=</span> <span class="n">match_image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">thresholds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">to_show</span><span class="p">[</span><span class="n">to_show</span> <span class="o">&lt;</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="n">im</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">to_show</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">same_scale</span><span class="p">:</span>
                <span class="c1"># https://stackoverflow.com/questions/23876588</span>
                <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
                <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s1">&#39;5%&#39;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>

            <span class="n">title</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;(</span><span class="si">{td}</span><span class="s1">x</span><span class="si">{td}</span><span class="s1"> template)&#39;</span>
            <span class="k">if</span> <span class="n">match_value_weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">match_value_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">title</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39; (weight=</span><span class="si">{w:.2f}</span><span class="s1">)&#39;</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">same_scale</span><span class="p">:</span>
            <span class="c1"># l, b, w, h</span>
            <span class="n">cax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.85</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">])</span>
            <span class="n">cb</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
            <span class="n">cb</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">&#39;match value&#39;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">right</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;template matching metric at each template offset&#39;</span>
        <span class="k">if</span> <span class="n">thresholds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">(white space is pixels below corresponding threshold)&#39;</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="c1"># TODO may want to decrease wspace if same_scale</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">wspace</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

    <span class="n">all_flat_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">mi</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">for</span> <span class="n">mi</span> <span class="ow">in</span> <span class="n">match_images</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;thresholds for each scale:&#39;</span><span class="p">,</span> <span class="n">thresholds</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;min (possibly scaled) match val at each scale:&#39;</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">vs</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="k">for</span> <span class="n">vs</span> <span class="ow">in</span> <span class="n">all_flat_vals</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;max (possibly scaled) match val at each scale:&#39;</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">vs</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">for</span> <span class="n">vs</span> <span class="ow">in</span> <span class="n">all_flat_vals</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;match_value_weights:&#39;</span><span class="p">,</span> <span class="n">match_value_weights</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">multiscale</span> <span class="ow">or</span> <span class="n">multiscale_strategy</span> <span class="o">==</span> <span class="s1">&#39;one_order&#39;</span><span class="p">:</span>
        <span class="c1"># TODO TODO TODO need to sort flat_vals into one order, while</span>
        <span class="c1"># maintaining info about which match_image (index) a particular</span>
        <span class="c1"># value came from</span>
        <span class="c1"># how to do this while also thresholding each one?</span>

        <span class="n">all_vals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">all_scale_and_flat_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">fv</span><span class="p">,</span> <span class="n">thresh</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">all_flat_vals</span><span class="p">,</span> <span class="n">thresholds</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">thresholds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">flat_idx_at_least_thresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">fv</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">vals_at_least_thresh</span> <span class="o">=</span> <span class="n">fv</span><span class="p">[</span><span class="n">flat_idx_at_least_thresh</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">flat_idx_at_least_thresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fv</span><span class="p">))</span>
                <span class="n">vals_at_least_thresh</span> <span class="o">=</span> <span class="n">fv</span>

            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">thr_frac</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">flat_idx_at_least_thresh</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">fv</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;scale </span><span class="si">{i}</span><span class="s1"> fraction of (scaled) match values above&#39;</span>
                    <span class="s1">&#39; threshold:&#39;</span><span class="p">,</span> <span class="n">thr_frac</span>
                <span class="p">)</span>

                <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">                # TODO delete after figuring out discrepancy</span>
<span class="sd">                thr_fracs = [0.001252, 0.0008177839, 0.00087937249]</span>
<span class="sd">                assert np.isclose(thr_frac, thr_fracs[i])</span>

<span class="sd">                #print(len(flat_idx_at_least_thresh))</span>
<span class="sd">                #import ipdb; ipdb.set_trace()</span>
<span class="sd">                #</span>
<span class="sd">                &#39;&#39;&#39;</span>
                <span class="c1"># TODO TODO maybe find range of weights that produce same</span>
                <span class="c1"># fraction above thresholds, and see if somewhere in that range</span>
                <span class="c1"># is a set of weights that also leads to a global ordering that</span>
                <span class="c1"># behaves as I want?</span>

                <span class="c1"># TODO delete if not gonna finish</span>
                <span class="k">if</span> <span class="n">_initial_single_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">t0</span> <span class="o">=</span> <span class="n">_initial_single_threshold</span>

                    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">                    if match_value_weights is not None:</span>
<span class="sd">                        # Undoing previous multiplication by weight.</span>
<span class="sd">                        w = match_value_weights[i]</span>
<span class="sd">                        orig_match_image = match_images[i] / w</span>
<span class="sd">                    orig </span>

<span class="sd">                    # TODO TODO TODO fit(?) to find match value weight that</span>
<span class="sd">                    # produces same fraction of pixels above threshold</span>
<span class="sd">                    import ipdb; ipdb.set_trace()</span>
<span class="sd">                    &#39;&#39;&#39;</span>
                <span class="c1">#</span>

            <span class="c1"># TODO maybe just store ranges of indices in concatenated</span>
            <span class="c1"># flat_idx... that correspond to each source img?</span>
            <span class="n">src_img_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">flat_idx_at_least_thresh</span><span class="p">))</span>

            <span class="n">scale_and_flat_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                <span class="p">[</span><span class="n">src_img_idx</span><span class="p">,</span> <span class="n">flat_idx_at_least_thresh</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">all_scale_and_flat_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scale_and_flat_indices</span><span class="p">)</span>
            <span class="n">all_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vals_at_least_thresh</span><span class="p">)</span>

        <span class="n">all_scale_and_flat_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">all_scale_and_flat_indices</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="n">all_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">all_vals</span><span class="p">)</span>
        <span class="c1"># Reversing order so indices corresponding to biggest element is first,</span>
        <span class="c1"># and so on, decreasing.</span>
        <span class="n">one_order_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">all_vals</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        # TODO delete</span>
<span class="sd">        #np.set_printoptions(threshold=sys.maxsize)</span>
<span class="sd">        out = all_scale_and_flat_indices.T[one_order_indices]</span>
<span class="sd">        print(&#39;all_scale_and_flat_indices.shape:&#39;,</span>
<span class="sd">            all_scale_and_flat_indices.shape</span>
<span class="sd">        )</span>
<span class="sd">        print(&#39;one_order_indices.shape:&#39;, one_order_indices.shape)</span>

<span class="sd">        print(&#39;sorted match values:&#39;)</span>
<span class="sd">        print(all_vals[one_order_indices])</span>

<span class="sd">        nlines = 20</span>
<span class="sd">        head = out[:nlines]</span>
<span class="sd">        tail = out[-nlines:]</span>
<span class="sd">        print(&#39;head:&#39;)</span>
<span class="sd">        print(head)</span>
<span class="sd">        print(&#39;tail:&#39;)</span>
<span class="sd">        print(tail)</span>

<span class="sd">        chead = np.array([[     2, 120520],</span>
<span class="sd">               [     1, 108599],</span>
<span class="sd">               [     0, 125250],</span>
<span class="sd">               [     2, 120521],</span>
<span class="sd">               [     2, 120029],</span>
<span class="sd">               [     2, 120519],</span>
<span class="sd">               [     2, 121011],</span>
<span class="sd">               [     2, 120030],</span>
<span class="sd">               [     2, 121012],</span>
<span class="sd">               [     2, 120028],</span>
<span class="sd">               [     2, 121010],</span>
<span class="sd">               [     1, 108600],</span>
<span class="sd">               [     1, 109096],</span>
<span class="sd">               [     1, 108598],</span>
<span class="sd">               [     1, 108102],</span>
<span class="sd">               [     0, 125750],</span>
<span class="sd">               [     0, 125249],</span>
<span class="sd">               [     0, 124750],</span>
<span class="sd">               [     0, 125251],</span>
<span class="sd">               [     1, 124002]])</span>

<span class="sd">        ctail = np.array([[     0, 108759],</span>
<span class="sd">               [     0, 112252],</span>
<span class="sd">               [     0, 111259],</span>
<span class="sd">               [     0, 112257],</span>
<span class="sd">               [     0, 125723],</span>
<span class="sd">               [     0, 124223],</span>
<span class="sd">               [     0, 128231],</span>
<span class="sd">               [     0, 121728],</span>
<span class="sd">               [     0, 128228],</span>
<span class="sd">               [     0, 124236],</span>
<span class="sd">               [     0, 125736],</span>
<span class="sd">               [     0, 121731],</span>
<span class="sd">               [     0, 128227],</span>
<span class="sd">               [     0, 126236],</span>
<span class="sd">               [     0, 126223],</span>
<span class="sd">               [     0, 121732],</span>
<span class="sd">               [     0, 123723],</span>
<span class="sd">               [     0, 128232],</span>
<span class="sd">               [     0, 121727],</span>
<span class="sd">               [     0, 123736]])</span>

<span class="sd">        try:</span>
<span class="sd">            assert np.array_equal(chead, head)</span>
<span class="sd">            assert np.array_equal(ctail, tail)</span>
<span class="sd">        except AssertionError:</span>
<span class="sd">            print(&#39;arrays did not match&#39;)</span>
<span class="sd">            print(&#39;correct versions (from specific thresholds):&#39;)</span>
<span class="sd">            print(&#39;correct head:&#39;)</span>
<span class="sd">            print(chead)</span>
<span class="sd">            print(&#39;correct tail:&#39;)</span>
<span class="sd">            print(ctail)</span>
<span class="sd">            import ipdb; ipdb.set_trace()</span>
<span class="sd">        #</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">def</span> <span class="nf">match_iter_fn</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">scale_idx</span><span class="p">,</span> <span class="n">match_img_flat_idx</span> <span class="ow">in</span> <span class="n">all_scale_and_flat_indices</span><span class="o">.</span><span class="n">T</span><span class="p">[</span>
                <span class="n">one_order_indices</span><span class="p">]:</span>

                <span class="n">match_image</span> <span class="o">=</span> <span class="n">match_images</span><span class="p">[</span><span class="n">scale_idx</span><span class="p">]</span>
                <span class="n">match_pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">match_img_flat_idx</span><span class="p">,</span>
                    <span class="n">match_image</span><span class="o">.</span><span class="n">shape</span>
                <span class="p">)</span>
                <span class="k">yield</span> <span class="n">scale_idx</span><span class="p">,</span> <span class="n">match_pt</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">all_matches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">match_image</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">match_images</span><span class="p">):</span>
            <span class="n">flat_vals</span> <span class="o">=</span> <span class="n">all_flat_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">sorted_flat_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">flat_vals</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">thresholds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">flat_vals</span><span class="p">[</span><span class="n">sorted_flat_indices</span><span class="p">],</span>
                    <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">sorted_flat_indices</span> <span class="o">=</span> <span class="n">sorted_flat_indices</span><span class="p">[</span><span class="n">idx</span><span class="p">:]</span>
                <span class="k">del</span> <span class="n">idx</span>

            <span class="c1"># Reversing order so indices corresponding to biggest element is</span>
            <span class="c1"># first, and so on, decreasing.</span>
            <span class="n">sorted_flat_indices</span> <span class="o">=</span> <span class="n">sorted_flat_indices</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">sorted_flat_indices</span><span class="p">,</span> <span class="n">match_image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">all_matches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">multiscale_strategy</span> <span class="o">==</span> <span class="s1">&#39;fixed_scale_order&#39;</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">match_iter_fn</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">scale_idx</span> <span class="ow">in</span> <span class="n">scale_order</span><span class="p">:</span>
                    <span class="n">matches</span> <span class="o">=</span> <span class="n">all_matches</span><span class="p">[</span><span class="n">scale_idx</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">match_pt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">matches</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">scale_idx</span><span class="p">,</span> <span class="n">match_pt</span>

        <span class="k">elif</span> <span class="n">multiscale_strategy</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">match_iter_fn</span><span class="p">():</span>
                <span class="n">per_scale_last_idx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_scales</span>
                <span class="n">scale_ps</span> <span class="o">=</span> <span class="n">radii_px_ps</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">scale_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">n_scales</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale_ps</span><span class="p">)</span>
                    <span class="n">matches</span> <span class="o">=</span> <span class="n">all_matches</span><span class="p">[</span><span class="n">scale_idx</span><span class="p">]</span>

                    <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">last</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">last</span><span class="p">,</span> <span class="n">matches</span> <span class="ow">in</span>
                        <span class="nb">zip</span><span class="p">(</span><span class="n">per_scale_last_idx</span><span class="p">,</span> <span class="n">all_matches</span><span class="p">)]):</span>

                        <span class="c1"># This should end the generator&#39;s iteration.</span>
                        <span class="k">return</span>

                    <span class="c1"># Currently just opting to retry sampling when we</span>
                    <span class="c1"># got something for which we have already exhausted all</span>
                    <span class="c1"># matches, rather than changing probabilities and choices.</span>
                    <span class="k">if</span> <span class="n">per_scale_last_idx</span><span class="p">[</span><span class="n">scale_idx</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="k">continue</span>

                    <span class="n">match_idx</span> <span class="o">=</span> <span class="n">per_scale_last_idx</span><span class="p">[</span><span class="n">scale_idx</span><span class="p">]</span>
                    <span class="n">match_pt</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">match_idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">)</span>

                    <span class="n">per_scale_last_idx</span><span class="p">[</span><span class="n">scale_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="k">yield</span> <span class="n">scale_idx</span><span class="p">,</span> <span class="n">match_pt</span>

    <span class="n">match_iter</span> <span class="o">=</span> <span class="n">match_iter_fn</span><span class="p">()</span>

    <span class="c1"># TODO and any point to having subpixel circles anyway?</span>
    <span class="c1"># i.e. will packing decisions ever differ from those w/ rounded int</span>
    <span class="c1"># circles (and then also given that my ijroi currently only supports</span>
    <span class="c1"># saving non-subpixel rois...)?</span>

    <span class="n">claimed</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">center2radius</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="n">total_n_found</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">roi_centers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># roi_ prefix here is to disambiguate this from radii_px input, which</span>
    <span class="c1"># describes radii of various template scales to use for matching, but</span>
    <span class="c1"># NOT the radii of the particular matched ROI outputs.</span>
    <span class="n">roi_radii_px</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">ns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_found_per_scale</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_scales</span>

    <span class="n">max_exclusion_radius_px</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">exclusion_radius_frac</span> <span class="o">*</span> <span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">radii_px</span><span class="p">)</span>
    <span class="n">scale_info_printed</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_scales</span>
    <span class="k">for</span> <span class="n">scale_idx</span><span class="p">,</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">match_iter</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">total_n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">total_n_found</span> <span class="o">&gt;=</span> <span class="n">total_n</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">elif</span> <span class="n">ns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">n_found</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n_found</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">n_found_per_scale</span><span class="p">,</span> <span class="n">ns</span><span class="p">)]):</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="n">n_found_per_scale</span><span class="p">[</span><span class="n">scale_idx</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">ns</span><span class="p">[</span><span class="n">scale_idx</span><span class="p">]:</span>
                <span class="k">continue</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="n">scale_idx</span><span class="p">]</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">d</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">offset</span>

        <span class="k">if</span> <span class="n">exclusion_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">exclusion_mask</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">center</span><span class="p">)]:</span>
                <span class="k">continue</span>

        <span class="n">radius_px</span> <span class="o">=</span> <span class="n">radii_px</span><span class="p">[</span><span class="n">scale_idx</span><span class="p">]</span>
        <span class="n">exclusion_radius_px</span> <span class="o">=</span> <span class="n">radius_px</span> <span class="o">*</span> <span class="n">exclusion_radius_frac</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">scale_info_printed</span><span class="p">[</span><span class="n">scale_idx</span><span class="p">]:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;template d:&#39;</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;radius_px:&#39;</span><span class="p">,</span> <span class="n">radius_px</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;exclusion_radius_frac:&#39;</span><span class="p">,</span> <span class="n">exclusion_radius_frac</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;exclusion_radius_px:&#39;</span><span class="p">,</span> <span class="n">exclusion_radius_px</span><span class="p">)</span>
                <span class="n">scale_info_printed</span><span class="p">[</span><span class="n">scale_idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Ideally I&#39;d probably use a data structure that doesn&#39;t need to</span>
        <span class="c1"># be rebuilt each time (and k-d trees in general don&#39;t, but</span>
        <span class="c1"># scipy&#39;s doesn&#39;t support that (perhaps b/c issues w/ accumulating</span>
        <span class="c1"># rebalancing costs?), nor do they seem to offer spatial</span>
        <span class="c1"># structures that do)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">claimed</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="n">claimed</span><span class="p">)</span>
            <span class="c1"># (would need to relax if supporting 3d)</span>
            <span class="k">assert</span> <span class="n">tree</span><span class="o">.</span><span class="n">m</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="c1"># TODO tests to check whether this is right dist bound</span>
            <span class="c1"># ( / 2 ?)</span>
            <span class="n">dists</span><span class="p">,</span> <span class="n">locs</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">center</span><span class="p">,</span>
                <span class="n">distance_upper_bound</span><span class="o">=</span><span class="n">max_exclusion_radius_px</span> <span class="o">*</span> <span class="mi">2</span>
            <span class="p">)</span>
            <span class="c1"># Docs say this indicates no neighbors found.</span>
            <span class="k">if</span> <span class="n">locs</span> <span class="o">!=</span> <span class="n">tree</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">dists</span> <span class="o">=</span> <span class="p">[</span><span class="n">dists</span><span class="p">]</span>
                    <span class="n">locs</span> <span class="o">=</span> <span class="p">[</span><span class="n">locs</span><span class="p">]</span>

                <span class="n">conflict</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">dist</span><span class="p">,</span> <span class="n">neighbor_idx</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">locs</span><span class="p">):</span>
                    <span class="c1"># TODO TODO any way to add metadata to tree element to avoid</span>
                    <span class="c1"># this lookup? (+ dist bound above)</span>
                    <span class="n">neighbor_r</span> <span class="o">=</span> <span class="n">center2radius</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">neighbor_idx</span><span class="p">])]</span>
                    <span class="c1"># We already counted the radius about the tentative</span>
                    <span class="c1"># new ROI, but that assumes all neighbors are just points.</span>
                    <span class="c1"># This prevents small ROIs from being placed inside big</span>
                    <span class="c1"># ones.</span>
                    <span class="c1"># TODO check these two lines</span>
                    <span class="n">dist</span> <span class="o">-=</span> <span class="n">neighbor_r</span> <span class="o">*</span> <span class="n">exclusion_radius_frac</span>
                    <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">exclusion_radius_px</span><span class="p">:</span>
                        <span class="n">conflict</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">conflict</span><span class="p">:</span>
                    <span class="k">continue</span>

        <span class="n">total_n_found</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">roi_centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
        <span class="n">roi_radii_px</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">radius_px</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">draw_on</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">draw_pt</span> <span class="o">=</span> <span class="p">(</span><span class="n">ups</span> <span class="o">*</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ups</span> <span class="o">*</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">draw_c</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">ups</span> <span class="o">*</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span>
                <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">ups</span> <span class="o">*</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># TODO factor this stuff out into post-hoc drawing fn, so that</span>
            <span class="c1"># roi filters in here can exclude stuff? or maybe just factor out</span>
            <span class="c1"># the filtering stuff anyway?</span>

            <span class="k">if</span> <span class="n">draw_bboxes</span><span class="p">:</span>
                <span class="n">cv2</span><span class="o">.</span><span class="n">rectangle</span><span class="p">(</span><span class="n">draw_on</span><span class="p">,</span> <span class="n">draw_pt</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">draw_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ups</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span> <span class="n">draw_pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ups</span> <span class="o">*</span> <span class="n">d</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">),</span> <span class="mi">2</span>
                <span class="p">)</span>

            <span class="c1"># TODO maybe diff colors for diff scales? (random or from kwarg)</span>
            <span class="k">if</span> <span class="n">draw_circles</span><span class="p">:</span>
                <span class="n">cv2</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">draw_on</span><span class="p">,</span> <span class="n">draw_c</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">ups</span> <span class="o">*</span> <span class="n">radius_px</span><span class="p">)),</span>
                    <span class="p">(</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">2</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">draw_nums</span><span class="p">:</span>
                <span class="n">cv2</span><span class="o">.</span><span class="n">putText</span><span class="p">(</span><span class="n">draw_on</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">total_n_found</span><span class="p">),</span> <span class="n">draw_pt</span><span class="p">,</span>
                    <span class="n">cv2</span><span class="o">.</span><span class="n">FONT_HERSHEY_SIMPLEX</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">2</span>
                <span class="p">)</span>

        <span class="n">claimed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
        <span class="n">center2radius</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">center</span><span class="p">)]</span> <span class="o">=</span> <span class="n">radius_px</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    if debug and _show_packing_constraints:</span>
<span class="sd">        title = &#39;greedy_roi_packing overlap exlusion mask&#39;</span>
<span class="sd">        viz.imshow(claimed, title)</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">debug</span> <span class="ow">and</span> <span class="n">draw_on</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">_show_fit</span><span class="p">:</span>
        <span class="n">viz</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">draw_on</span><span class="p">,</span> <span class="s1">&#39;greedy_roi_packing fit&#39;</span><span class="p">)</span>

    <span class="c1"># TODO also use kdtree for this step</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">min_neighbors</span><span class="p">:</span>
        <span class="n">filtered_roi_centers</span> <span class="o">=</span> <span class="n">roi_centers</span>
        <span class="n">filtered_roi_radii</span> <span class="o">=</span> <span class="n">roi_radii_px</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># TODO maybe extend this to requiring the nth closest be closer than a</span>
        <span class="c1"># certain amount (to exclude 2 (or n) cells off by themselves)</span>
        <span class="n">filtered_roi_centers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">filtered_roi_radii</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">roi_centers</span><span class="p">,</span> <span class="n">roi_radii_px</span><span class="p">)):</span>
            <span class="n">n_neighbors</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">other_center</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">roi_centers</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">dist</span> <span class="o">=</span> <span class="n">euclidean_dist</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">other_center</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">min_dist2neighbor_px</span><span class="p">:</span>
                    <span class="n">n_neighbors</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">n_neighbors</span> <span class="o">&gt;=</span> <span class="n">min_neighbors</span><span class="p">:</span>
                    <span class="n">filtered_roi_centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
                    <span class="n">filtered_roi_radii</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>
                    <span class="k">break</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_roi_centers</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_roi_radii</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">filtered_roi_centers</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">filtered_roi_radii</span><span class="p">)</span></div>


<span class="c1"># TODO what were these files for again?</span>
<div class="viewcode-block" id="autoroi_metadata_filename"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.autoroi_metadata_filename">[docs]</a><span class="k">def</span> <span class="nf">autoroi_metadata_filename</span><span class="p">(</span><span class="n">ijroi_file</span><span class="p">):</span>
    <span class="n">path</span><span class="p">,</span> <span class="n">fname</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">ijroi_file</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;.</span><span class="si">{}</span><span class="s1">.meta.p&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span></div>


<div class="viewcode-block" id="scale_template"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.scale_template">[docs]</a><span class="k">def</span> <span class="nf">scale_template</span><span class="p">(</span><span class="n">template_data</span><span class="p">,</span> <span class="n">um_per_pixel_xy</span><span class="p">,</span> <span class="n">target_cell_diam_um</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">target_cell_diam_px</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_template_d</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">cv2</span>

    <span class="k">if</span> <span class="n">target_cell_diam_um</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># TODO make either of other kwargs also work (any of the 3 should</span>
        <span class="c1"># be alone)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="n">template</span> <span class="o">=</span> <span class="n">template_data</span><span class="p">[</span><span class="s1">&#39;template&#39;</span><span class="p">]</span>
    <span class="n">margin</span> <span class="o">=</span> <span class="n">template_data</span><span class="p">[</span><span class="s1">&#39;margin&#39;</span><span class="p">]</span>
    <span class="c1"># We enforce both elements of shape are same at creation.</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">target_cell_diam_px</span> <span class="o">=</span> <span class="n">target_cell_diam_um</span> <span class="o">/</span> <span class="n">um_per_pixel_xy</span>

    <span class="c1"># TODO which of these is correct? both? assert one is w/in</span>
    <span class="c1"># rounding err of other?</span>
    <span class="n">template_cell_diam_px</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">margin</span>
    <span class="n">template_scale</span> <span class="o">=</span> <span class="n">target_cell_diam_px</span> <span class="o">/</span> <span class="n">template_cell_diam_px</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    template_cell_diam_um = template_data[&#39;mean_cell_diam_um&#39;]</span>
<span class="sd">    print(f&#39;template_cell_diam_um: {template_cell_diam_um}&#39;)</span>
<span class="sd">    template_scale = target_cell_diam_um / template_cell_diam_um</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">new_template_d</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">template_scale</span> <span class="o">*</span> <span class="n">d</span><span class="p">))</span>
    <span class="n">new_template_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">new_template_d</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">scale_template:</span><span class="se">\n</span><span class="s1">d: </span><span class="si">{d}</span><span class="se">\n</span><span class="s1">margin: </span><span class="si">{margin}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;um_per_pixel_xy: </span><span class="si">{um_per_pixel_xy}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;target_cell_diam_um: </span><span class="si">{target_cell_diam_um}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;target_cell_diam_px: </span><span class="si">{target_cell_diam_px}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;template_cell_diam_px: </span><span class="si">{template_cell_diam_px}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;template_scale: </span><span class="si">{template_scale}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;new_template_d: </span><span class="si">{new_template_d}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">new_template_d</span> <span class="o">!=</span> <span class="n">d</span><span class="p">:</span>
        <span class="n">scaled_template</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">new_template_shape</span><span class="p">)</span>
        <span class="n">scaled_template_cell_diam_px</span> <span class="o">=</span> \
            <span class="n">template_cell_diam_px</span> <span class="o">*</span> <span class="n">new_template_d</span> <span class="o">/</span> <span class="n">d</span>

        <span class="k">return</span> <span class="n">scaled_template</span><span class="p">,</span> <span class="n">scaled_template_cell_diam_px</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">template</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">template_cell_diam_px</span></div>


<span class="k">def</span> <span class="nf">_get_template_roi_radius_px</span><span class="p">(</span><span class="n">template_data</span><span class="p">,</span> <span class="n">if_template_d</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_round</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">template</span> <span class="o">=</span> <span class="n">template_data</span><span class="p">[</span><span class="s1">&#39;template&#39;</span><span class="p">]</span>
    <span class="n">margin</span> <span class="o">=</span> <span class="n">template_data</span><span class="p">[</span><span class="s1">&#39;margin&#39;</span><span class="p">]</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">template_cell_diam_px</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">margin</span>
    <span class="n">template_cell_radius_px</span> <span class="o">=</span> <span class="n">template_cell_diam_px</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="n">radius_frac</span> <span class="o">=</span> <span class="n">template_cell_radius_px</span> <span class="o">/</span> <span class="n">d</span>

    <span class="k">if</span> <span class="n">if_template_d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">if_template_d</span> <span class="o">=</span> <span class="n">d</span>

    <span class="n">radius_px</span> <span class="o">=</span> <span class="n">radius_frac</span> <span class="o">*</span> <span class="n">if_template_d</span>
    <span class="k">if</span> <span class="n">_round</span><span class="p">:</span>
        <span class="n">radius_px</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">radius_px</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">radius_px</span>


<span class="c1"># TODO test this w/ n.5 centers / radii</span>
<div class="viewcode-block" id="get_circle_ijroi_input"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.get_circle_ijroi_input">[docs]</a><span class="k">def</span> <span class="nf">get_circle_ijroi_input</span><span class="p">(</span><span class="n">center_px</span><span class="p">,</span> <span class="n">radius_px</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns appropriate first arg for my ijroi.write_roi</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">min_corner</span> <span class="o">=</span> <span class="p">[</span><span class="n">center_px</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">radius_px</span><span class="p">,</span> <span class="n">center_px</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">radius_px</span><span class="p">]</span>
    <span class="n">max_corner</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">min_corner</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">radius_px</span><span class="p">,</span>
        <span class="n">min_corner</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">radius_px</span>
    <span class="p">]</span>
    <span class="n">bbox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">min_corner</span><span class="p">,</span> <span class="n">max_corner</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">bbox</span></div>


<span class="c1"># TODO move to viz? or maybe move all roi stuff to a new module?</span>
<div class="viewcode-block" id="plot_circles"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.plot_circles">[docs]</a><span class="k">def</span> <span class="nf">plot_circles</span><span class="p">(</span><span class="n">draw_on</span><span class="p">,</span> <span class="n">centers</span><span class="p">,</span> <span class="n">radii</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">cv2</span>
    <span class="n">draw_on</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">draw_on</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mi">255</span><span class="p">,</span>
        <span class="n">norm_type</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">NORM_MINMAX</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">CV_8UC1</span>
    <span class="p">)</span>
    <span class="n">draw_on</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">equalizeHist</span><span class="p">(</span><span class="n">draw_on</span><span class="p">)</span>

    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">10.5</span><span class="p">))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">draw_on</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">center</span><span class="p">,</span> <span class="n">radius</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">centers</span><span class="p">,</span> <span class="n">radii</span><span class="p">):</span>
        <span class="n">roi_circle</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">((</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">radius</span><span class="p">,</span>
            <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">roi_circle</span><span class="p">)</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">set_frame_on</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="fit_circle_rois"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.fit_circle_rois">[docs]</a><span class="k">def</span> <span class="nf">fit_circle_rois</span><span class="p">(</span><span class="n">tif</span><span class="p">,</span> <span class="n">template_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">avg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">movie</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">method_str</span><span class="o">=</span><span class="s1">&#39;cv2.TM_CCOEFF_NORMED&#39;</span><span class="p">,</span> <span class="n">thresholds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">exclusion_radius_frac</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">min_neighbors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">_packing_debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">show_fit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">write_ijrois</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">_force_write_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">exclude_dark_regions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dark_fraction_beyond_dhist_min</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
    <span class="n">max_n_rois</span><span class="o">=</span><span class="mi">650</span><span class="p">,</span> <span class="n">min_n_rois</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span>
    <span class="n">per_scale_max_n_rois</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">per_scale_min_n_rois</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">threshold_update_factor</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
    <span class="n">update_factor_shrink_factor</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">max_threshold_tries</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">_um_per_pixel_xy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">multiscale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">roi_diams_px</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">roi_diams_um</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">roi_diams_from_kmeans_k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">multiscale_strategy</span><span class="o">=</span><span class="s1">&#39;one_order&#39;</span><span class="p">,</span> <span class="n">template_d2match_value_scale_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">allow_duplicate_px_scales</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">_show_scaled_templates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Even if movie or avg is passed in, tif is used to find metadata and</span>
<span class="sd">    determine where to save ImageJ ROIs.</span>

<span class="sd">    _um_per_pixel_xy only used for testing. Normally, XML is found from `tif`,</span>
<span class="sd">    and that is loaded to get this value.</span>

<span class="sd">    Returns centers_px, radii_px</span>
<span class="sd">    (both w/ coordinates and conventions ijrois uses)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">tifffile</span>
    <span class="kn">import</span> <span class="nn">cv2</span>
    <span class="kn">import</span> <span class="nn">ijroi</span>
    <span class="kn">from</span> <span class="nn">scipy.cluster.vq</span> <span class="k">import</span> <span class="n">vq</span>

    <span class="k">if</span> <span class="n">debug</span> <span class="ow">and</span> <span class="n">show_fit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">show_fit</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># TODO update all kwargs to go through a dict (store existing defaults as</span>
    <span class="c1"># dict at module level?) + need to handle passing of remaining to greedy_...</span>
    <span class="c1"># appropriately (don&#39;t pass stuff it won&#39;t take / don&#39;t unwrap and modify</span>
    <span class="c1"># so it only uses relevant ones)</span>
    <span class="n">method_str2defaults</span> <span class="o">=</span> <span class="p">{</span>
        <span class="c1"># Though this does not work at all scales</span>
        <span class="c1"># (especially sensitive since not normed)</span>
        <span class="s1">&#39;cv2.TM_CCOEFF&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;threshold&#39;</span><span class="p">:</span> <span class="mf">4000.0</span><span class="p">,</span> <span class="s1">&#39;exclude_dark_regions&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
        <span class="s1">&#39;cv2.TM_CCOEFF_NORMED&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;threshold&#39;</span><span class="p">:</span> <span class="mf">0.3</span><span class="p">,</span> <span class="s1">&#39;exclude_dark_regions&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">method_str</span> <span class="ow">in</span> <span class="n">method_str2defaults</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">method_str2defaults</span><span class="p">[</span><span class="n">method_str</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="n">threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;threshold&#39;</span><span class="p">)</span>
    <span class="n">exclude_dark_regions</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;exclude_dark_regions&#39;</span><span class="p">)</span>

    <span class="c1"># Will divide rather than multiply by this,</span>
    <span class="c1"># if we need to increase threshold.</span>
    <span class="k">assert</span> <span class="n">threshold_update_factor</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">threshold_update_factor</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="c1"># TODO also provide fitting for this fn in extract_template?</span>
    <span class="n">mvw_key</span> <span class="o">=</span> <span class="s1">&#39;match_value_weights&#39;</span>
    <span class="k">if</span> <span class="n">template_d2match_value_scale_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">multiscale</span> <span class="ow">and</span> <span class="n">multiscale_strategy</span> <span class="o">==</span> <span class="s1">&#39;one_scale&#39;</span>
        <span class="k">assert</span> <span class="n">mvw_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span>
        <span class="n">match_value_weights</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">match_value_weights</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">mvw_key</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">match_value_weights</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">template_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># TODO maybe options to cache this data across calls?</span>
        <span class="c1"># might not matter...</span>
        <span class="n">template_data</span> <span class="o">=</span> <span class="n">load_template_data</span><span class="p">(</span><span class="n">err_if_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">template</span> <span class="o">=</span> <span class="n">template_data</span><span class="p">[</span><span class="s1">&#39;template&#39;</span><span class="p">]</span>
    <span class="n">margin</span> <span class="o">=</span> <span class="n">template_data</span><span class="p">[</span><span class="s1">&#39;margin&#39;</span><span class="p">]</span>
    <span class="n">mean_cell_diam_um</span> <span class="o">=</span> <span class="n">template_data</span><span class="p">[</span><span class="s1">&#39;mean_cell_diam_um&#39;</span><span class="p">]</span>
    <span class="n">frame_shape</span> <span class="o">=</span> <span class="n">template_data</span><span class="p">[</span><span class="s1">&#39;frame_shape&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">_um_per_pixel_xy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">tiff_filename2keys</span><span class="p">(</span><span class="n">tif</span><span class="p">)</span>
        <span class="n">ti_dir</span> <span class="o">=</span> <span class="n">thorimage_dir</span><span class="p">(</span><span class="o">*</span><span class="nb">tuple</span><span class="p">(</span><span class="n">keys</span><span class="p">))</span>
        <span class="n">xmlroot</span> <span class="o">=</span> <span class="n">thor</span><span class="o">.</span><span class="n">get_thorimage_xmlroot</span><span class="p">(</span><span class="n">ti_dir</span><span class="p">)</span>
        <span class="n">um_per_pixel_xy</span> <span class="o">=</span> <span class="n">thor</span><span class="o">.</span><span class="n">get_thorimage_pixelsize_xml</span><span class="p">(</span><span class="n">xmlroot</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">keys</span><span class="p">,</span> <span class="n">ti_dir</span><span class="p">,</span> <span class="n">xmlroot</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">um_per_pixel_xy</span> <span class="o">=</span> <span class="n">_um_per_pixel_xy</span>

    <span class="k">if</span> <span class="n">multiscale</span><span class="p">:</span>
        <span class="c1"># Centroids are scalars in units of um diam</span>
        <span class="n">kmeans_k2cluster_cell_diams</span> <span class="o">=</span> \
            <span class="n">template_data</span><span class="p">[</span><span class="s1">&#39;kmeans_k2cluster_cell_diams&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">roi_diams_px</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">roi_diams_um</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">roi_diams_from_kmeans_k</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="n">roi_diams_um</span> <span class="o">=</span> <span class="p">[</span><span class="n">rd_px</span> <span class="o">*</span> <span class="n">um_per_pixel_xy</span> <span class="k">for</span> <span class="n">rd_px</span> <span class="ow">in</span> <span class="n">roi_diams_px</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">roi_diams_um</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">roi_diams_from_kmeans_k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">roi_diams_from_kmeans_k</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">roi_diams_um</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">roi_diams_um</span> <span class="o">=</span> <span class="n">kmeans_k2cluster_cell_diams</span><span class="p">[</span><span class="n">roi_diams_from_kmeans_k</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">in_px</span> <span class="o">=</span> <span class="n">roi_diams_um</span> <span class="o">/</span> <span class="n">um_per_pixel_xy</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Using ROI diameters </span><span class="si">{roi_diams_um}</span><span class="s1"> um (</span><span class="si">{in_px}</span><span class="s1"> px) from&#39;</span>
                    <span class="n">f</span><span class="s1">&#39; K-means (k=</span><span class="si">{roi_diams_from_kmeans_k}</span><span class="s1">) on data used to &#39;</span>
                    <span class="s1">&#39;generate template.&#39;</span>
                <span class="p">)</span>
                <span class="k">del</span> <span class="n">in_px</span>

            <span class="k">if</span> <span class="n">multiscale_strategy</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
                <span class="n">all_cell_diams_um</span> <span class="o">=</span> <span class="n">template_data</span><span class="p">[</span><span class="s1">&#39;all_cell_diams_um&#39;</span><span class="p">]</span>
                <span class="n">clusters</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">vq</span><span class="p">(</span><span class="n">all_cell_diams_um</span><span class="p">,</span> <span class="n">roi_diams_um</span><span class="p">)</span>
                <span class="n">count_clusters</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1"># otherwise would need to reindex the counts</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">count_clusters</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">count_clusters</span><span class="p">))</span>
                <span class="n">radii_px_ps</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;radii_px_ps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">radii_px_ps</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Calculated these probabilities from template data:&#39;</span><span class="p">,</span>
                    <span class="n">radii_px_ps</span>
                <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">roi_diams_px</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="n">roi_diams_um</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="n">roi_diams_from_kmeans_k</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="n">roi_diams_um</span> <span class="o">=</span> <span class="p">[</span><span class="n">mean_cell_diam_um</span><span class="p">]</span>

    <span class="n">n_scales</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">roi_diams_um</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">thresholds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">thresholds</span> <span class="o">=</span> <span class="p">[</span><span class="n">threshold</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_scales</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># TODO better way to specify thresholds in kmeans case, where</span>
        <span class="c1"># user may not know # thresholds needed in advance?</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">thresholds</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_scales</span>
    <span class="k">del</span> <span class="n">threshold</span>
    <span class="n">thresholds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">thresholds</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">write_ijrois</span> <span class="ow">or</span> <span class="n">_force_write_to</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">write_ijrois</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">path</span><span class="p">,</span> <span class="n">tiff_last_part</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">tif</span><span class="p">)</span>
        <span class="n">tiff_parts</span> <span class="o">=</span> <span class="n">tiff_last_part</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.tif&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tiff_parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">tiff_parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">tiff_parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_rois.zip&#39;</span><span class="p">)</span>

        <span class="c1"># TODO TODO change. fname needs to always be under</span>
        <span class="c1"># analysis_output_root (or just change input in</span>
        <span class="c1"># kc_natural_mixes/populate_db.py).</span>
        <span class="c1"># TODO or at least err if not subdir of it</span>
        <span class="c1"># see: https://stackoverflow.com/questions/3812849</span>

        <span class="k">if</span> <span class="n">_force_write_to</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_force_write_to</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">fname</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">tiff_parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_auto_rois.zip&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fname</span> <span class="o">=</span> <span class="n">_force_write_to</span>

        <span class="c1"># TODO also check for modifications before overwriting (mtime in that hidden</span>
        <span class="c1"># file)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">overwrite</span> <span class="ow">and</span> <span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;already existed. returning.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">avg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">movie</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">movie</span> <span class="o">=</span> <span class="n">tifffile</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">tif</span><span class="p">)</span>
        <span class="n">avg</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">avg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">avg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">orig_frame_d</span> <span class="o">=</span> <span class="n">avg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># It seemed to me that picking a new threshold on cv2.TM_CCOEFF_NORMED was</span>
    <span class="c1"># not sufficient to reproduce cv2.TM_CCOEFF performance, so even if the</span>
    <span class="c1"># normed version were useful to keep the same threshold across image scales,</span>
    <span class="c1"># it seems other problems prevent me from using that in my case, so I&#39;m</span>
    <span class="c1"># rescaling the image to match against.</span>

    <span class="n">frame_downscaling</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">if</span> <span class="n">avg</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">frame_shape</span><span class="p">:</span>
        <span class="n">scaled_avg</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">avg</span><span class="p">,</span> <span class="n">frame_shape</span><span class="p">)</span>

        <span class="n">new_frame_d</span> <span class="o">=</span> <span class="n">scaled_avg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">frame_downscaling</span> <span class="o">=</span> <span class="n">orig_frame_d</span> <span class="o">/</span> <span class="n">new_frame_d</span>
        <span class="k">del</span> <span class="n">new_frame_d</span>
        <span class="n">um_per_pixel_xy</span> <span class="o">*=</span> <span class="n">frame_downscaling</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">scaled_avg</span> <span class="o">=</span> <span class="n">avg</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;frame downscaling:&#39;</span><span class="p">,</span> <span class="n">frame_downscaling</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;scaled_avg.shape:&#39;</span><span class="p">,</span> <span class="n">scaled_avg</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">exclude_dark_regions</span><span class="p">:</span>
        <span class="n">histvals</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">scaled_avg</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">hv_deltas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">histvals</span><span class="p">)</span>
        <span class="c1"># TODO get the + 3 from a parameter controller percentage beyond</span>
        <span class="c1"># count delta min</span>
        <span class="c1"># min from: histvals[idx + 1] - histvals[idx]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">hv_deltas</span><span class="p">)</span>

        <span class="c1"># TODO if this method of calculating dark_thresh doesn&#39;t seem robust,</span>
        <span class="c1"># compare robustness to thresholds from percetile of overal image,</span>
        <span class="c1"># or fixed thresholds on image scaled to [0,1], or fixed fractional</span>
        <span class="c1"># adjustment from delta hist threshold</span>

        <span class="c1"># Originally, dark_thresh was from bins[idx + 4], and that seemed to</span>
        <span class="c1"># work OK, so on one image, I calculated initial value (~0.5 -&gt; 0.5)</span>
        <span class="c1"># of this from: ((scaled_avg &lt;= bins[idx + 4]).sum() -</span>
        <span class="c1"># (scaled_avg &lt;= bins[idx]).sum()) / scaled_avg.size (=0.543...)</span>
        <span class="c1">#dark_thresh = bins[idx + 4]</span>
        <span class="n">dh_min_fractile</span> <span class="o">=</span> <span class="p">(</span><span class="n">scaled_avg</span> <span class="o">&lt;=</span> <span class="n">bins</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">scaled_avg</span><span class="o">.</span><span class="n">size</span>
        <span class="n">dark_thresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">scaled_avg</span><span class="p">,</span>
            <span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="n">dark_fraction_beyond_dhist_min</span> <span class="o">+</span> <span class="n">dh_min_fractile</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">exclusion_mask</span> <span class="o">=</span> <span class="n">scaled_avg</span> <span class="o">&gt;=</span> <span class="n">dark_thresh</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">scaled_avg</span><span class="p">)</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">exclusion_mask</span><span class="p">)</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;exclusion mask&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">exclusion_mask</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># We enforce earlier that template must be symmetric.</span>
    <span class="n">d</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="n">d</span> <span class="o">==</span> <span class="n">d2</span>

    <span class="n">match_images</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">template_ds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">per_scale_radii_px</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">roi_diam_um</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">roi_diams_um</span><span class="p">):</span>
        <span class="n">scaled_template</span><span class="p">,</span> <span class="n">scaled_template_cell_diam_px</span> <span class="o">=</span> <span class="n">scale_template</span><span class="p">(</span>
            <span class="n">template_data</span><span class="p">,</span> <span class="n">um_per_pixel_xy</span><span class="p">,</span> <span class="n">roi_diam_um</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span>
        <span class="p">)</span>
        <span class="n">scaled_radius_px</span> <span class="o">=</span> <span class="n">scaled_template_cell_diam_px</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;scaled template shape:&#39;</span><span class="p">,</span> <span class="n">scaled_template</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">debug</span> <span class="ow">and</span> <span class="n">_show_scaled_templates</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">scaled_template</span><span class="p">)</span>
            <span class="n">title</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;scaled template (roi_diam_um=</span><span class="si">{roi_diam_um:.2f}</span><span class="s1">)&#39;</span>
            <span class="k">if</span> <span class="n">roi_diams_px</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">title</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">(roi_diam_px=</span><span class="si">{roi_diams_px[i]:.1f}</span><span class="s1">)&#39;</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

        <span class="c1"># see note below about what i&#39;d need to do to continue using</span>
        <span class="c1"># a check like this</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        if template.shape != scaled_template.shape:</span>
<span class="sd">            # Just for checking that conversion back to original coordinates</span>
<span class="sd">            # (just scale diff) seems to be working.</span>
<span class="sd">            radius_px_before_scaling = int(round((d - 2 * margin) / 2))</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">match_image</span> <span class="o">=</span> <span class="n">template_match</span><span class="p">(</span><span class="n">scaled_avg</span><span class="p">,</span> <span class="n">scaled_template</span><span class="p">,</span>
            <span class="n">method_str</span><span class="o">=</span><span class="n">method_str</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;scaled_template_cell_diam_px: &#39;</span>
                <span class="n">f</span><span class="s1">&#39;</span><span class="si">{scaled_template_cell_diam_px}</span><span class="s1">&#39;</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;scaled_radius_px: </span><span class="si">{scaled_radius_px}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">template_d</span> <span class="o">=</span> <span class="n">scaled_template</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">match_value_weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
            <span class="n">template_d2match_value_scale_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>

            <span class="n">match_value_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">template_d2match_value_scale_fn</span><span class="p">(</span><span class="n">template_d</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">match_images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">match_image</span><span class="p">)</span>
        <span class="n">template_ds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">template_d</span><span class="p">)</span>
        <span class="n">per_scale_radii_px</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scaled_radius_px</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;template_ds:&#39;</span><span class="p">,</span> <span class="n">template_ds</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">template_ds</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">template_ds</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_duplicate_px_scales</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;roi_diams_um: </span><span class="si">{roi_diams_um}</span><span class="s1"> led to duplicate &#39;</span>
                <span class="n">f</span><span class="s1">&#39;pixel template scales (</span><span class="si">{template_ds}</span><span class="s1">)&#39;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO would still probably have to de-duplicate before passing to</span>
            <span class="c1"># packing fn</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="c1"># TODO one fn that just returns circles, another to draw?</span>
    <span class="n">draw_on</span> <span class="o">=</span> <span class="n">scaled_avg</span>

    <span class="k">if</span> <span class="n">per_scale_max_n_rois</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">per_scale_min_n_rois</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">per_scale_max_n_rois</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">per_scale_max_n_rois</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_scales</span><span class="p">,</span> \
                <span class="n">f</span><span class="s1">&#39;{len(per_scale_max_n_rois)} != </span><span class="si">{n_scales}</span><span class="s1">&#39;</span>

        <span class="k">if</span> <span class="n">per_scale_min_n_rois</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">per_scale_min_n_rois</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_scales</span><span class="p">,</span> \
                <span class="n">f</span><span class="s1">&#39;{len(per_scale_min_n_rois)} != </span><span class="si">{n_scales}</span><span class="s1">&#39;</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Per-scale bounds on number of ROIs overriding global bounds.&#39;</span><span class="p">)</span>
        <span class="n">min_n_rois</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">max_n_rois</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">per_scale_n_roi_bounds</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">per_scale_n_roi_bounds</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">threshold_tries_remaining</span> <span class="o">=</span> <span class="n">max_threshold_tries</span>
    <span class="k">while</span> <span class="n">threshold_tries_remaining</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Regarding exclusion_radius_frac: 0.3 allowed too much overlap, 0.5</span>
        <span class="c1"># borderline too much w/ non-normed method (0.7 OK there)</span>
        <span class="c1"># (r=4,er=4,6 respectively, in 0.5 and 0.7 cases)</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;per_scale_radii_px:&#39;</span><span class="p">,</span> <span class="n">per_scale_radii_px</span><span class="p">)</span>

        <span class="n">centers_px</span><span class="p">,</span> <span class="n">radii_px</span> <span class="o">=</span> <span class="n">greedy_roi_packing</span><span class="p">(</span><span class="n">match_images</span><span class="p">,</span> <span class="n">template_ds</span><span class="p">,</span>
            <span class="n">per_scale_radii_px</span><span class="p">,</span> <span class="n">thresholds</span><span class="o">=</span><span class="n">thresholds</span><span class="p">,</span>
            <span class="n">min_neighbors</span><span class="o">=</span><span class="n">min_neighbors</span><span class="p">,</span> <span class="n">exclusion_mask</span><span class="o">=</span><span class="n">exclusion_mask</span><span class="p">,</span>
            <span class="n">exclusion_radius_frac</span><span class="o">=</span><span class="n">exclusion_radius_frac</span><span class="p">,</span> <span class="n">draw_on</span><span class="o">=</span><span class="n">draw_on</span><span class="p">,</span>
            <span class="n">draw_bboxes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">draw_nums</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">multiscale_strategy</span><span class="o">=</span><span class="n">multiscale_strategy</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">_packing_debug</span><span class="p">,</span>
            <span class="n">match_value_weights</span><span class="o">=</span><span class="n">match_value_weights</span><span class="p">,</span>
            <span class="n">_src_img_shape</span><span class="o">=</span><span class="n">scaled_avg</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="n">n_found_per_scale</span> <span class="o">=</span> <span class="p">{</span><span class="n">r_px</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">r_px</span> <span class="ow">in</span> <span class="n">per_scale_radii_px</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">r_px</span> <span class="ow">in</span> <span class="n">radii_px</span><span class="p">:</span>
            <span class="n">n_found_per_scale</span><span class="p">[</span><span class="n">r_px</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">centers_px</span><span class="p">)</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span><span class="n">n_found_per_scale</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;number of ROIs found at each pixel radius scale:&#39;</span><span class="p">)</span>
            <span class="n">pprint</span><span class="p">(</span><span class="n">n_found_per_scale</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">per_scale_n_roi_bounds</span><span class="p">:</span>
            <span class="n">wrong_num</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_scales</span><span class="p">):</span>
                <span class="n">r_px</span> <span class="o">=</span> <span class="n">per_scale_radii_px</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">thr</span> <span class="o">=</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">n_found</span> <span class="o">=</span> <span class="n">n_found_per_scale</span><span class="p">[</span><span class="n">r_px</span><span class="p">]</span>

                <span class="n">sstr</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39; w/ radius=</span><span class="si">{r_px}</span><span class="s1">px @ thr=</span><span class="si">{thr:.2f}</span><span class="s1">&#39;</span>
                <span class="n">have_retries</span> <span class="o">=</span> <span class="n">threshold_tries_remaining</span> <span class="o">&gt;</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">have_retries</span><span class="p">:</span>
                    <span class="n">sstr</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">thr:={{:.2f}}&#39;</span>

                <span class="k">if</span> <span class="n">per_scale_max_n_rois</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">smax</span> <span class="o">=</span> <span class="n">per_scale_max_n_rois</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">smax</span> <span class="o">&lt;</span> <span class="n">n_found</span><span class="p">:</span>
                        <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">threshold_update_factor</span>
                        <span class="nb">print</span><span class="p">((</span><span class="n">f</span><span class="s1">&#39;too many ROIs (</span><span class="si">{n_found}</span><span class="s1"> &gt; </span><span class="si">{smax}</span><span class="s1">)</span><span class="si">{sstr}</span><span class="s1">&#39;</span>
                            <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">thresholds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">have_retries</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">()</span>
                        <span class="p">))</span>
                        <span class="n">wrong_num</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="n">per_scale_min_n_rois</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">smin</span> <span class="o">=</span> <span class="n">per_scale_min_n_rois</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">n_found</span> <span class="o">&lt;</span> <span class="n">smin</span><span class="p">:</span>
                        <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">threshold_update_factor</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;too few ROIs (</span><span class="si">{n_found}</span><span class="s1"> &lt; </span><span class="si">{smin}</span><span class="s1">)</span><span class="si">{sstr}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">have_retries</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">()</span>
                        <span class="p">))</span>
                        <span class="n">wrong_num</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">wrong_num</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="n">n_rois_found</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">centers_px</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">per_scale_n_roi_bounds</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">min_n_rois</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">min_n_rois</span> <span class="o">&lt;=</span> <span class="n">n_rois_found</span><span class="p">)</span> <span class="ow">and</span>
                <span class="p">(</span><span class="n">max_n_rois</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">n_rois_found</span> <span class="o">&lt;=</span> <span class="n">max_n_rois</span><span class="p">)):</span>
                <span class="k">break</span>

        <span class="n">threshold_tries_remaining</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">threshold_tries_remaining</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">debug</span> <span class="ow">or</span> <span class="n">_packing_debug</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;too many/few (</span><span class="si">{n_rois_found}</span><span class="s1">) ROIs still &#39;</span>
                <span class="n">f</span><span class="s1">&#39;detected after </span><span class="si">{max_threshold_tries}</span><span class="s1"> attempts to modify &#39;</span>
                <span class="s1">&#39;threshold. try changing threshold(s)?&#39;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">per_scale_n_roi_bounds</span><span class="p">:</span>
            <span class="c1"># TODO maybe squeeze to threshold if just one</span>
            <span class="n">fail_notice_suffix</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;, with thresholds=</span><span class="si">{thresholds}</span><span class="s1">&#39;</span>
            <span class="k">if</span> <span class="n">max_n_rois</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">n_rois_found</span> <span class="o">&gt;</span> <span class="n">max_n_rois</span><span class="p">:</span>
                <span class="n">thresholds</span> <span class="o">/=</span> <span class="n">threshold_update_factor</span>
                <span class="n">fail_notice</span> <span class="o">=</span> \
                    <span class="n">f</span><span class="s1">&#39;found too many ROIs (</span><span class="si">{n_rois_found}</span><span class="s1"> &gt; </span><span class="si">{max_n_rois}</span><span class="s1">)&#39;</span>

            <span class="k">elif</span> <span class="n">min_n_rois</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">n_rois_found</span> <span class="o">&lt;</span> <span class="n">min_n_rois</span><span class="p">:</span>
                <span class="n">thresholds</span> <span class="o">*=</span> <span class="n">threshold_update_factor</span>
                <span class="n">fail_notice</span> <span class="o">=</span> \
                    <span class="n">f</span><span class="s1">&#39;found too few ROIs (</span><span class="si">{n_rois_found}</span><span class="s1"> &lt; </span><span class="si">{min_n_rois}</span><span class="s1">)&#39;</span>

            <span class="n">fail_notice</span> <span class="o">+=</span> <span class="n">fail_notice_suffix</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{fail_notice}</span><span class="se">\n\n</span><span class="s1">retrying with thresholds=</span><span class="si">{thresholds}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">update_factor_shrink_factor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">threshold_update_factor</span> <span class="o">=</span> \
                <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">threshold_update_factor</span><span class="p">)</span> <span class="o">*</span> <span class="n">update_factor_shrink_factor</span>

    <span class="k">if</span> <span class="n">frame_downscaling</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="c1"># TODO if i want to keep doing this check, while also supporting</span>
        <span class="c1"># multiscale case, gonna need to check (the set of?) radii returned</span>
        <span class="c1"># (would i need more info for that?)</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        # This is to invert any previous scaling into coordinates for matching</span>
<span class="sd">        radius_px = scaled_radius_px * frame_downscaling</span>

<span class="sd">        # always gonna be true? seems like if a frame were 7x7, converting size</span>
<span class="sd">        # down to say 2x2 and back up by same formula would yield same result</span>
<span class="sd">        # as a 6x6 input or something, no?</span>
<span class="sd">        assert radius_px == radius_px_before_scaling</span>
<span class="sd">        del radius_px_before_scaling</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">centers_px</span> <span class="o">=</span> <span class="n">centers_px</span> <span class="o">*</span> <span class="n">frame_downscaling</span>
        <span class="n">radii_px</span>  <span class="o">=</span> <span class="n">radii_px</span> <span class="o">*</span> <span class="n">frame_downscaling</span>

    <span class="c1"># TODO would some other (alternating?) rounding rule help?</span>
    <span class="c1"># TODO random seed then randomly choose between floor and ceil for stuff</span>
    <span class="c1"># at 0.5?</span>
    <span class="c1"># TODO TODO or is rounding wrong? do some tests to try to figure out</span>
    <span class="n">centers_px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">centers_px</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
    <span class="n">radii_px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">radii_px</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
    <span class="c1"># this work if centers is empty?</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">centers_px</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">centers_px</span> <span class="o">&lt;</span> <span class="n">orig_frame_d</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">show_fit</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plot_circles</span><span class="p">(</span><span class="n">avg</span><span class="p">,</span> <span class="n">centers_px</span><span class="p">,</span> <span class="n">radii_px</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tif</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;fit circles&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="n">tiff_title</span><span class="p">(</span><span class="n">tif</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

        <span class="n">roi_plot_dir</span> <span class="o">=</span> <span class="s1">&#39;auto_rois&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">roi_plot_dir</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;making directory </span><span class="si">{roi_plot_dir}</span><span class="s1"> for plots of ROI fits&#39;</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">roi_plot_dir</span><span class="p">)</span>

        <span class="n">roi_plot_fname</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">roi_plot_dir</span><span class="p">,</span> <span class="n">title</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span><span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.png&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Writing image showing fit ROIs to </span><span class="si">{roi_plot_fname}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">roi_plot_fname</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">write_ijrois</span><span class="p">:</span>
        <span class="n">auto_md_fname</span> <span class="o">=</span> <span class="n">autoroi_metadata_filename</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>

        <span class="n">name2bboxes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">center_px</span><span class="p">,</span> <span class="n">radius_px</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">centers_px</span><span class="p">,</span> <span class="n">radii_px</span><span class="p">)):</span>
            <span class="c1"># TODO TODO test that these radii are preserved across</span>
            <span class="c1"># round trip save / loads?</span>
            <span class="n">bbox</span> <span class="o">=</span> <span class="n">get_circle_ijroi_input</span><span class="p">(</span><span class="n">center_px</span><span class="p">,</span> <span class="n">radius_px</span><span class="p">)</span>
            <span class="n">name2bboxes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">bbox</span><span class="p">))</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Writing ImageJ ROIs to </span><span class="si">{}</span><span class="s1"> ...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
        <span class="c1"># TODO TODO TODO uncomment</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        ijroi.write_oval_roi_zip(name2bboxes, fname)</span>

<span class="sd">        with open(auto_md_fname, &#39;wb&#39;) as f:</span>
<span class="sd">            data = {</span>
<span class="sd">                &#39;mtime&#39;: getmtime(fname)</span>
<span class="sd">            }</span>
<span class="sd">            pickle.dump(data, f)</span>
<span class="sd">        &#39;&#39;&#39;</span>

    <span class="n">ns_found</span> <span class="o">=</span> <span class="p">[</span><span class="n">n_found_per_scale</span><span class="p">[</span><span class="n">rpx</span><span class="p">]</span> <span class="k">for</span> <span class="n">rpx</span> <span class="ow">in</span> <span class="n">per_scale_radii_px</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">centers_px</span><span class="p">,</span> <span class="n">radii_px</span><span class="p">,</span> <span class="n">thresholds</span><span class="p">,</span> <span class="n">ns_found</span></div>


<div class="viewcode-block" id="template_data_file"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.template_data_file">[docs]</a><span class="k">def</span> <span class="nf">template_data_file</span><span class="p">():</span>
    <span class="n">template_cache</span> <span class="o">=</span> <span class="s1">&#39;template.p&#39;</span>
    <span class="k">return</span> <span class="n">join</span><span class="p">(</span><span class="n">analysis_output_root</span><span class="p">(),</span> <span class="n">template_cache</span><span class="p">)</span></div>


<div class="viewcode-block" id="load_template_data"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.load_template_data">[docs]</a><span class="k">def</span> <span class="nf">load_template_data</span><span class="p">(</span><span class="n">err_if_missing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">template_cache</span> <span class="o">=</span> <span class="n">template_data_file</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">template_cache</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">template_cache</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">err_if_missing</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;template data not found at </span><span class="si">{template_cache}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="assign_frames_to_trials"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.assign_frames_to_trials">[docs]</a><span class="k">def</span> <span class="nf">assign_frames_to_trials</span><span class="p">(</span><span class="n">movie</span><span class="p">,</span> <span class="n">presentations_per_block</span><span class="p">,</span> <span class="n">block_first_frames</span><span class="p">,</span>
    <span class="n">odor_onset_frames</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns arrays trial_start_frames, trial_stop_frames</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_frames</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># TODO maybe just add metadata[&#39;drop_first_n_frames&#39;] to this?</span>
    <span class="c1"># (otherwise, that variable screws things up, right?)</span>
    <span class="c1">#onset_frame_offset = \</span>
    <span class="c1">#    odor_onset_frames[0] - block_first_frames[0]</span>

    <span class="c1"># TODO delete this hack, after implementing more robust frame-to-trial</span>
    <span class="c1"># assignment described below</span>
    <span class="n">b2o_offsets</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">o</span> <span class="o">-</span> <span class="n">b</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">block_first_frames</span><span class="p">,</span>
        <span class="n">odor_onset_frames</span><span class="p">[::</span><span class="n">presentations_per_block</span><span class="p">])</span>
    <span class="p">])</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">b2o_offsets</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span>
    <span class="c1"># TODO TODO TODO re-enable after fixing frame_times based issues w/</span>
    <span class="c1"># volumetric data</span>
    <span class="c1"># TODO might need to allow for some error here...? frame or two?</span>
    <span class="c1"># (in resonant scanner case, w/ frame averaging maybe)</span>
    <span class="c1">#assert b2o_offsets[-1] == b2o_offsets[-2]</span>
    <span class="n">onset_frame_offset</span> <span class="o">=</span> <span class="n">b2o_offsets</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1">#</span>

    <span class="c1"># TODO TODO TODO instead of this frame # strategy for assigning frames</span>
    <span class="c1"># to trials, maybe do this:</span>
    <span class="c1"># 1) find ~max # frames from block start to onset, as above</span>
    <span class="c1"># TODO but maybe still warn if some offset deviates from max by more</span>
    <span class="c1"># than a frame or two...</span>
    <span class="c1"># 2) paint all frames before odor onsets up to this max # frames / time</span>
    <span class="c1">#    (if frames have a time discontinuity between them indicating</span>
    <span class="c1">#     acquisition did not proceed continuously between them, do not</span>
    <span class="c1">#     paint across that boundary)</span>
    <span class="c1"># 3) paint still-unassigned frames following odor onset in the same</span>
    <span class="c1">#    fashion (again stopping at boundaries of &gt; certain dt)</span>
    <span class="c1"># [4)] if not using max in #1 (but something like rounded mean)</span>
    <span class="c1">#      may still have unassigned frames at block starts. assign those to</span>
    <span class="c1">#      trials.</span>
    <span class="c1"># TODO could just assert everything within block regions i&#39;m painting</span>
    <span class="c1"># does not have time discontinuities, and then i could just deal w/</span>
    <span class="c1"># frames</span>

    <span class="n">trial_start_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">odor_onset_frames</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">onset_frame_offset</span>
    <span class="p">)</span>
    <span class="n">trial_stop_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="n">odor_onset_frames</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">onset_frame_offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_frames</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="p">)</span>

    <span class="c1"># TODO same checks are made for blocks, so factor out?</span>
    <span class="n">total_trial_frames</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">t_start</span><span class="p">,</span> <span class="n">t_end</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
        <span class="nb">zip</span><span class="p">(</span><span class="n">trial_start_frames</span><span class="p">,</span> <span class="n">trial_stop_frames</span><span class="p">)):</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">last_t_end</span> <span class="o">=</span> <span class="n">trial_stop_frames</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">last_t_end</span> <span class="o">==</span> <span class="p">(</span><span class="n">t_start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">total_trial_frames</span> <span class="o">+=</span> <span class="n">t_end</span> <span class="o">-</span> <span class="n">t_start</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">assert</span> <span class="n">total_trial_frames</span> <span class="o">==</span> <span class="n">n_frames</span><span class="p">,</span> \
        <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> != </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">total_trial_frames</span><span class="p">,</span> <span class="n">n_frames</span><span class="p">)</span>
    <span class="c1">#</span>

    <span class="c1"># TODO warn if all block/trial lens are not the same? (by more than some</span>
    <span class="c1"># threshold probably)</span>

    <span class="k">return</span> <span class="n">trial_start_frames</span><span class="p">,</span> <span class="n">trial_stop_frames</span></div>


<span class="c1"># TODO TODO TODO after refactoring much of the stuff that was under</span>
<span class="c1"># open_recording and some of its downstream fns from gui.py, also refactor this</span>
<span class="c1"># to use the new fns</span>
<span class="c1"># TODO and maybe move this to project/analysis specific specific repo /</span>
<span class="c1"># submodule as it uses matlab pipeline ouputs...</span>
<span class="c1"># TODO maybe move to project/analysis specific repo / submodule (same as other</span>
<span class="c1"># stuff that uses matlab_kc_plane outputs)</span>
<span class="c1"># TODO maybe move to matlab (this is only fn that uses either of fns imported</span>
<span class="c1"># from there)</span>
<div class="viewcode-block" id="movie_blocks"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.movie_blocks">[docs]</a><span class="k">def</span> <span class="nf">movie_blocks</span><span class="p">(</span><span class="n">tif</span><span class="p">,</span> <span class="n">movie</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">allow_gsheet_to_restrict_blocks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">stimfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">first_block</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">last_block</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns list of arrays, one per continuous acquisition.</span>

<span class="sd">    `tif` must be named and placed according to convention, and a .mat file</span>
<span class="sd">    created from `ejhonglab/matlab_kc_plane` (typically run via `populate_db.py`</span>
<span class="sd">    in what is now my `kc_natural_mixes` repo) must exist in the conventional</span>
<span class="sd">    path under the analysis root. This .mat file is used for the timing</span>
<span class="sd">    information (ultimately derived mainly from ThorSync data).</span>

<span class="sd">    Total length along time dimension should be preserved from input TIFF.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">stats</span>

    <span class="k">if</span> <span class="n">movie</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">tifffile</span>
        <span class="n">movie</span> <span class="o">=</span> <span class="n">tifffile</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">tif</span><span class="p">)</span>

    <span class="n">keys</span> <span class="o">=</span> <span class="n">tiff_filename2keys</span><span class="p">(</span><span class="n">tif</span><span class="p">)</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">matlab</span><span class="o">.</span><span class="n">matfile</span><span class="p">(</span><span class="o">*</span><span class="n">keys</span><span class="p">)</span>
    <span class="c1">#mat = matfile(*keys)</span>

    <span class="c1"># TODO TODO TODO refactor all stuff that uses this to new output format</span>
    <span class="c1"># (and remove factored checks, etc)</span>
    <span class="n">ti</span> <span class="o">=</span> <span class="n">matlab</span><span class="o">.</span><span class="n">load_mat_timing_info</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="c1">#ti = load_mat_timing_info(mat)</span>

    <span class="k">if</span> <span class="n">stimfile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">mb_team_gsheet</span><span class="p">()</span>
        <span class="n">recordings</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">date</span> <span class="o">==</span> <span class="n">keys</span><span class="o">.</span><span class="n">date</span><span class="p">)</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">fly_num</span> <span class="o">==</span> <span class="n">keys</span><span class="o">.</span><span class="n">fly_num</span><span class="p">)</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">thorimage_dir</span> <span class="o">==</span> <span class="n">keys</span><span class="o">.</span><span class="n">thorimage_id</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">del</span> <span class="n">df</span>
        <span class="n">recording</span> <span class="o">=</span> <span class="n">recordings</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">recordings</span>
        <span class="k">if</span> <span class="n">recording</span><span class="o">.</span><span class="n">project</span> <span class="o">!=</span> <span class="s1">&#39;natural_odors&#39;</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;project type </span><span class="si">{}</span><span class="s1"> not supported. skipping.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">recording</span><span class="o">.</span><span class="n">project</span><span class="p">))</span>
            <span class="k">return</span>

        <span class="n">stimfile</span> <span class="o">=</span> <span class="n">recording</span><span class="p">[</span><span class="s1">&#39;stimulus_data_file&#39;</span><span class="p">]</span>
        <span class="n">first_block</span> <span class="o">=</span> <span class="n">recording</span><span class="p">[</span><span class="s1">&#39;first_block&#39;</span><span class="p">]</span>
        <span class="n">last_block</span> <span class="o">=</span> <span class="n">recording</span><span class="p">[</span><span class="s1">&#39;last_block&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">recording</span>

        <span class="n">stimfile_path</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">stimfile_root</span><span class="p">(),</span> <span class="n">stimfile</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;using hardcoded stimulus file, rather than using value &#39;</span>
            <span class="s1">&#39;from MB team gsheet&#39;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">stimfile</span><span class="p">):</span>
            <span class="n">stimfile_path</span> <span class="o">=</span> <span class="n">stimfile</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stimfile_path</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">stimfile_root</span><span class="p">(),</span> <span class="n">stimfile</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">exists</span><span class="p">(</span><span class="n">stimfile_path</span><span class="p">),</span> <span class="p">(</span><span class="n">f</span><span class="s1">&#39;stimfile </span><span class="si">{stimfile}</span><span class="s1"> not found &#39;</span>
                <span class="n">f</span><span class="s1">&#39;alone or under {stimfile_root()}&#39;</span>
            <span class="p">)</span>

    <span class="c1"># TODO also err if not readable / valid</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">stimfile_path</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;copy missing stimfile </span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">stimfile</span><span class="p">,</span>
            <span class="n">stimfile_root</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">stimfile_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="c1"># TODO just infer from data if no stimfile and not specified in</span>
    <span class="c1"># metadata_file</span>
    <span class="n">n_repeats</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_repeats&#39;</span><span class="p">])</span>

    <span class="c1"># TODO delete this hack (which is currently just using new pickle</span>
    <span class="c1"># format as a proxy for the experiment being a supermixture experiment)</span>
    <span class="k">if</span> <span class="s1">&#39;odor_lists&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="c1"># The 3 is because 3 odors are compared in each repeat for the</span>
        <span class="c1"># natural_odors project.</span>
        <span class="n">presentations_per_repeat</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">odor_list</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;odor_pair_list&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_expected_real_blocks</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">odor_list</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;odor_lists&#39;</span><span class="p">]</span>
        <span class="c1"># because of &quot;block&quot; def in arduino / get_stiminfo code</span>
        <span class="c1"># not matching def in randomizer / stimfile code</span>
        <span class="c1"># (scopePin pulses vs. randomization units, depending on settings)</span>
        <span class="n">presentations_per_repeat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">odor_list</span><span class="p">)</span> <span class="o">//</span> <span class="n">n_expected_real_blocks</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">odor_list</span><span class="p">)</span> <span class="o">%</span> <span class="n">n_expected_real_blocks</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="c1"># Hardcode to break up into more blocks, to align defs of blocks.</span>
        <span class="c1"># TODO (maybe just for experiments on 2019-07-25 ?) or change block</span>
        <span class="c1"># handling in here? make more flexible?</span>
        <span class="n">n_repeats</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">presentations_per_block</span> <span class="o">=</span> <span class="n">n_repeats</span> <span class="o">*</span> <span class="n">presentations_per_repeat</span>

    <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">first_block</span><span class="p">):</span>
        <span class="n">first_block</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">first_block</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">first_block</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">last_block</span><span class="p">):</span>
        <span class="n">n_full_panel_blocks</span> <span class="o">=</span> \
            <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">odor_list</span><span class="p">)</span> <span class="o">/</span> <span class="n">presentations_per_block</span><span class="p">)</span>
        <span class="n">last_block</span> <span class="o">=</span> <span class="n">n_full_panel_blocks</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">last_block</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">last_block</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">first_presentation</span> <span class="o">=</span> <span class="n">first_block</span> <span class="o">*</span> <span class="n">presentations_per_block</span>
    <span class="n">last_presentation</span> <span class="o">=</span> <span class="p">(</span><span class="n">last_block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">presentations_per_block</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">odor_list</span> <span class="o">=</span> <span class="n">odor_list</span><span class="p">[</span><span class="n">first_presentation</span><span class="p">:(</span><span class="n">last_presentation</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">odor_list</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">presentations_per_repeat</span> <span class="o">*</span> <span class="n">n_repeats</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># TODO TODO delete odor frame stuff after using them to check blocks frames</span>
    <span class="c1"># are actually blocks and not trials</span>
    <span class="c1"># TODO or if keeping odor stuff, re-add asserts involving odor_list,</span>
    <span class="c1"># since how i have that here</span>

    <span class="n">odor_onset_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ti</span><span class="p">[</span><span class="s1">&#39;stim_on&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span>
        <span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">odor_offset_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ti</span><span class="p">[</span><span class="s1">&#39;stim_off&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">odor_onset_frames</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">odor_offset_frames</span><span class="p">)</span>

    <span class="c1"># Of length equal to number of blocks. Each element is the frame</span>
    <span class="c1"># index (from 1) in CNMF output that starts the block, where</span>
    <span class="c1"># block is defined as a period of continuous acquisition.</span>
    <span class="n">block_first_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ti</span><span class="p">[</span><span class="s1">&#39;block_start_frame&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span>
        <span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">block_last_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ti</span><span class="p">[</span><span class="s1">&#39;block_end_frame&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span>
        <span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">n_blocks_from_gsheet</span> <span class="o">=</span> <span class="n">last_block</span> <span class="o">-</span> <span class="n">first_block</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">n_blocks_from_thorsync</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">block_first_frames</span><span class="p">)</span>

    <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">odor_list</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">last_block</span> <span class="o">-</span> <span class="n">first_block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
        <span class="n">presentations_per_block</span><span class="p">)</span>

    <span class="n">n_presentations</span> <span class="o">=</span> <span class="n">n_blocks_from_gsheet</span> <span class="o">*</span> <span class="n">presentations_per_block</span>

    <span class="n">err_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> blocks (</span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1">, inclusive) in Google sheet {{}} </span><span class="si">{}</span><span class="s1"> &#39;</span> <span class="o">+</span>
        <span class="s1">&#39;blocks from ThorSync.&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_blocks_from_gsheet</span><span class="p">,</span>
        <span class="n">first_block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">last_block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_blocks_from_thorsync</span><span class="p">)</span>
    <span class="n">fail_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39; Fix in Google sheet, turn off &#39;</span> <span class="o">+</span>
        <span class="s1">&#39;cache if necessary, and rerun.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n_blocks_from_gsheet</span> <span class="o">&gt;</span> <span class="n">n_blocks_from_thorsync</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">fail_msg</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">n_blocks_from_gsheet</span> <span class="o">&lt;</span> <span class="n">n_blocks_from_thorsync</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">allow_gsheet_to_restrict_blocks</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">err_msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;&lt;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39; This is ONLY ok if you &#39;</span><span class="o">+</span>
                <span class="s1">&#39;intend to exclude the LAST </span><span class="si">{}</span><span class="s1"> blocks in the Thor output.&#39;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_blocks_from_thorsync</span> <span class="o">-</span> <span class="n">n_blocks_from_gsheet</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;&lt;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">fail_msg</span><span class="p">)</span>

    <span class="n">frame_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ti</span><span class="p">[</span><span class="s1">&#39;frame_times&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="c1"># TODO replace this w/ factored check fn</span>
    <span class="n">total_block_frames</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">b_start</span><span class="p">,</span> <span class="n">b_end</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
        <span class="nb">zip</span><span class="p">(</span><span class="n">block_first_frames</span><span class="p">,</span> <span class="n">block_last_frames</span><span class="p">)):</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">last_b_end</span> <span class="o">=</span> <span class="n">block_last_frames</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">last_b_end</span> <span class="o">==</span> <span class="p">(</span><span class="n">b_start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">assert</span> <span class="p">(</span><span class="n">b_start</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_times</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b_end</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_times</span><span class="p">))</span>
        <span class="n">block_frametimes</span> <span class="o">=</span> <span class="n">frame_times</span><span class="p">[</span><span class="n">b_start</span><span class="p">:</span><span class="n">b_end</span><span class="p">]</span>
        <span class="n">dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">block_frametimes</span><span class="p">)</span>
        <span class="c1"># np.max(np.abs(dts - np.mean(dts))) / np.mean(dts)</span>
        <span class="c1"># was 0.000148... in one case I tested w/ data from the older</span>
        <span class="c1"># system, so the check below w/ rtol=1e-4 would fail.</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">dts</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">dts</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">3e-4</span><span class="p">)</span>

        <span class="n">total_block_frames</span> <span class="o">+=</span> <span class="n">b_end</span> <span class="o">-</span> <span class="n">b_start</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">orig_n_frames</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># TODO may need to remove this assert to handle cases where there is a</span>
    <span class="c1"># partial block (stopped early). leave assert after slicing tho.</span>
    <span class="c1"># (warn instead, probably)</span>
    <span class="k">assert</span> <span class="n">total_block_frames</span> <span class="o">==</span> <span class="n">orig_n_frames</span><span class="p">,</span> \
        <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> != </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">total_block_frames</span><span class="p">,</span> <span class="n">orig_n_frames</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">allow_gsheet_to_restrict_blocks</span><span class="p">:</span>
        <span class="c1"># TODO unit test for case where first_block != 0 and == 0</span>
        <span class="c1"># w/ last_block == first_block and &gt; first_block</span>
        <span class="c1"># TODO TODO doesn&#39;t this only support dropping blocks at end?</span>
        <span class="c1"># do i assert that first_block is 0 then? probably should...</span>
        <span class="c1"># TODO TODO TODO shouldnt it be first_block:last_block+1?</span>
        <span class="n">block_first_frames</span> <span class="o">=</span> <span class="n">block_first_frames</span><span class="p">[</span>
            <span class="p">:(</span><span class="n">last_block</span> <span class="o">-</span> <span class="n">first_block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">block_last_frames</span> <span class="o">=</span> <span class="n">block_last_frames</span><span class="p">[</span>
            <span class="p">:(</span><span class="n">last_block</span> <span class="o">-</span> <span class="n">first_block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">block_first_frames</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_blocks_from_gsheet</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">block_last_frames</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_blocks_from_gsheet</span>

        <span class="c1"># TODO also delete this odor frame stuff when done</span>
        <span class="n">odor_onset_frames</span> <span class="o">=</span> <span class="n">odor_onset_frames</span><span class="p">[</span>
            <span class="p">:(</span><span class="n">last_presentation</span> <span class="o">-</span> <span class="n">first_presentation</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">odor_offset_frames</span> <span class="o">=</span> <span class="n">odor_offset_frames</span><span class="p">[</span>
            <span class="p">:(</span><span class="n">last_presentation</span> <span class="o">-</span> <span class="n">first_presentation</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">odor_onset_frames</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_presentations</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">odor_offset_frames</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_presentations</span>
        <span class="c1">#</span>

        <span class="n">frame_times</span> <span class="o">=</span> <span class="n">frame_times</span><span class="p">[:(</span><span class="n">block_last_frames</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="n">last_frame</span> <span class="o">=</span> <span class="n">block_last_frames</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">n_tossed_frames</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">last_frame</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n_tossed_frames</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;Tossing trailing </span><span class="si">{}</span><span class="s1"> of </span><span class="si">{}</span><span class="s1"> frames of movie, which did not &#39;</span> <span class="o">+</span>
            <span class="s1">&#39;belong to any used block.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">n_tossed_frames</span><span class="p">,</span> <span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="c1"># TODO factor this metadata handling out. fns for load / set?</span>
    <span class="c1"># combine w/ remy&#39;s .mat metadata (+ my stimfile?)</span>

    <span class="c1"># This will return defaults if the YAML file is not found.</span>
    <span class="n">meta</span> <span class="o">=</span> <span class="n">load_metadata</span><span class="p">(</span><span class="o">*</span><span class="n">keys</span><span class="p">)</span>

    <span class="c1"># TODO want / need to do more than just slice to free up memory from</span>
    <span class="c1"># other pixels? is that operation worth it?</span>
    <span class="n">drop_first_n_frames</span> <span class="o">=</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;drop_first_n_frames&#39;</span><span class="p">]</span>
    <span class="c1"># TODO TODO err if this is past first odor onset (or probably even too</span>
    <span class="c1"># close)</span>
    <span class="k">del</span> <span class="n">meta</span>

    <span class="n">odor_onset_frames</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">drop_first_n_frames</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">odor_onset_frames</span><span class="p">]</span>
    <span class="n">odor_offset_frames</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">drop_first_n_frames</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">odor_offset_frames</span><span class="p">]</span>

    <span class="n">block_first_frames</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">drop_first_n_frames</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">block_first_frames</span><span class="p">]</span>
    <span class="n">block_first_frames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">block_last_frames</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">drop_first_n_frames</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">block_last_frames</span><span class="p">]</span>

    <span class="k">assert</span> <span class="n">odor_onset_frames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="n">frame_times</span> <span class="o">=</span> <span class="n">frame_times</span><span class="p">[</span><span class="n">drop_first_n_frames</span><span class="p">:]</span>
    <span class="n">movie</span> <span class="o">=</span> <span class="n">movie</span><span class="p">[</span><span class="n">drop_first_n_frames</span><span class="p">:(</span><span class="n">last_frame</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="c1"># TODO TODO fix bug referenced in cthulhu:190520...</span>
    <span class="c1"># and re-enable assert</span>
    <span class="k">assert</span> <span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_times</span><span class="p">),</span> \
        <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> != </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_times</span><span class="p">))</span>
    <span class="c1">#</span>

    <span class="k">if</span> <span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_times</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> != </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_times</span><span class="p">)))</span>

    <span class="c1"># TODO maybe move this and the above checks on block start/end frames</span>
    <span class="c1"># + frametimes into assign_frames_to_trials</span>
    <span class="n">n_frames</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">total_block_frames</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">e</span> <span class="o">-</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span>
        <span class="nb">zip</span><span class="p">(</span><span class="n">block_first_frames</span><span class="p">,</span> <span class="n">block_last_frames</span><span class="p">)</span>
    <span class="p">])</span>

    <span class="k">assert</span> <span class="n">total_block_frames</span> <span class="o">==</span> <span class="n">n_frames</span><span class="p">,</span> \
        <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> != </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">total_block_frames</span><span class="p">,</span> <span class="n">n_frames</span><span class="p">)</span>


    <span class="c1"># TODO any time / space diff returning slices to slice array and only</span>
    <span class="c1"># slicing inside loop vs. returning list of (presumably views) by slicing</span>
    <span class="c1"># matrix?</span>
    <span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">movie</span><span class="p">[</span><span class="n">start</span><span class="p">:(</span><span class="n">stop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="ow">in</span>
        <span class="nb">zip</span><span class="p">(</span><span class="n">block_first_frames</span><span class="p">,</span> <span class="n">block_last_frames</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="k">assert</span> <span class="nb">sum</span><span class="p">([</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">])</span> <span class="o">==</span> <span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">blocks</span></div>


<div class="viewcode-block" id="downsample_movie"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.downsample_movie">[docs]</a><span class="k">def</span> <span class="nf">downsample_movie</span><span class="p">(</span><span class="n">movie</span><span class="p">,</span> <span class="n">target_fps</span><span class="p">,</span> <span class="n">current_fps</span><span class="p">,</span> <span class="n">allow_overshoot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">allow_uneven_division</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">relative_fps_err</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns downsampled movie by averaging consecutive groups of frames.</span>

<span class="sd">    Groups of frames averaged do not overlap.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">allow_uneven_division</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="c1"># TODO maybe kwarg for max acceptable (rel/abs?) factor error,</span>
    <span class="c1"># and err / return None if it can&#39;t be achieved</span>

    <span class="n">target_factor</span> <span class="o">=</span> <span class="n">current_fps</span> <span class="o">/</span> <span class="n">target_fps</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;allow_overshoot: </span><span class="si">{allow_overshoot}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;allow_uneven_division: </span><span class="si">{allow_uneven_division}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;relative_fps_err: </span><span class="si">{relative_fps_err}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;target_fps: </span><span class="si">{target_fps:.2f}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;target_factor: </span><span class="si">{target_factor:.2f}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">n_frames</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># TODO TODO also support uneven # of frames per bin (toss last probably)</span>
    <span class="c1"># (skip loop checking for even divisors in that case)</span>

    <span class="c1"># Find the largest/closest downsampling we can do, with equal numbers of</span>
    <span class="c1"># frames for each average.</span>
    <span class="n">best_divisor</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_frames</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n_frames</span> <span class="o">%</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">decimated_n_frames</span> <span class="o">=</span> <span class="n">n_frames</span> <span class="o">//</span> <span class="n">i</span>
        <span class="c1"># (will always be float(i) in even division case, so could get rid of</span>
        <span class="c1"># this if that&#39;s all i&#39;ll support)</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">n_frames</span> <span class="o">/</span> <span class="n">decimated_n_frames</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;factor: </span><span class="si">{factor:.2f}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">factor</span> <span class="o">&gt;</span> <span class="n">target_factor</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">allow_overshoot</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;breaking because of overshoot&#39;</span><span class="p">)</span>
            <span class="k">break</span>

        <span class="n">downsampled_fps</span> <span class="o">=</span> <span class="n">current_fps</span> <span class="o">/</span> <span class="n">factor</span>
        <span class="n">fps_error</span> <span class="o">=</span> <span class="n">downsampled_fps</span> <span class="o">-</span> <span class="n">target_fps</span>
        <span class="k">if</span> <span class="n">relative_fps_err</span><span class="p">:</span>
            <span class="n">fps_error</span> <span class="o">=</span> <span class="n">fps_error</span> <span class="o">/</span> <span class="n">target_fps</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;downsampled_fps: </span><span class="si">{downsampled_fps:.2f}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;fps_error: </span><span class="si">{fps_error:.2f}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">best_divisor</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">fps_error</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">best_fps_error</span><span class="p">):</span>
            <span class="n">best_divisor</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">best_downsampled_fps</span> <span class="o">=</span> <span class="n">downsampled_fps</span>
            <span class="n">best_fps_error</span> <span class="o">=</span> <span class="n">fps_error</span>
            <span class="n">best_factor</span> <span class="o">=</span> <span class="n">factor</span>

            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;best_downsampled_fps: </span><span class="si">{best_downsampled_fps:.2f}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;new best factor&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="p">(</span><span class="n">best_divisor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
            <span class="nb">abs</span><span class="p">(</span><span class="n">fps_error</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">best_fps_error</span><span class="p">)):</span>

            <span class="k">assert</span> <span class="n">allow_overshoot</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;breaking because past best factor&#39;</span><span class="p">)</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">best_divisor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="c1"># TODO unit test for this case</span>
    <span class="k">if</span> <span class="n">best_divisor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;best downsampling with this flags at factor of 1&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;best_divisor: </span><span class="si">{best_divisor}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;best_factor: </span><span class="si">{best_factor:.2f}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;best_fps_error: </span><span class="si">{best_fps_error:.2f}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;best_downsampled_fps: </span><span class="si">{best_downsampled_fps:.2f}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">frame_shape</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">new_n_frames</span> <span class="o">=</span> <span class="n">n_frames</span> <span class="o">//</span> <span class="n">best_divisor</span>

    <span class="c1"># see: stackoverflow.com/questions/15956309 for how to adapt this</span>
    <span class="c1"># to uneven division case</span>
    <span class="n">downsampled</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">new_n_frames</span><span class="p">,</span> <span class="n">best_divisor</span><span class="p">)</span> <span class="o">+</span> <span class="n">frame_shape</span>
        <span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># TODO maybe it&#39;s obvious, but is there any kind of guarantee dimensions in</span>
    <span class="c1"># frame_shape will not be screwed up in a way relevant to the average</span>
    <span class="c1"># when reshaping?</span>
    <span class="c1"># well, at least this looks reasonable:</span>
    <span class="c1"># viz.image_grid(downsampled[:64])</span>

    <span class="k">return</span> <span class="n">downsampled</span><span class="p">,</span> <span class="n">best_downsampled_fps</span></div>


<span class="c1"># TODO delete (+ probably delete contour2mask too and replace use of both w/ ijroi2mask)</span>
<span class="c1"># don&#39;t like this convexHull based approach though...</span>
<span class="c1"># (because roi may be intentionally not a convex hull)</span>
<div class="viewcode-block" id="ijroi2cv_contour"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.ijroi2cv_contour">[docs]</a><span class="k">def</span> <span class="nf">ijroi2cv_contour</span><span class="p">(</span><span class="n">roi</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">cv2</span>

    <span class="c1">## cnts = cv2.findContours(img, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span>
    <span class="c1">## cnts[1][0].shape</span>
    <span class="c1">## cnts[1][0].dtype</span>
    <span class="c1"># from inspecting output of findContours, as above:</span>
    <span class="c1">#cnt = np.expand_dims(ijroi, 1).astype(np.int32)</span>
    <span class="c1"># TODO fix so this isn&#39;t necessary. in case of rois that didn&#39;t start as</span>
    <span class="c1"># circles, the convexHull may occasionally not be equal to what i want</span>
    <span class="n">cnt</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">convexHull</span><span class="p">(</span><span class="n">roi</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>
    <span class="c1"># if only getting cnt from convexHull, this is probably a given...</span>
    <span class="k">assert</span> <span class="n">cv2</span><span class="o">.</span><span class="n">contourArea</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">cnt</span></div>
<span class="c1">#</span>


<div class="viewcode-block" id="roi_center"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.roi_center">[docs]</a><span class="k">def</span> <span class="nf">roi_center</span><span class="p">(</span><span class="n">roi</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">cv2</span>
    <span class="n">cnt</span> <span class="o">=</span> <span class="n">ijroi2cv_contour</span><span class="p">(</span><span class="n">roi</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">moments</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
    <span class="n">cx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;m10&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="s1">&#39;m00&#39;</span><span class="p">])</span>
    <span class="n">cy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;m01&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="s1">&#39;m00&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">))</span></div>


<div class="viewcode-block" id="roi_centers"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.roi_centers">[docs]</a><span class="k">def</span> <span class="nf">roi_centers</span><span class="p">(</span><span class="n">rois</span><span class="p">):</span>
    <span class="n">centers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">roi</span> <span class="ow">in</span> <span class="n">rois</span><span class="p">:</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">roi_center</span><span class="p">(</span><span class="n">roi</span><span class="p">)</span>
        <span class="c1"># pretty close to (w/in 0.5 in each dim) np.mean(roi, axis=0),</span>
        <span class="c1"># in at least one example i played with</span>
        <span class="n">centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span></div>


<div class="viewcode-block" id="tiff_title"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.tiff_title">[docs]</a><span class="k">def</span> <span class="nf">tiff_title</span><span class="p">(</span><span class="n">tif</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns abbreviation of TIFF filename for use in titles.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tif</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="s1">&#39;tif_stacks&#39;</span><span class="p">]</span>
    <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;.tif&#39;</span>
    <span class="k">if</span> <span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">ext</span><span class="p">):</span>
        <span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">ext</span><span class="p">)]</span>
    <span class="k">return</span> <span class="s1">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span></div>


<span class="c1"># TODO didn&#39;t i have some other fn for this? delete one if so</span>
<span class="c1"># (or was it just in natural_odors?)</span>
<div class="viewcode-block" id="to_filename"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.to_filename">[docs]</a><span class="k">def</span> <span class="nf">to_filename</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take a str and normalizes it a bit to make it a better filename prefix.</span>

<span class="sd">    E.g. taking a plot title and using it to derive a filename for saving the</span>
<span class="sd">    plot.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># To handle things like consecutive whitespace (e.g. &#39;x\n y&#39;)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

    <span class="n">replace_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;/&#39;</span><span class="p">:</span> <span class="s1">&#39;_&#39;</span><span class="p">,</span>
        <span class="s1">&#39;@&#39;</span><span class="p">:</span> <span class="s1">&#39;_&#39;</span><span class="p">,</span>
        <span class="s1">&#39;,&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;.&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;(&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;)&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;[&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;]&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;?&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">replace_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="c1"># Replace multiple consecutive &#39;_&#39; with a single &#39;_&#39;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;_+&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="c1"># TODO delete this and refactor code that expects this behavior to add the period</span>
    <span class="k">if</span> <span class="n">period</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="s1">&#39;.&#39;</span>

    <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="point_idx"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.point_idx">[docs]</a><span class="k">def</span> <span class="nf">point_idx</span><span class="p">(</span><span class="n">xys_to_check</span><span class="p">,</span> <span class="n">pt_xy</span><span class="p">,</span> <span class="n">swap_xy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">swap_xy</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pt_xy</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">pt_xy</span>

    <span class="n">matching_pt</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">xys_to_check</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> <span class="o">&amp;</span>
        <span class="p">(</span><span class="n">xys_to_check</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">assert</span> <span class="n">matching_pt</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">matching_pt</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="correspond_rois"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.correspond_rois">[docs]</a><span class="k">def</span> <span class="nf">correspond_rois</span><span class="p">(</span><span class="n">left_centers_or_seq</span><span class="p">,</span> <span class="o">*</span><span class="n">right_centers</span><span class="p">,</span> <span class="n">cost_fn</span><span class="o">=</span><span class="n">euclidean_dist</span><span class="p">,</span>
    <span class="n">max_cost</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">write_plots</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">left_name</span><span class="o">=</span><span class="s1">&#39;Left&#39;</span><span class="p">,</span>
    <span class="n">right_name</span><span class="o">=</span><span class="s1">&#39;Right&#39;</span><span class="p">,</span> <span class="n">name_prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">draw_on</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">connect_centers</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pairwise_plots</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pairwise_same_style</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">roi_numbers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">jitter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug_points</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">    left_centers_or_seq (list): (length n_timepoints) list of (n_rois x 2)</span>
<span class="sd">        arrays of ROI center coordinates.</span>

<span class="sd">    Returns:</span>
<span class="sd">    lr_matches: list of arrays matching ROIs in one timepoint to ROIs in the</span>
<span class="sd">        next.</span>

<span class="sd">    left_unmatched: list of arrays with ROI labels at time t,</span>
<span class="sd">        without a match at time (t + 1)</span>

<span class="sd">    right_unmatched: same as left_unmatched, but for (t + 1) with respect to t.</span>

<span class="sd">    total_costs: array of sums of costs from matching.</span>

<span class="sd">    fig: matplotlib figure handle to the figure with all ROIs on it,</span>
<span class="sd">        for modification downstream.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO doc support for ROI inputs / rewrite to expect them</span>
    <span class="c1"># (to use jaccard, etc)</span>

    <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">linear_sum_assignment</span>
    <span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>

    <span class="c1"># TODO maybe unsupport two args case to be more concise</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_centers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sequence_of_centers</span> <span class="o">=</span> <span class="n">left_centers_or_seq</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_centers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">right_centers</span> <span class="o">=</span> <span class="n">right_centers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sequence_of_centers</span> <span class="o">=</span> <span class="p">[</span><span class="n">left_centers_or_seq</span><span class="p">,</span> <span class="n">right_centers</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;wrong number of arguments&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">progress</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence_of_centers</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">10</span>
    <span class="k">if</span> <span class="n">progress</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">tqdm</span> <span class="k">import</span> <span class="n">tqdm</span>

    <span class="k">if</span> <span class="n">max_cost</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;max_cost must not be None&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;max_cost: </span><span class="si">{max_cost:.2f}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">default_two_colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence_of_centers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">pairwise_plots</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">scatter_alpha</span> <span class="o">=</span> <span class="mf">0.6</span>
        <span class="n">scatter_marker</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="s1">&#39; centers&#39;</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">(</span><span class="n">left_name</span><span class="p">,</span> <span class="n">right_name</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="n">default_two_colors</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">scatter_alpha</span> <span class="o">=</span> <span class="mf">0.8</span>
        <span class="n">scatter_marker</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">name_prefix</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sequence_of_centers</span><span class="p">))]</span>
        <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">color_palette</span><span class="p">(</span><span class="s1">&#39;hls&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence_of_centers</span><span class="p">))</span>

    <span class="c1"># TODO don&#39;t copy after removing need for flip</span>
    <span class="c1"># Copying so that flip doesn&#39;t screw with input data.</span>
    <span class="n">new_sequence_of_centers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">centers</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sequence_of_centers</span><span class="p">):</span>
        <span class="c1"># Otherwise it should be an ndarray representing centers</span>
        <span class="c1"># TODO assertion on dims in ndarray case</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">centers</span> <span class="o">=</span> <span class="n">roi_centers</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span>

        <span class="c1"># This is just to make them display right (not transposed).</span>
        <span class="c1"># Should not change any of the matching.</span>
        <span class="c1"># TODO remove need for this flip</span>
        <span class="n">new_sequence_of_centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">centers</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">sequence_of_centers</span> <span class="o">=</span> <span class="n">new_sequence_of_centers</span>

    <span class="n">fig</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
        <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">draw_on</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;black&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">draw_on</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
            <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;yellow&#39;</span>
        <span class="n">fontsize</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="n">text_x_offset</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">plot_format</span> <span class="o">=</span> <span class="s1">&#39;png&#39;</span>

        <span class="k">if</span> <span class="n">jitter</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
            <span class="n">jl</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.1</span>
            <span class="n">jh</span> <span class="o">=</span> <span class="mf">0.1</span>

    <span class="n">unmatched_left</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">unmatched_right</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">lr_matches</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_totals</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">progress</span><span class="p">:</span>
        <span class="n">centers_iter</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sequence_of_centers</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Matching ROIs across timepoints:&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">centers_iter</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sequence_of_centers</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ci</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">centers_iter</span><span class="p">):</span>
        <span class="n">left_centers</span> <span class="o">=</span> <span class="n">sequence_of_centers</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">right_centers</span> <span class="o">=</span> <span class="n">sequence_of_centers</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># TODO TODO use pdist / something else under scipy.spatial.distance?</span>
        <span class="c1"># TODO other / better ways to generate cost matrix?</span>
        <span class="c1"># pairwise jacard (would have to not take centers then)?</span>
        <span class="c1"># TODO why was there a &quot;RuntimeWarning: invalid valid encounterd in</span>
        <span class="c1"># multiply&quot; here ocassionally? it still seems like we had some left and</span>
        <span class="c1"># right centers, so idk</span>
        <span class="n">costs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">left_centers</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_centers</span><span class="p">)))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">left_centers</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">cr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">right_centers</span><span class="p">):</span>
                <span class="c1"># TODO short circuit as appropriate? better way to loop over</span>
                <span class="c1"># coords we need?</span>
                <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_fn</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">cr</span><span class="p">)</span>
                <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&#39;(iteration {ci}) fraction of costs &gt;= max_cost:&#39;,</span>
<span class="sd">                &#39;{:.3f}&#39;.format((costs &gt;= max_cost).sum() / costs.size)</span>
<span class="sd">            )</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># TODO delete. problem does not seem to be in this fn.</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        if debug_points and ci in debug_points:</span>
<span class="sd">            print(f&#39;iteration {ci}:&#39;)</span>
<span class="sd">            ln = 3</span>
<span class="sd">            for pt_info in debug_points[ci]:</span>
<span class="sd">                name = pt_info[&#39;name&#39;]</span>
<span class="sd">                xy0 = pt_info[&#39;xy0&#39;]</span>
<span class="sd">                # TODO print cost wrt this point</span>
<span class="sd">                xy1 = pt_info[&#39;xy1&#39;]</span>

<span class="sd">                # swap_xy etc b/c of flip earlier</span>
<span class="sd">                idx = point_idx(left_centers, xy0, swap_xy=True)</span>
<span class="sd">                print(f&#39;lowest {ln} costs for point {name} in &#39;</span>
<span class="sd">                    &#39;left_centers:&#39;</span>
<span class="sd">                )</span>
<span class="sd">                # TODO also print to which other points (x,y)</span>
<span class="sd">                # correspond to these ln lowest costs</span>
<span class="sd">                print(np.sort(costs[idx, :])[:ln])</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># TODO TODO TODO test that setting these to an arbitrarily large number</span>
        <span class="c1"># produces matching equivalent to setting them to max_cost here</span>
        <span class="n">costs</span><span class="p">[</span><span class="n">costs</span> <span class="o">&gt;=</span> <span class="n">max_cost</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_cost</span>

        <span class="c1"># TODO was Kellan&#39;s method of matching points not equivalent to this?</span>
        <span class="c1"># or per-timestep maybe it was (or this was better), but he also</span>
        <span class="c1"># had a way to evolve points over time (+ a particular cost)?</span>

        <span class="n">left_idx</span><span class="p">,</span> <span class="n">right_idx</span> <span class="o">=</span> <span class="n">linear_sum_assignment</span><span class="p">(</span><span class="n">costs</span><span class="p">)</span>
        <span class="c1"># Just to double-check properties I assume about the assignment</span>
        <span class="c1"># procedure.</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_idx</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">left_idx</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_idx</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">right_idx</span><span class="p">))</span>

        <span class="n">n_not_drawn</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">jitter</span><span class="p">:</span>
                <span class="n">left_jitter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">jl</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">jh</span><span class="p">,</span>
                    <span class="n">size</span><span class="o">=</span><span class="n">left_centers</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">right_jitter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">jl</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">jh</span><span class="p">,</span>
                    <span class="n">size</span><span class="o">=</span><span class="n">right_centers</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

                <span class="n">left_centers_to_plot</span> <span class="o">=</span> <span class="n">left_centers</span> <span class="o">+</span> <span class="n">left_jitter</span>
                <span class="n">right_centers_to_plot</span> <span class="o">=</span> <span class="n">right_centers</span> <span class="o">+</span> <span class="n">right_jitter</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">left_centers_to_plot</span> <span class="o">=</span> <span class="n">left_centers</span>
                <span class="n">right_centers_to_plot</span> <span class="o">=</span> <span class="n">right_centers</span>

            <span class="k">if</span> <span class="n">pairwise_plots</span><span class="p">:</span>
                <span class="c1"># TODO maybe change multiple pairwise plots to be created as</span>
                <span class="c1"># axes within one the axes from one call to subplots</span>
                <span class="n">pfig</span><span class="p">,</span> <span class="n">pax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pairwise_same_style</span><span class="p">:</span>
                    <span class="n">pmarker</span> <span class="o">=</span> <span class="n">scatter_marker</span>
                    <span class="n">c1</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">c2</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pmarker</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">c1</span> <span class="o">=</span> <span class="n">default_two_colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">c2</span> <span class="o">=</span> <span class="n">default_two_colors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">draw_on</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">pax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">draw_on</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
                    <span class="n">pax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

                <span class="n">pax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="o">*</span><span class="n">left_centers_to_plot</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">labels</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">c1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">scatter_alpha</span><span class="p">,</span>
                    <span class="n">marker</span><span class="o">=</span><span class="n">pmarker</span>
                <span class="p">)</span>
                <span class="n">pax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="o">*</span><span class="n">right_centers_to_plot</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">labels</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">c2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">scatter_alpha</span><span class="p">,</span>
                    <span class="n">marker</span><span class="o">=</span><span class="n">pmarker</span>
                <span class="p">)</span>
                <span class="n">psuffix</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{k}</span><span class="s1"> vs. {k+1}&#39;</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">name_prefix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">psuffix</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{name_prefix}</span><span class="s1"> &#39;</span> <span class="o">+</span> <span class="n">psuffix</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">title</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ptitle</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{title}</span><span class="s1">, &#39;</span> <span class="o">+</span> <span class="n">psuffix</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ptitle</span> <span class="o">=</span> <span class="n">psuffix</span>
                <span class="n">pax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">ptitle</span><span class="p">)</span>
                <span class="n">pax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="o">*</span><span class="n">left_centers_to_plot</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">labels</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="n">scatter_alpha</span><span class="p">,</span>
                <span class="n">marker</span><span class="o">=</span><span class="n">scatter_marker</span>
            <span class="p">)</span>
            <span class="c1"># TODO factor out scatter + opt numbers (internal fn?)</span>
            <span class="k">if</span> <span class="n">roi_numbers</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">left_centers_to_plot</span><span class="p">):</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">text_x_offset</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span>
                    <span class="p">)</span>

            <span class="c1"># Because generally this loop only scatterplots the left_centers,</span>
            <span class="c1"># so without this, the last set of centers would not get a</span>
            <span class="c1"># scatterplot.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sequence_of_centers</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">last_centers</span> <span class="o">=</span> <span class="n">right_centers_to_plot</span>

                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="o">*</span><span class="n">last_centers</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">labels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="n">scatter_alpha</span><span class="p">,</span>
                    <span class="n">marker</span><span class="o">=</span><span class="n">scatter_marker</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">roi_numbers</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">last_centers</span><span class="p">):</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">text_x_offset</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                            <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span>
                        <span class="p">)</span>

            <span class="k">if</span> <span class="n">connect_centers</span><span class="p">:</span>
                <span class="n">n_not_drawn</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">li</span><span class="p">,</span> <span class="n">ri</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">left_idx</span><span class="p">,</span> <span class="n">right_idx</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">costs</span><span class="p">[</span><span class="n">li</span><span class="p">,</span><span class="n">ri</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">max_cost</span><span class="p">:</span>
                        <span class="n">n_not_drawn</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">continue</span>
                        <span class="c1">#linestyle = &#39;--&#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">linestyle</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>

                    <span class="n">lc</span> <span class="o">=</span> <span class="n">left_centers_to_plot</span><span class="p">[</span><span class="n">li</span><span class="p">]</span>
                    <span class="n">rc</span> <span class="o">=</span> <span class="n">right_centers_to_plot</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span>
                    <span class="n">correspondence_line</span> <span class="o">=</span> <span class="p">([</span><span class="n">lc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rc</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">lc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rc</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">correspondence_line</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="n">linestyle</span><span class="p">,</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">pairwise_plots</span><span class="p">:</span>
                        <span class="n">pax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">correspondence_line</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="n">linestyle</span><span class="p">,</span>
                            <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

                <span class="c1"># TODO didn&#39;t i have some fn for getting filenames from things</span>
                <span class="c1"># like titles? use that if so</span>
                <span class="c1"># TODO plot format + flag to control saving + save to some</span>
                <span class="c1"># better dir</span>
                <span class="c1"># TODO separate dir for these figs? or at least place where some</span>
                <span class="c1"># of other figs currently go?</span>
                <span class="k">if</span> <span class="n">pairwise_plots</span> <span class="ow">and</span> <span class="n">write_plots</span><span class="p">:</span>
                    <span class="n">fname</span> <span class="o">=</span> <span class="n">to_filename</span><span class="p">(</span><span class="n">ptitle</span><span class="p">)</span> <span class="o">+</span> <span class="n">plot_format</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;writing to </span><span class="si">{fname}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">pfig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>

        <span class="n">k_unmatched_left</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">left_centers</span><span class="p">)))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">left_idx</span><span class="p">)</span>
        <span class="n">k_unmatched_right</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">right_centers</span><span class="p">)))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">right_idx</span><span class="p">)</span>

        <span class="c1"># TODO why is costs.min() actually 0? that seems unlikely?</span>
        <span class="n">match_costs</span> <span class="o">=</span> <span class="n">costs</span><span class="p">[</span><span class="n">left_idx</span><span class="p">,</span> <span class="n">right_idx</span><span class="p">]</span>
        <span class="n">total_cost</span> <span class="o">=</span> <span class="n">match_costs</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="n">to_unmatch</span> <span class="o">=</span> <span class="n">match_costs</span> <span class="o">&gt;=</span> <span class="n">max_cost</span>
        <span class="c1"># For checking consistent w/ draw output above</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">n_not_drawn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n_unmatched</span> <span class="o">=</span> <span class="n">to_unmatch</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">n_not_drawn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">n_not_drawn</span> <span class="o">==</span> <span class="n">n_unmatched</span><span class="p">,</span> \
                    <span class="n">f</span><span class="s1">&#39;</span><span class="si">{n_not_drawn}</span><span class="s1"> != </span><span class="si">{n_unmatched}</span><span class="s1">&#39;</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;(iteration=</span><span class="si">{ci}</span><span class="s1">) unmatched </span><span class="si">{n_unmatched}</span><span class="s1"> for exceeding&#39;</span>
                    <span class="s1">&#39; max_cost&#39;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">debug_points</span> <span class="ow">and</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">debug_points</span><span class="p">:</span>
            <span class="n">l_idxs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">r_idxs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">pt_info</span> <span class="ow">in</span> <span class="n">debug_points</span><span class="p">[</span><span class="n">ci</span><span class="p">]:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">pt_info</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
                <span class="c1"># swap_xy etc b/c of flip earlier</span>
                <span class="n">xy0</span> <span class="o">=</span> <span class="n">pt_info</span><span class="p">[</span><span class="s1">&#39;xy0&#39;</span><span class="p">]</span>
                <span class="n">xy1</span> <span class="o">=</span> <span class="n">pt_info</span><span class="p">[</span><span class="s1">&#39;xy1&#39;</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;name: </span><span class="si">{name}</span><span class="s1">, xy0: </span><span class="si">{xy0}</span><span class="s1">, xy1: </span><span class="si">{xy1}</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="n">lidx</span> <span class="o">=</span> <span class="n">point_idx</span><span class="p">(</span><span class="n">left_centers</span><span class="p">,</span> <span class="n">xy0</span><span class="p">,</span> <span class="n">swap_xy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">left_idx</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_centers</span><span class="p">)</span>

                <span class="n">midx0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">left_idx</span> <span class="o">==</span> <span class="n">lidx</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">midx0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">midx0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                    <span class="n">midx0</span> <span class="o">=</span> <span class="n">midx0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">assert</span> <span class="n">left_idx</span><span class="p">[</span><span class="n">midx0</span><span class="p">]</span> <span class="o">==</span> <span class="n">lidx</span>
                    <span class="n">lpt</span> <span class="o">=</span> <span class="n">left_centers</span><span class="p">[</span><span class="n">left_idx</span><span class="p">[</span><span class="n">midx0</span><span class="p">]]</span>
                    <span class="k">assert</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lpt</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">xy0</span>
                    <span class="c1"># since by the time debug_points are generated, point</span>
                    <span class="c1"># matching seems off, rpt will not necessarily be</span>
                    <span class="c1"># equal to lpt.</span>
                    <span class="n">rpt_idx</span> <span class="o">=</span> <span class="n">right_idx</span><span class="p">[</span><span class="n">midx0</span><span class="p">]</span>
                    <span class="n">rpt</span> <span class="o">=</span> <span class="n">right_centers</span><span class="p">[</span><span class="n">rpt_idx</span><span class="p">]</span>
                    <span class="n">mcost0</span> <span class="o">=</span> <span class="n">match_costs</span><span class="p">[</span><span class="n">midx0</span><span class="p">]</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;xy0 matched (</span><span class="si">{lidx}</span><span class="s1">:</span><span class="si">{lpt}</span><span class="s1"> -&gt; </span><span class="si">{rpt_idx}</span><span class="s1">:</span><span class="si">{rpt}</span><span class="s1">) &#39;</span>
                        <span class="n">f</span><span class="s1">&#39;at cost </span><span class="si">{mcost0:.3f}</span><span class="s1">&#39;</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">to_unmatch</span><span class="p">[</span><span class="n">midx0</span><span class="p">]:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;xy0 will be unmatched for cost &gt;= max_cost!&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">l_idxs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">lidx</span><span class="p">))</span>
                        <span class="c1"># For use debugging downstream of this function.</span>
                        <span class="n">pt_info</span><span class="p">[</span><span class="s1">&#39;xy0_lidx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lidx</span>
                        <span class="n">pt_info</span><span class="p">[</span><span class="s1">&#39;xy0_ridx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rpt_idx</span>
                        <span class="n">pt_info</span><span class="p">[</span><span class="s1">&#39;xy0_lpt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lpt</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">pt_info</span><span class="p">[</span><span class="s1">&#39;xy0_rpt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rpt</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;xy0 not matched!&#39;</span><span class="p">)</span>

                <span class="n">ridx</span> <span class="o">=</span> <span class="n">point_idx</span><span class="p">(</span><span class="n">right_centers</span><span class="p">,</span> <span class="n">xy1</span><span class="p">,</span> <span class="n">swap_xy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">right_idx</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_centers</span><span class="p">)</span>
                <span class="n">midx1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">right_idx</span> <span class="o">==</span> <span class="n">ridx</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">midx1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">midx1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                    <span class="n">midx1</span> <span class="o">=</span> <span class="n">midx1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">assert</span> <span class="n">right_idx</span><span class="p">[</span><span class="n">midx1</span><span class="p">]</span> <span class="o">==</span> <span class="n">ridx</span>
                    <span class="n">rpt</span> <span class="o">=</span> <span class="n">right_centers</span><span class="p">[</span><span class="n">right_idx</span><span class="p">[</span><span class="n">midx1</span><span class="p">]]</span>
                    <span class="k">assert</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rpt</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">xy1</span>
                    <span class="c1"># likewise, this is not necessarily equal to xy0, by the</span>
                    <span class="c1"># time downstream functions screw up propagating the matches</span>
                    <span class="n">lpt_idx</span> <span class="o">=</span> <span class="n">left_idx</span><span class="p">[</span><span class="n">midx1</span><span class="p">]</span>
                    <span class="n">lpt</span> <span class="o">=</span> <span class="n">left_centers</span><span class="p">[</span><span class="n">lpt_idx</span><span class="p">]</span>
                    <span class="n">mcost1</span> <span class="o">=</span> <span class="n">match_costs</span><span class="p">[</span><span class="n">midx1</span><span class="p">]</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;xy1 matched (</span><span class="si">{ridx}</span><span class="s1">:</span><span class="si">{rpt}</span><span class="s1"> &lt;- </span><span class="si">{lpt_idx}</span><span class="s1">:</span><span class="si">{lpt}</span><span class="s1">) &#39;</span>
                        <span class="n">f</span><span class="s1">&#39;at cost </span><span class="si">{mcost1:.3f}</span><span class="s1">&#39;</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">to_unmatch</span><span class="p">[</span><span class="n">midx1</span><span class="p">]:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;xy1 will be unmatched for cost &gt;= max_cost!&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">r_idxs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">ridx</span><span class="p">))</span>
                        <span class="c1"># For use debugging downstream of this function.</span>
                        <span class="n">pt_info</span><span class="p">[</span><span class="s1">&#39;xy1_lidx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lpt_idx</span>
                        <span class="n">pt_info</span><span class="p">[</span><span class="s1">&#39;xy1_ridx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ridx</span>
                        <span class="n">pt_info</span><span class="p">[</span><span class="s1">&#39;xy1_lpt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lpt</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">pt_info</span><span class="p">[</span><span class="s1">&#39;xy1_rpt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rpt</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;xy1 not matched!&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="n">k_unmatched_left</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">left_idx</span><span class="p">[</span><span class="n">to_unmatch</span><span class="p">])</span>
        <span class="n">k_unmatched_right</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">right_idx</span><span class="p">[</span><span class="n">to_unmatch</span><span class="p">])</span>
        <span class="n">left_idx</span> <span class="o">=</span> <span class="n">left_idx</span><span class="p">[</span><span class="o">~</span> <span class="n">to_unmatch</span><span class="p">]</span>
        <span class="n">right_idx</span> <span class="o">=</span> <span class="n">right_idx</span><span class="p">[</span><span class="o">~</span> <span class="n">to_unmatch</span><span class="p">]</span>

        <span class="n">n_unassigned</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">left_centers</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_centers</span><span class="p">))</span>

        <span class="n">total_cost</span> <span class="o">+=</span> <span class="n">max_cost</span> <span class="o">*</span> <span class="n">n_unassigned</span>
        <span class="c1"># TODO better way to normalize error?</span>
        <span class="n">total_cost</span> <span class="o">=</span> <span class="n">total_cost</span> <span class="o">/</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">left_centers</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_centers</span><span class="p">))</span>

        <span class="c1"># TODO maybe compute costs for all unmatched w/ pdist, and check</span>
        <span class="c1"># nothing is &lt; max_cost</span>

        <span class="n">unmatched_left</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">k_unmatched_left</span><span class="p">)))</span>
        <span class="n">unmatched_right</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">k_unmatched_right</span><span class="p">)))</span>
        <span class="n">cost_totals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">total_cost</span><span class="p">)</span>
        <span class="n">lr_matches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">left_idx</span><span class="p">,</span> <span class="n">right_idx</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># These just need to be consistent w/ numbers printed before colons</span>
        <span class="c1"># above (and they are).</span>
        <span class="k">if</span> <span class="n">debug_points</span> <span class="ow">and</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">debug_points</span><span class="p">:</span>
            <span class="n">lrm</span> <span class="o">=</span> <span class="n">lr_matches</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">li</span> <span class="ow">in</span> <span class="n">l_idxs</span><span class="p">:</span>
                <span class="n">midx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">lrm</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">li</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">midx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">midx</span> <span class="o">=</span> <span class="n">midx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;name: </span><span class="si">{name}</span><span class="s1">, xy0 match row </span><span class="si">{midx}</span><span class="s1">:&#39;</span><span class="p">,</span> <span class="n">lrm</span><span class="p">[</span><span class="n">midx</span><span class="p">,</span> <span class="p">:])</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">ri</span> <span class="ow">in</span> <span class="n">r_idxs</span><span class="p">:</span>
                <span class="n">midx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">lrm</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">ri</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">midx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">midx</span> <span class="o">=</span> <span class="n">midx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;name: </span><span class="si">{name}</span><span class="s1">, xy1 match row </span><span class="si">{midx}</span><span class="s1">:&#39;</span><span class="p">,</span> <span class="n">lrm</span><span class="p">[</span><span class="n">midx</span><span class="p">,</span> <span class="p">:])</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">write_plots</span><span class="p">:</span>
            <span class="c1"># TODO and delete this extra hack</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence_of_centers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">extra</span> <span class="o">=</span> <span class="s1">&#39;_acrossblocks&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">extra</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">to_filename</span><span class="p">(</span><span class="n">title</span> <span class="o">+</span> <span class="n">extra</span><span class="p">)</span> <span class="o">+</span> <span class="n">plot_format</span>
            <span class="c1">#</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;writing to </span><span class="si">{fname}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="c1">#</span>

    <span class="c1"># TODO TODO change all parts that require squeeze=True to squeeze=False?</span>
    <span class="k">if</span> <span class="n">squeeze</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence_of_centers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">lr_matches</span> <span class="o">=</span> <span class="n">lr_matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">unmatched_left</span> <span class="o">=</span> <span class="n">unmatched_left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">unmatched_right</span> <span class="o">=</span> <span class="n">unmatched_right</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cost_totals</span> <span class="o">=</span> <span class="n">cost_totals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># TODO maybe stop returning unmatched_* . not sure it&#39;s useful.</span>

    <span class="k">return</span> <span class="n">lr_matches</span><span class="p">,</span> <span class="n">unmatched_left</span><span class="p">,</span> <span class="n">unmatched_right</span><span class="p">,</span> <span class="n">cost_totals</span><span class="p">,</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="stable_rois"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.stable_rois">[docs]</a><span class="k">def</span> <span class="nf">stable_rois</span><span class="p">(</span><span class="n">lr_matches</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a list of n_cells x 2 matrices, with each row taking an integer ROI</span>
<span class="sd">    label from one set of labels to the other.</span>

<span class="sd">    Input is as first output of correspond_rois.</span>

<span class="sd">    Returns:</span>
<span class="sd">    stable_cells: a n_stable_cells x (len(lr_matches) + 1) matrix, where rows</span>
<span class="sd">        represent different labels for the same real cells. Columns have the</span>
<span class="sd">        set of stable cells IDs, labelled as the inputs are.</span>

<span class="sd">    new_lost: a (len(lr_matches) - 1) length list of IDs lost when matching</span>
<span class="sd">        lr_matches[i] to lr_matches[i + 1]. only considers IDs that had</span>
<span class="sd">        been stable across all previous pairs of matchings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO TODO also test in cases where lr_matches is greater than len 2</span>
    <span class="c1"># (at least len 3)</span>

    <span class="c1"># TODO TODO also test when lr_matches is len 1, to support that case</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lr_matches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">lr_matches</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="n">orig_matches</span> <span class="o">=</span> <span class="n">lr_matches</span>
    <span class="c1"># Just since it gets written to in the loop.</span>
    <span class="n">lr_matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">lr_matches</span><span class="p">]</span>

    <span class="n">stable</span> <span class="o">=</span> <span class="n">lr_matches</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">UNLABELLED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">new_lost</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lr_matches</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">matches1</span> <span class="o">=</span> <span class="n">lr_matches</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">matches2</span> <span class="o">=</span> <span class="n">lr_matches</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># These two columns should have the ROI / center numbers</span>
        <span class="c1"># represent the same real ROI / point coordinates.</span>
        <span class="n">stable_1to2</span><span class="p">,</span> <span class="n">m1_idx</span><span class="p">,</span> <span class="n">m2_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span>
            <span class="n">matches1</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">matches2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">matches1</span><span class="p">[</span><span class="n">m1_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">matches2</span><span class="p">[</span><span class="n">m2_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="n">curr_stable_prior_labels</span> <span class="o">=</span> <span class="n">matches1</span><span class="p">[</span><span class="n">m1_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">matches2</span><span class="p">[</span><span class="n">m2_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_stable_prior_labels</span>

        <span class="c1"># To avoid confusion / errors related too using old, now meaningless</span>
        <span class="c1"># labels.</span>
        <span class="n">not_in_m2_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matches2</span><span class="p">)),</span> <span class="n">m2_idx</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">lr_matches</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">UNLABELLED</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="n">matches2</span><span class="p">[</span><span class="n">not_in_m2_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">UNLABELLED</span> 
        <span class="k">assert</span> <span class="p">(</span><span class="n">lr_matches</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">UNLABELLED</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">not_in_m2_idx</span><span class="p">)</span>

        <span class="n">ids_lost_at_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">stable</span><span class="p">,</span> <span class="n">curr_stable_prior_labels</span><span class="p">)</span>
        <span class="n">stable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">stable</span><span class="p">,</span> <span class="n">ids_lost_at_i</span><span class="p">)</span>
        <span class="n">new_lost</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ids_lost_at_i</span><span class="p">)</span>

        <span class="n">n_lost_at_i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids_lost_at_i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">n_lost_at_i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Lost </span><span class="si">{n_lost_at_i}</span><span class="s1"> ROI(s) between blocks </span><span class="si">{i}</span><span class="s1"> and {i + 1}&#39;</span><span class="p">)</span>

    <span class="c1"># TODO make a test case where the total number of *matched* rois is</span>
    <span class="c1"># conserved at each time step, but the matching makes the length of the</span>
    <span class="c1"># ultimate stable set reduce</span>
    <span class="n">n_matched</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">-</span> <span class="p">((</span><span class="n">m</span> <span class="o">==</span> <span class="n">UNLABELLED</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">lr_matches</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">stable</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_matched</span><span class="p">)</span>

    <span class="n">stable_cells</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">matches</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lr_matches</span><span class="p">):</span>
        <span class="c1"># Because each of these columns will have been edited in the loop</span>
        <span class="c1"># above, to have labels matching the first set of center labels.</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">stable_indices_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">stable</span><span class="p">,</span> <span class="n">matches</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">assert</span> <span class="ow">not</span> <span class="n">UNLABELLED</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">[</span><span class="n">stable_indices_i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">orig_labels_stable_i</span> <span class="o">=</span> <span class="n">orig_matches</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">stable_indices_i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">stable_cells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">orig_labels_stable_i</span><span class="p">)</span>

    <span class="c1"># This last column in the last element in the last of matches</span>
    <span class="c1"># was the only column that did NOT get painted over with the new labels.</span>
    <span class="n">stable_cells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matches</span><span class="p">[</span><span class="n">stable_indices_i</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">stable_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">stable_cells</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># might be redundant...</span>
    <span class="n">stable_cells</span> <span class="o">=</span> <span class="n">stable_cells</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">stable_cells</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span> <span class="p">:]</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">stable_cells</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">stable</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">stable_cells</span><span class="p">,</span> <span class="n">new_lost</span></div>


<span class="c1"># TODO try to numba this</span>
<div class="viewcode-block" id="renumber_rois2"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.renumber_rois2">[docs]</a><span class="k">def</span> <span class="nf">renumber_rois2</span><span class="p">(</span><span class="n">matches_list</span><span class="p">,</span> <span class="n">centers_list</span><span class="p">):</span>
    <span class="n">id2frame_bounds</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">id2indices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">next_id</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">seen_at_i</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matches_list</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen_at_i</span><span class="p">:</span>
            <span class="n">seen_at_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">matches_list</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches_list</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">left</span> <span class="ow">in</span> <span class="n">seen_at_i</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="n">seen_at_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
                <span class="n">roi_indices_across_frames</span> <span class="o">=</span> <span class="p">[</span><span class="n">left</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">right</span> <span class="ow">in</span> <span class="n">seen_at_i</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="n">roi_indices_across_frames</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">first_frame</span> <span class="o">=</span> <span class="n">i</span>
            <span class="c1"># So that the frame counter increments as soon as we have one</span>
            <span class="c1"># &quot;right&quot; element (every match row must correspond to at least</span>
            <span class="c1"># two timepoints).</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches_list</span><span class="p">):</span>
                <span class="n">roi_indices_across_frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
                <span class="n">last_frame</span> <span class="o">=</span> <span class="n">j</span>

                <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">seen_at_i</span><span class="p">:</span>
                    <span class="n">seen_at_i</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">seen_at_i</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches_list</span><span class="p">):</span>
                    <span class="k">break</span>

                <span class="n">next_matches</span> <span class="o">=</span> <span class="n">matches_list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">next_row_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">next_matches</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">next_row_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="n">next_row_idx</span> <span class="o">=</span> <span class="n">next_row_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">next_matches</span><span class="p">[</span><span class="n">next_row_idx</span><span class="p">]</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">assert</span> <span class="p">(</span><span class="n">last_frame</span> <span class="o">-</span> <span class="n">first_frame</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">roi_indices_across_frames</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">id2frame_bounds</span><span class="p">[</span><span class="n">next_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_frame</span><span class="p">,</span> <span class="n">last_frame</span><span class="p">)</span>
            <span class="n">id2indices</span><span class="p">[</span><span class="n">next_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">roi_indices_across_frames</span>
            <span class="n">next_id</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches_list</span><span class="p">):</span>
            <span class="n">unmatched</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">centers_list</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span> <span class="n">m</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unmatched</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">centers_list</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span> <span class="n">m</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">unmatched</span><span class="p">:</span>
            <span class="c1"># TODO never need to check whether this is in seen, do i?</span>
            <span class="n">id2frame_bounds</span><span class="p">[</span><span class="n">next_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">id2indices</span><span class="p">[</span><span class="n">next_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span><span class="p">]</span>
            <span class="n">next_id</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">id2frame_bounds</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">id2indices</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">centers_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">centers_list</span><span class="p">),</span> <span class="n">next_id</span><span class="p">,</span>
        <span class="n">centers_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">for</span> <span class="n">roi_id</span> <span class="ow">in</span> <span class="n">id2frame_bounds</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">id2frame_bounds</span><span class="p">[</span><span class="n">roi_id</span><span class="p">]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">id2indices</span><span class="p">[</span><span class="n">roi_id</span><span class="p">]</span>
        <span class="n">centers_array</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">roi_id</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> \
            <span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">centers_list</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">indices</span><span class="p">)]</span>

    <span class="c1"># TODO assert min / max non-nan cover full frame for reasonable test data</span>

    <span class="k">return</span> <span class="n">centers_array</span></div>


<span class="c1"># TODO TODO should either this fn or correspond_rois try to handle the case</span>
<span class="c1"># where a cell drifts out of plane and then back into plane???</span>
<span class="c1"># possible? some kind of filtering?</span>
<div class="viewcode-block" id="renumber_rois"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.renumber_rois">[docs]</a><span class="k">def</span> <span class="nf">renumber_rois</span><span class="p">(</span><span class="n">matches_list</span><span class="p">,</span> <span class="n">centers_list</span><span class="p">,</span> <span class="n">debug_points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_cost</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Each sequence of matched ROIs gets an increasing integer identifier</span>
<span class="sd">    (including length-1 sequences, i.e. unmatched stuff).</span>

<span class="sd">    Returns lists of IDs in each element of input list and centers,</span>
<span class="sd">    re-indexed with new IDs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO use this function inside stable_rois / delete that function</span>
    <span class="c1"># altogether (?)</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">matches_list</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">centers_list</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;both input arguments must be lists&#39;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">centers_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches_list</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Since they get written to in the loop.</span>
    <span class="n">matches_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">matches_list</span><span class="p">]</span>
    <span class="n">centers_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">centers_list</span><span class="p">]</span>

    <span class="c1"># TODO test case where input is not == np.arange(input.max())</span>
    <span class="c1"># (both just missing some less and w/ ids beyond len(centers) - 1)</span>
    <span class="n">ids_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">first_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">centers_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">matches_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">first_ids</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="n">ids_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">first_ids</span><span class="p">)</span>
    <span class="n">next_new_id</span> <span class="o">=</span> <span class="n">first_ids</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;next_new_id (after making first_ids):&#39;</span><span class="p">,</span> <span class="n">next_new_id</span><span class="p">)</span>
    <span class="c1">##next_new_id = matches_list[0][:,0].max() + 1</span>

    <span class="c1">#if len(centers_list[0]) &gt; len(matches_list[0]):</span>
    <span class="c1">#    import ipdb; ipdb.set_trace()</span>

    <span class="c1"># TODO delete / put behind something like a `checks` flag</span>
    <span class="k">assert</span> <span class="n">max_cost</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="n">id2last_xy</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">c</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">first_ids</span><span class="p">,</span> <span class="n">centers_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,:</span><span class="mi">2</span><span class="p">])}</span>
    <span class="n">id2src_history</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span>
        <span class="p">[</span><span class="s1">&#39;first_match&#39;</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">matches_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="s1">&#39;new_first&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">first_ids</span>
    <span class="p">}</span>
    <span class="n">id2idx_history</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">first_ids</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">matches_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">id2idx_history</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">id2src_history</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">id2idx_history</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">nonshared_m2_idx_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matches_list</span><span class="p">)):</span>
        <span class="c1"># These centers are referred to by the IDs in matches_list[i + 1][:, 1],</span>
        <span class="c1"># and (if it exists) matches_list[i + 2][:, 1]</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="n">centers_list</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">matches1</span> <span class="o">=</span> <span class="n">matches_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        # This includes stuff shared and stuff lost by m2.</span>
<span class="sd">        # The only thing this should not include is stuff that should get</span>
<span class="sd">        # a new ID in m2.</span>
<span class="sd">        centers_in_m1 = matches1[:, 1]</span>

<span class="sd">        # These include both things in matches2 (those not shared with matches1)</span>
<span class="sd">        # and things we need to generate new IDs for.</span>
<span class="sd">        only_new_centers_idx = np.setdiff1d(</span>
<span class="sd">            np.arange(len(centers)),</span>
<span class="sd">            centers_in_m1</span>
<span class="sd">        )</span>
<span class="sd">        # This should be of the same length as centers and should index each</span>
<span class="sd">        # value, just in a different order.</span>
<span class="sd">        new_center_idx = np.concatenate((</span>
<span class="sd">            centers_in_m1,</span>
<span class="sd">            only_new_centers_idx</span>
<span class="sd">        ))</span>
<span class="sd">        assert np.array_equal(</span>
<span class="sd">            np.arange(len(centers)),</span>
<span class="sd">            np.unique(new_center_idx)</span>
<span class="sd">        )</span>

<span class="sd">        # We are re-ordering the centers, so that they are in the same order</span>
<span class="sd">        # as the IDs (both propagated and new) at this timestep (curr_ids).</span>
<span class="sd">        centers_list[i + 1] = centers[new_center_idx]</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># TODO TODO TODO i think this is the heart of the problem</span>
        <span class="c1"># (b/c all problem indices were in the new_ids that got cut off</span>
        <span class="c1"># when trying to fit into smaller space of nonshared_m2_idx</span>
        <span class="n">existing_ids</span> <span class="o">=</span> <span class="n">matches1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c1">#next_new_id = existing_ids.max() + 1</span>
        <span class="c1">###n_new_ids = len(only_new_centers_idx)</span>
        <span class="c1">##assert len(centers) - len(matches1) == n_new_ids</span>
        <span class="n">n_new_ids</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches1</span><span class="p">)</span>
        <span class="c1"># Not + 1 because arange does not include the endpoint.</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">next_new_id</span> <span class="o">+</span> <span class="n">n_new_ids</span>
        <span class="n">new_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">next_new_id</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ids_list</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="nb">print</span><span class="p">(</span><span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">new_ids</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">idl</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;overlap:&#39;</span><span class="p">,</span> <span class="n">overlap</span><span class="p">)</span>
                <span class="kn">import</span> <span class="nn">ipdb</span><span class="p">;</span> <span class="n">ipdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
        <span class="c1">#</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;i:&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;n_new_ids:&#39;</span><span class="p">,</span> <span class="n">n_new_ids</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;stop:&#39;</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;next_new_id:&#39;</span><span class="p">,</span> <span class="n">next_new_id</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;next_new_id - existing_ids.max():&#39;</span><span class="p">,</span>
            <span class="n">next_new_id</span> <span class="o">-</span> <span class="n">existing_ids</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">next_new_id</span> <span class="o">=</span> <span class="n">stop</span>

        <span class="n">curr_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">existing_ids</span><span class="p">,</span> <span class="n">new_ids</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_ids</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_ids</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">curr_ids</span><span class="p">))</span>

        <span class="c1"># TODO this is the necessary condition for having current centers not</span>
        <span class="c1"># get mis-ordered, right?</span>
        <span class="c1">#assert np.array_equal(np.argsort(curr_ids), np.argsort(new_center_idx))</span>
        <span class="c1">#</span>
        <span class="c1">#import ipdb; ipdb.set_trace()</span>

        <span class="c1">#&#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">_id</span><span class="p">,</span> <span class="n">cxy</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">curr_ids</span><span class="p">,</span> <span class="n">centers_list</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][:,:</span><span class="mi">2</span><span class="p">])):</span>
            <span class="k">if</span> <span class="n">_id</span> <span class="ow">in</span> <span class="n">id2last_xy</span><span class="p">:</span>
                <span class="n">last_xy</span> <span class="o">=</span> <span class="n">id2last_xy</span><span class="p">[</span><span class="n">_id</span><span class="p">]</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">euclidean_dist</span><span class="p">(</span><span class="n">cxy</span><span class="p">,</span> <span class="n">last_xy</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">max_cost</span>
                <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                    <span class="c1">#print(max_cost)</span>
                    <span class="c1">#print(dist)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;id:&#39;</span><span class="p">,</span> <span class="n">_id</span><span class="p">)</span>
                    <span class="c1">#print(last_xy)</span>
                    <span class="c1">#print(cxy)</span>
                    <span class="k">if</span> <span class="n">_id</span> <span class="ow">in</span> <span class="n">new_ids</span><span class="p">:</span>
                        <span class="n">fr</span> <span class="o">=</span> <span class="s1">&#39;new&#39;</span>
                    <span class="k">elif</span> <span class="n">_id</span> <span class="ow">in</span> <span class="n">existing_ids</span><span class="p">:</span>
                        <span class="n">fr</span> <span class="o">=</span> <span class="s1">&#39;old&#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="kc">False</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">fr</span><span class="p">)</span>

                    <span class="nb">print</span><span class="p">(</span><span class="n">id2src_history</span><span class="p">[</span><span class="n">_id</span><span class="p">])</span>
                    <span class="n">prev_idx</span> <span class="o">=</span> <span class="n">id2idx_history</span><span class="p">[</span><span class="n">_id</span><span class="p">]</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">prev_idx</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">prev_idx</span> <span class="o">=</span> <span class="n">prev_idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">prev_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="c1"># (previous entry in ids_list)</span>
                            <span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">ids_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">_id</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span>
                                <span class="n">prev_idx</span>
                            <span class="p">)</span>

                    <span class="kn">import</span> <span class="nn">ipdb</span><span class="p">;</span> <span class="n">ipdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>

            <span class="n">id2last_xy</span><span class="p">[</span><span class="n">_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">cxy</span>
            <span class="c1"># TODO delete these after debugging</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">_id</span> <span class="ow">in</span> <span class="n">id2src_history</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">_id</span> <span class="ow">in</span> <span class="n">id2idx_history</span><span class="p">)</span>
            <span class="n">src_hist</span> <span class="o">=</span> <span class="s1">&#39;new&#39;</span> <span class="k">if</span> <span class="n">_id</span> <span class="ow">in</span> <span class="n">new_ids</span> <span class="k">else</span> <span class="s1">&#39;old&#39;</span>
            <span class="k">if</span> <span class="n">_id</span> <span class="ow">in</span> <span class="n">id2src_history</span><span class="p">:</span>
                <span class="n">id2src_history</span><span class="p">[</span><span class="n">_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">src_hist</span><span class="p">)</span>
                <span class="n">id2idx_history</span><span class="p">[</span><span class="n">_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">id2src_history</span><span class="p">[</span><span class="n">_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">src_hist</span><span class="p">]</span>
                <span class="n">id2idx_history</span><span class="p">[</span><span class="n">_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="c1">#</span>
        <span class="c1">#&#39;&#39;&#39;</span>

        <span class="n">ids_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_ids</span><span class="p">)</span>

        <span class="c1"># TODO TODO TODO some assertion that re-ordered centers are still</span>
        <span class="c1"># fully equiv to old centers, when indexing as they get indexed below?</span>
        <span class="c1"># though ordering across centers is what really matters...</span>

        <span class="c1"># TODO `i` as well?</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        if debug_points and i + 1 in debug_points:</span>
<span class="sd">            print(f&#39;I + 1 = {i + 1}&#39;)</span>
<span class="sd">            for pt_info in debug_points[i + 1]:</span>
<span class="sd">                roi_id = int(pt_info[&#39;name&#39;])</span>
<span class="sd">                xy0 = pt_info[&#39;xy0&#39;]</span>
<span class="sd">                xy1 = pt_info[&#39;xy1&#39;]</span>
<span class="sd">                print(&#39;roi_id:&#39;, roi_id)</span>
<span class="sd">                print(&#39;xy0:&#39;, xy0)</span>

<span class="sd">                # TODO turn into assertion</span>
<span class="sd">                # shouldn&#39;t happen?</span>
<span class="sd">                if roi_id not in curr_ids:</span>
<span class="sd">                    print(&#39;not in curr_ids&#39;)</span>
<span class="sd">                    import ipdb; ipdb.set_trace()</span>
<span class="sd">                #</span>

<span class="sd">                if roi_id in matches1[:,0]:</span>
<span class="sd">                    print(&#39;in matches1[:,0] (old IDs)&#39;)</span>
<span class="sd">                elif roi_id in new_ids:</span>
<span class="sd">                    print(&#39;in new_ids!&#39;)</span>
<span class="sd">                else:</span>
<span class="sd">                    assert False, &#39;neither in old nor new ids&#39;</span>

<span class="sd">                id_idx = np.argmax(curr_ids == roi_id)</span>
<span class="sd">                cxy = tuple(centers_list[i + 1][id_idx][:2])</span>
<span class="sd">                assert cxy == xy0</span>
<span class="sd">                lidx = pt_info.get(&#39;xy0_lidx&#39;)</span>
<span class="sd">                if lidx is not None:</span>
<span class="sd">                    xy0_was_matched = True</span>
<span class="sd">                    lpt = pt_info.get(&#39;xy0_lpt&#39;)</span>
<span class="sd">                    # so we can still index in to the non-re-ordered centers</span>
<span class="sd">                    assert tuple(centers[lidx, :2]) == xy0</span>
<span class="sd">                    print(&#39;xy0_lidx:&#39;, lidx)</span>
<span class="sd">                else:</span>
<span class="sd">                    xy0_was_matched = False</span>

<span class="sd">                #if xy0_was_matched:</span>
<span class="sd">                #    assert</span>
<span class="sd">                #import ipdb; ipdb.set_trace()</span>

<span class="sd">            #import ipdb; ipdb.set_trace()</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches_list</span><span class="p">):</span>
            <span class="n">matches2</span> <span class="o">=</span> <span class="n">matches_list</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span>

            <span class="c1"># These two columns should have the ROI / center numbers</span>
            <span class="c1"># represent the same real ROI / point coordinates.</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">shared_m1_idx</span><span class="p">,</span> <span class="n">shared_m2_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span>
                <span class="n">matches1</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">matches2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span>
                <span class="n">matches1</span><span class="p">[</span><span class="n">shared_m1_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">matches2</span><span class="p">[</span><span class="n">shared_m2_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">prior_ids_of_shared</span> <span class="o">=</span> <span class="n">matches1</span><span class="p">[</span><span class="n">shared_m1_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">matches2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">matches2</span><span class="p">[</span><span class="n">shared_m2_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">prior_ids_of_shared</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">matches2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span>

            <span class="n">nonshared_m2_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matches2</span><span class="p">)),</span>
                <span class="n">shared_m2_idx</span>
            <span class="p">)</span>
            <span class="c1"># ROIs unmatched in matches2 get any remaining higher IDs in new_ids</span>
            <span class="c1"># It is possible for there to be new_ids without any</span>
            <span class="c1"># nonshared_m2_idx.</span>
            <span class="c1"># TODO TODO TODO will we ever need to map from these new_ids that</span>
            <span class="c1"># run off the end to specific centers later?</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;new_ids:&#39;</span><span class="p">,</span> <span class="n">new_ids</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;new_ids[:len(nonshared_m2_idx)]:&#39;</span><span class="p">,</span>
                <span class="n">new_ids</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">nonshared_m2_idx</span><span class="p">)]</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;nonshared_m2_idx:&#39;</span><span class="p">,</span> <span class="n">nonshared_m2_idx</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;matches2[nonshared_m2_idx, 0]:&#39;</span><span class="p">,</span>
                <span class="n">matches2</span><span class="p">[</span><span class="n">nonshared_m2_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="kn">import</span> <span class="nn">ipdb</span><span class="p">;</span> <span class="n">ipdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
            <span class="n">matches2</span><span class="p">[</span><span class="n">nonshared_m2_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_ids</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">nonshared_m2_idx</span><span class="p">)]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">matches2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ids_list</span><span class="p">,</span> <span class="n">centers_list</span><span class="p">)):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">cs</span><span class="p">),</span> <span class="n">f</span><span class="s1">&#39;(i=</span><span class="si">{i}</span><span class="s1">) {len(ids)} != {len(cs)}&#39;</span>

    <span class="n">centers_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">centers_list</span><span class="p">),</span> <span class="n">next_new_id</span><span class="p">,</span>
        <span class="n">centers_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">centers</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ids_list</span><span class="p">,</span> <span class="n">centers_list</span><span class="p">)):</span>
        <span class="n">centers_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">centers</span>

        <span class="k">if</span> <span class="n">debug_points</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">debug_points</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">pt_info</span> <span class="ow">in</span> <span class="n">debug_points</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">roi_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pt_info</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
                    <span class="n">xy0</span> <span class="o">=</span> <span class="n">pt_info</span><span class="p">[</span><span class="s1">&#39;xy0&#39;</span><span class="p">]</span>
                    <span class="n">cidx</span> <span class="o">=</span> <span class="n">point_idx</span><span class="p">(</span><span class="n">centers_array</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">xy0</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="n">cidx</span> <span class="o">==</span> <span class="n">roi_id</span>

    <span class="k">return</span> <span class="n">centers_array</span></div>


<div class="viewcode-block" id="roi_jumps"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.roi_jumps">[docs]</a><span class="k">def</span> <span class="nf">roi_jumps</span><span class="p">(</span><span class="n">roi_xyd</span><span class="p">,</span> <span class="n">max_cost</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns dict of first_frame -&gt; list of (x, y, str(point idx)) for each</span>
<span class="sd">    time an ROI jumps by &gt;= max_cost on consecutive frames.</span>

<span class="sd">    correspond_rois should have not matched these points.</span>

<span class="sd">    Output suitable for debug_points kwarg to correspond_rois</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">diffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">roi_xyd</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">roi_xyd</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
    <span class="c1"># to avoid NaN comparison warning on &gt;= (dists must be positive anyway)</span>
    <span class="n">dists</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dists</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">jumps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">dists</span> <span class="o">&gt;=</span> <span class="n">max_cost</span><span class="p">)</span>
    <span class="n">dists</span><span class="p">[</span><span class="n">dists</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">first_frames</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">jumps</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">debug_points</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="n">first_frames</span><span class="p">:</span>
        <span class="n">ff_rois</span> <span class="o">=</span> <span class="n">jumps</span><span class="p">[</span><span class="n">jumps</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ff</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># switching frame and roi axes so iteration is over rois</span>
        <span class="c1"># (zippable w/ ff_rois below)</span>
        <span class="n">xys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">roi_xyd</span><span class="p">[</span><span class="n">ff</span><span class="p">:</span><span class="n">ff</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">ff_rois</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
        <span class="p">)</span>
        <span class="n">ff_info</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">roi</span><span class="p">,</span> <span class="n">roi_xys</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ff_rois</span><span class="p">,</span> <span class="n">xys</span><span class="p">):</span>
            <span class="n">xy0</span><span class="p">,</span> <span class="n">xy1</span> <span class="o">=</span> <span class="n">roi_xys</span>
            <span class="n">pt_info</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">roi</span><span class="p">),</span> <span class="s1">&#39;xy0&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">xy0</span><span class="p">),</span> <span class="s1">&#39;xy1&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">xy1</span><span class="p">)}</span>
            <span class="n">ff_info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt_info</span><span class="p">)</span>
        <span class="n">debug_points</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span> <span class="o">=</span> <span class="n">ff_info</span>

    <span class="k">return</span> <span class="n">debug_points</span></div>


<span class="c1"># TODO TODO use in unit tests of roi tracking w/ some real data as input</span>
<div class="viewcode-block" id="check_no_roi_jumps"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.check_no_roi_jumps">[docs]</a><span class="k">def</span> <span class="nf">check_no_roi_jumps</span><span class="p">(</span><span class="n">roi_xyd</span><span class="p">,</span> <span class="n">max_cost</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">roi_jumps</span><span class="p">(</span><span class="n">roi_xyd</span><span class="p">,</span> <span class="n">max_cost</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span></div>


<span class="c1"># TODO TODO TODO re-enable checks!!!</span>
<div class="viewcode-block" id="correspond_and_renumber_rois"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.correspond_and_renumber_rois">[docs]</a><span class="k">def</span> <span class="nf">correspond_and_renumber_rois</span><span class="p">(</span><span class="n">roi_xyd_sequence</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">checks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_renumber_rois2</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="n">max_cost</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_cost&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">max_cost</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># TODO maybe switch to max / check current approach yields results</span>
        <span class="c1"># just as reasonable as those w/ larger max_cost</span>
        <span class="n">min_diam</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">xyd</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="k">for</span> <span class="n">xyd</span> <span class="ow">in</span> <span class="n">roi_xyd_sequence</span><span class="p">])</span>
        <span class="c1"># + 1 b/c cost == max_cost is thrown out</span>
        <span class="n">max_cost</span> <span class="o">=</span> <span class="n">min_diam</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;max_cost&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_cost</span>

    <span class="c1"># TODO fix what seems to be making correspond_rois fail in case where</span>
    <span class="c1"># diameter info is also passed in (so it can be used here and elsewhere</span>
    <span class="c1"># w/o having to toss that data first)</span>
    <span class="n">roi_xy_seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">xyd</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">xyd</span> <span class="ow">in</span> <span class="n">roi_xyd_sequence</span><span class="p">]</span>

    <span class="n">lr_matches</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">correspond_rois</span><span class="p">(</span><span class="n">roi_xy_seq</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="c1">#    verbose=debug, show=debug, write_plots=False, **kwargs</span>
        <span class="n">verbose</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">write_plots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    if debug:</span>
<span class="sd">        # For stuff plotted in correspond_rois</span>
<span class="sd">        plt.show()</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">debug_points</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;debug_points&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_renumber_rois2</span><span class="p">:</span>
        <span class="n">new_roi_xyd</span> <span class="o">=</span> <span class="n">renumber_rois2</span><span class="p">(</span><span class="n">lr_matches</span><span class="p">,</span> <span class="n">roi_xyd_sequence</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_roi_xyd</span> <span class="o">=</span> <span class="n">renumber_rois</span><span class="p">(</span><span class="n">lr_matches</span><span class="p">,</span> <span class="n">roi_xyd_sequence</span><span class="p">,</span>
            <span class="n">debug_points</span><span class="o">=</span><span class="n">debug_points</span><span class="p">,</span> <span class="n">max_cost</span><span class="o">=</span><span class="n">max_cost</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">checks</span><span class="p">:</span>
        <span class="n">check_no_roi_jumps</span><span class="p">(</span><span class="n">new_roi_xyd</span><span class="p">,</span> <span class="n">max_cost</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_roi_xyd</span></div>


<span class="c1"># TODO add nonoverlap constraint? somehow make closer to real data?</span>
<span class="c1"># TODO use this to test gui/fitting/tracking</span>
<div class="viewcode-block" id="make_test_centers"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.make_test_centers">[docs]</a><span class="k">def</span> <span class="nf">make_test_centers</span><span class="p">(</span><span class="n">initial_n</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">nt</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">frame_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">),</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">exlusion_radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">max_n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">round_</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">diam_px</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
    <span class="n">add_diameters</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># TODO maybe adapt p so it&#39;s the p over the course of the</span>
    <span class="c1"># nt steps, and derivce single timestep p from that?</span>

    <span class="k">if</span> <span class="n">exlusion_radius</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="c1"># So that we can pre-allocate the center coordinates over time</span>
    <span class="c1"># (rather than having to figure out how many were added by the end,</span>
    <span class="c1"># and then pad all the preceding arrays of centers w/ NaN)</span>
    <span class="k">if</span> <span class="n">p</span><span class="p">:</span>
        <span class="n">max_n</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">initial_n</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Don&#39;t need to allocate extra space if the number of ROIs is</span>
        <span class="c1"># deterministic.</span>
        <span class="n">max_n</span> <span class="o">=</span> <span class="n">initial_n</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="n">frame_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">frame_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">frame_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">max_coord</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># Also using this for new centers gained while iterating.</span>
    <span class="n">initial_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">max_n</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

    <span class="c1"># TODO more idiomatic numpy way to generate cumulative noise?</span>
    <span class="c1"># (if so, just repeat initial_centers to generate centers, and add the</span>
    <span class="c1"># two) (maybe not, with my constraints...)</span>
    <span class="c1"># TODO TODor generate inside the loop (only as many as non-NaN, and only</span>
    <span class="c1"># apply to non NaN)</span>
    <span class="n">xy_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">nt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_n</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">sigma</span>

    <span class="n">next_trajectory_idx</span> <span class="o">=</span> <span class="n">initial_n</span>
    <span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nt</span><span class="p">,</span> <span class="n">max_n</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">centers</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="n">initial_n</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_centers</span><span class="p">[:</span><span class="n">initial_n</span><span class="p">]</span>
    <span class="c1"># TODO should i be generating the noise differently, so that the x and y</span>
    <span class="c1"># components are not independent (so that if deviation is high in one,</span>
    <span class="c1"># it&#39;s more likely to be lower in other coordinate, to more directly</span>
    <span class="c1"># constrain the distance? maybe it&#39;s just a scaling thing though...)</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nt</span><span class="p">):</span>
        <span class="c1"># TODO maybe handle this differently...</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">and</span> <span class="n">next_trajectory_idx</span> <span class="o">==</span> <span class="n">max_n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;reached max_n (</span><span class="si">{max_n}</span><span class="s1">) on step </span><span class="si">{t}</span><span class="s1"> &#39;</span>
                <span class="n">f</span><span class="s1">&#39;(before </span><span class="si">{nt}</span><span class="s1"> requested steps&#39;</span>
            <span class="p">)</span>
            <span class="c1">#break</span>

        <span class="n">centers</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">centers</span><span class="p">[</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">xy_steps</span><span class="p">[</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># TODO make sure NaN stuff handled correctly here</span>
        <span class="c1"># The centers should stay within the imaginary frame bounds.</span>
        <span class="n">centers</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">centers</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_coord</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_coord</span>
        <span class="n">centers</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">centers</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">lose</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">max_n</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">nonnan</span> <span class="o">=</span> <span class="o">~</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">centers</span><span class="p">[</span><span class="n">t</span><span class="p">,:,</span><span class="mi">0</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;# non-nan:&#39;</span><span class="p">,</span> <span class="n">nonnan</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
            <span class="n">n_lost</span> <span class="o">=</span> <span class="p">(</span><span class="n">nonnan</span> <span class="o">&amp;</span> <span class="n">lose</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">n_lost</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;t=</span><span class="si">{t}</span><span class="s1">, losing </span><span class="si">{n_lost}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">centers</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">lose</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># TODO TODO note: if not allowed to fill NaN that come from losing</span>
        <span class="c1"># stuff, then max_n might more often limit # unique rather than #</span>
        <span class="c1"># concurrent tracks... (and that would prob make a format more close to</span>
        <span class="c1"># what i was already implementing in association code...)</span>
        <span class="c1"># maybe this all means i could benefit from a different</span>
        <span class="c1"># representation...</span>
        <span class="c1"># one more like id -&gt; (start frame, end frame, coordinates)</span>

        <span class="c1"># Currently, giving any new trajectories different indices (IDs)</span>
        <span class="c1"># from any previous trajectories, by putting them in ranges that</span>
        <span class="c1"># had so far only had NaN. As association code may be, this also</span>
        <span class="c1"># groups new ones in the next-unused-integer-indices, rather</span>
        <span class="c1"># than giving each remaining index a chance.</span>
        <span class="c1"># To justify first arg (n), imagine case where initial_n=0 and</span>
        <span class="c1"># max_n=1.</span>
        <span class="n">n_to_gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="n">max_n</span> <span class="o">-</span> <span class="n">initial_n</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_to_gain</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;t=</span><span class="si">{t}</span><span class="s1">, gaining </span><span class="si">{n_to_gain}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="n">first_ic_idx</span> <span class="o">=</span> <span class="n">next_trajectory_idx</span> <span class="o">-</span> <span class="n">initial_n</span>
            <span class="n">centers</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">next_trajectory_idx</span><span class="p">:</span><span class="n">next_trajectory_idx</span> <span class="o">+</span> <span class="n">n_to_gain</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">initial_centers</span><span class="p">[</span><span class="n">first_ic_idx</span><span class="p">:</span><span class="n">first_ic_idx</span> <span class="o">+</span> <span class="n">n_to_gain</span><span class="p">]</span>
            <span class="n">next_trajectory_idx</span> <span class="o">+=</span> <span class="n">n_to_gain</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span> <span class="o">==</span> <span class="n">nt</span>

    <span class="c1"># This seems to convert NaN to zero...</span>
    <span class="k">if</span> <span class="n">round_</span><span class="p">:</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">add_diameters</span><span class="p">:</span>
        <span class="n">roi_diams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">centers</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">diam_px</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">centers</span><span class="p">,</span> <span class="n">roi_diams</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># TODO check output is in same kind of format as output of my matching fns</span>

    <span class="k">return</span> <span class="n">centers</span></div>


<span class="c1"># Adapted from Vishal&#39;s answer at https://stackoverflow.com/questions/287871</span>
<span class="n">_color_codes</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;red&#39;</span><span class="p">:</span> <span class="s1">&#39;31&#39;</span><span class="p">,</span>
    <span class="s1">&#39;green&#39;</span><span class="p">:</span> <span class="s1">&#39;32&#39;</span><span class="p">,</span>
    <span class="s1">&#39;yellow&#39;</span><span class="p">:</span> <span class="s1">&#39;33&#39;</span><span class="p">,</span>
    <span class="s1">&#39;blue&#39;</span><span class="p">:</span> <span class="s1">&#39;34&#39;</span><span class="p">,</span>
    <span class="s1">&#39;cyan&#39;</span><span class="p">:</span> <span class="s1">&#39;36&#39;</span>
<span class="p">}</span>
<div class="viewcode-block" id="start_color"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.start_color">[docs]</a><span class="k">def</span> <span class="nf">start_color</span><span class="p">(</span><span class="n">color_name</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">color_code</span> <span class="o">=</span> <span class="n">_color_codes</span><span class="p">[</span><span class="n">color_name</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Available colors are:&#39;</span><span class="p">)</span>
        <span class="n">pprint</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">_color_codes</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">raise</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[</span><span class="si">{}</span><span class="s1">m&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">color_code</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="stop_color"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.stop_color">[docs]</a><span class="k">def</span> <span class="nf">stop_color</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[0m&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="print_color"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.print_color">[docs]</a><span class="k">def</span> <span class="nf">print_color</span><span class="p">(</span><span class="n">color_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">start_color</span><span class="p">(</span><span class="n">color_name</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">stop_color</span><span class="p">()</span></div>


<div class="viewcode-block" id="latest_trace_pickles"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.latest_trace_pickles">[docs]</a><span class="k">def</span> <span class="nf">latest_trace_pickles</span><span class="p">():</span>
    <span class="c1"># TODO say which data is searched/included in this fn</span>
    <span class="sd">&quot;&quot;&quot;Returns (date, fly, id) indexed DataFrame w/ filename and timestamp cols.</span>

<span class="sd">    Only returns rows for filenames that had the latest timestamp for the</span>
<span class="sd">    combination of index values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">vars_from_filename</span><span class="p">(</span><span class="n">tp_path</span><span class="p">):</span>
        <span class="n">final_part</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">tp_path</span><span class="p">)[</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># Note that we have lost any more precise time resolution, so an</span>
        <span class="c1"># exact search for this timestamp in database would fail.</span>
        <span class="n">n_time_chars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="s1">&#39;YYYYMMDD_HHMM&#39;</span><span class="p">)</span>
        <span class="n">run_at</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">final_part</span><span class="p">[:</span><span class="n">n_time_chars</span><span class="p">],</span>
            <span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">_%H%M&#39;</span>
        <span class="p">))</span>

        <span class="n">parts</span> <span class="o">=</span> <span class="n">final_part</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="n">date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">date_fmt_str</span><span class="p">))</span>
        <span class="n">fly_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">thorimage_id</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
        <span class="k">return</span> <span class="n">date</span><span class="p">,</span> <span class="n">fly_num</span><span class="p">,</span> <span class="n">thorimage_id</span><span class="p">,</span> <span class="n">run_at</span><span class="p">,</span> <span class="n">tp_path</span>

    <span class="c1"># TODO maybe replace w/ `recording_cols`, which is currently the same except</span>
    <span class="c1"># the first element is &#39;prep_date&#39; (maybe generalize representation to use</span>
    <span class="c1"># either? or migrate all data to using just date, change `recording_cols`,</span>
    <span class="c1"># then use here?)</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">,</span> <span class="s1">&#39;fly_num&#39;</span><span class="p">,</span> <span class="s1">&#39;thorimage_id&#39;</span><span class="p">]</span>
    <span class="n">tp_root</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">analysis_output_root</span><span class="p">(),</span> <span class="s1">&#39;trace_pickles&#39;</span><span class="p">)</span>
    <span class="n">tp_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">vars_from_filename</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">tp_root</span><span class="p">,</span> <span class="s1">&#39;*.p&#39;</span><span class="p">))]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tp_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;no trace pickles found under </span><span class="si">{tp_root}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">keys</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;run_at&#39;</span><span class="p">,</span> <span class="s1">&#39;trace_pickle_path&#39;</span><span class="p">],</span>
        <span class="n">data</span><span class="o">=</span><span class="n">tp_data</span>
    <span class="p">)</span>

    <span class="n">unique_len_before</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">keys</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">())</span>
    <span class="n">latest</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span><span class="o">.</span><span class="n">run_at</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()</span>
    <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">latest</span><span class="p">),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">keys</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">())</span> <span class="o">==</span> <span class="n">unique_len_before</span>

    <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<span class="c1"># TODO kwarg to have this replace the multiindex levels / columns values it is derived</span>
<span class="c1"># from (and thread through add_fly_id/add_recording_id)</span>
<div class="viewcode-block" id="add_group_id"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.add_group_id">[docs]</a><span class="k">def</span> <span class="nf">add_group_id</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">DataFrameOrDataArray</span><span class="p">,</span> <span class="n">group_keys</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">start_at_one</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Adds integer column to identify unique combinations of group_keys.</span>

<span class="sd">    Args:</span>
<span class="sd">        data: DataFrame or DataArray to add metadata to</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">group_keys</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_id&#39;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">data</span>
        <span class="c1"># Just to make sure we don&#39;t get SetWithCopyWarnings when assigning below.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="c1"># TODO maybe don&#39;t raise this if there are valid cases where the</span>
            <span class="c1"># assign_coords call wouldn&#39;t need the tuple RHS (with this dim value)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;must pass dim=&lt;dimension from data.dims to add group ID &#39;</span>
                <span class="s1">&#39;to&gt; for xarray input&#39;</span>
            <span class="p">)</span>

        <span class="c1"># TODO TODO TODO should i add handling for input where some coordinates in</span>
        <span class="c1"># group_keys are not associated with a dimension (as long as there are no</span>
        <span class="c1"># conflicts as to which dimension the coordinates in group_keys correspond</span>
        <span class="c1"># to...)? (if so, returned DataArray should probably move unassigned variables</span>
        <span class="c1"># to selected dimension)</span>
        <span class="c1"># or just require input has all group_keys assigned to (same) dimension?</span>

        <span class="k">assert</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">coords</span>
        <span class="c1"># Using data[n].values didn&#39;t make a difference in one test (same result).</span>
        <span class="c1"># (and didn&#39;t fix TypeError when some, but not all, group_keys are scalars, but</span>
        <span class="c1"># led to a diff TypeError. may or may not have been important those vars were</span>
        <span class="c1"># also not among coordinates)</span>
        <span class="c1">#df = pd.DataFrame({n: data[n].values for n in group_keys})</span>
        <span class="c1">#import ipdb; ipdb.set_trace()</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="n">n</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">group_keys</span><span class="p">})</span>

    <span class="n">group_numbers</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">group_keys</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span><span class="o">.</span><span class="n">ngroup</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">start_at_one</span><span class="p">:</span>
        <span class="n">group_numbers</span> <span class="o">=</span> <span class="n">group_numbers</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">df</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_numbers</span>
        <span class="k">return</span> <span class="n">df</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="c1"># Because assign_coords docs says it returns a new object</span>
            <span class="c1"># (maybe it doesn&#39;t actually copy sometimes, or there are equivalent calls</span>
            <span class="c1"># that wouldn&#39;t need to?)</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;inplace=True not supported for DataArray input&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">group_numbers</span><span class="p">)})</span></div>


<span class="c1"># TODO replace hardcoded recording_cols[:2] w/ kwarg that defaults to None where None</span>
<span class="c1"># gets replaced by current hardcoded value</span>
<div class="viewcode-block" id="add_fly_id"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.add_fly_id">[docs]</a><span class="k">def</span> <span class="nf">add_fly_id</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;fly_id&#39;</span>
    <span class="k">return</span> <span class="n">add_group_id</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">recording_cols</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="add_recording_id"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.add_recording_id">[docs]</a><span class="k">def</span> <span class="nf">add_recording_id</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;recording_id&#39;</span>
    <span class="k">return</span> <span class="n">add_group_id</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">recording_cols</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="thor2tiff"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.thor2tiff">[docs]</a><span class="nd">@thorimage_dir_input</span>
<span class="k">def</span> <span class="nf">thor2tiff</span><span class="p">(</span><span class="n">image_dir</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">output_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_basename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">output_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">if_exists</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;err&#39;</span><span class="p">,</span> <span class="n">flip_lr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">check_round_trip</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">_debug</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Converts ThorImage .raw file to .tif file in same directory</span>

<span class="sd">    Args:</span>
<span class="sd">        if_exists: &#39;load&#39;, &#39;ignore&#39;, &#39;overwrite&#39;, or &#39;err&#39;</span>

<span class="sd">        flip_lr: If True, flip the raw movie along the left/right axis, to make</span>
<span class="sd">            experiments including both left/right side data more comparable.</span>
<span class="sd">            If True/False, default output basename will be &#39;flipped.tif&#39;. If None,</span>
<span class="sd">            default output basename will remain &#39;raw.tif&#39;.</span>

<span class="sd">        check_round_trip: If True, and a TIFF was written, read it and check it is equal</span>
<span class="sd">            to data loaded from ThorImage raw.</span>

<span class="sd">    Returns an np.ndarray movie if TIFF was created OR if if_exists=&#39;load&#39; and</span>
<span class="sd">    the corresponding TIFF already exists. Returns None if if_exists=&#39;ignore&#39; and the</span>
<span class="sd">    corresponding TIFF already exists.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">if_exists_options</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;load&#39;</span><span class="p">,</span> <span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="s1">&#39;err&#39;</span><span class="p">,</span> <span class="s1">&#39;overwrite&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">if_exists</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">if_exists_options</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;if_exists must be one of </span><span class="si">{if_exists_options}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">output_name</span><span class="p">,</span> <span class="n">output_basename</span><span class="p">)]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;only pass at most one of output_name or output_basename&#39;</span><span class="p">)</span>

    <span class="n">image_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">image_dir</span><span class="p">)</span>

    <span class="c1"># TODO .tif or .tiff?</span>
    <span class="n">tiff_ext</span> <span class="o">=</span> <span class="s1">&#39;.tif&#39;</span>

    <span class="k">if</span> <span class="n">flip_lr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">default_output_basename</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;raw</span><span class="si">{tiff_ext}</span><span class="s1">&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Naming it &#39;flipped&#39; in both the cases where we do/don&#39;t flip (as long as</span>
        <span class="c1"># flip_lr is specified True/False, so other analysis can know that we at least</span>
        <span class="c1"># made the decision as to whether to flip this data, whether or not we actually</span>
        <span class="c1"># flipped it)</span>
        <span class="n">default_output_basename</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;flipped</span><span class="si">{tiff_ext}</span><span class="s1">&#39;</span>

    <span class="k">if</span> <span class="n">output_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">output_basename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output_basename</span> <span class="o">=</span> <span class="n">default_output_basename</span>

    <span class="k">if</span> <span class="n">output_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">output_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_dir</span> <span class="o">=</span> <span class="n">image_dir</span>

        <span class="c1"># TODO maybe just make it?</span>
        <span class="k">assert</span> <span class="n">isdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">),</span> <span class="n">f</span><span class="s1">&#39;output_dir=</span><span class="si">{output_dir}</span><span class="s1"> was not a directory&#39;</span>
        <span class="n">output_name</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">output_basename</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">output_name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">if_exists</span> <span class="o">==</span> <span class="s1">&#39;ignore&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;TIFF </span><span class="si">{output_name}</span><span class="s1"> already exists. Doing nothing.&#39;</span><span class="p">)</span>

            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">elif</span> <span class="n">if_exists</span> <span class="o">==</span> <span class="s1">&#39;load&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;TIFF </span><span class="si">{output_name}</span><span class="s1"> exists. Reading it (instead of raw)...&#39;</span><span class="p">,</span>
                    <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
                <span class="p">)</span>

            <span class="n">movie</span> <span class="o">=</span> <span class="n">tifffile</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">output_name</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">_debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; done&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># NOTE that if this will not returned any flipped version that might exist</span>
            <span class="c1"># UNLESS 1) it already exists, AND 2) flip_lr=False/True (not None)</span>
            <span class="c1"># TODO return as xarray? w/ flag to disable?</span>
            <span class="k">return</span> <span class="n">movie</span>

        <span class="k">elif</span> <span class="n">if_exists</span> <span class="o">==</span> <span class="s1">&#39;err&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{output_name}</span><span class="s1"> exists (set if_exists to either &#39;</span>
                <span class="s2">&quot;&#39;overwrite&#39; or &#39;ignore&#39; for other behavior&quot;</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">if_exists</span> <span class="o">==</span> <span class="s1">&#39;overwrite&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;TIFF </span><span class="si">{output_name}</span><span class="s1"> existed. Overwriting.&#39;</span><span class="p">)</span>

    <span class="c1"># TODO maybe also load metadata like fps (especially stuff, as w/ fps, that isn&#39;t</span>
    <span class="c1"># already baked into the TIFF, assuming the TIFF is saved correctly. so not</span>
    <span class="c1"># including stuff like z, c, xy), and print w/ -v flag?</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Reading raw movie...&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="n">movie</span> <span class="o">=</span> <span class="n">thor</span><span class="o">.</span><span class="n">read_movie</span><span class="p">(</span><span class="n">image_dir</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; done&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">flip_lr</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Flipping movie along left/right axis, as requested&#39;</span><span class="p">)</span>

        <span class="c1"># axis=-1 should be the X axis (in a ([z,], y, x) shape movie), and does</span>
        <span class="c1"># visually flip left/right when plotting frames.</span>
        <span class="n">movie</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">movie</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># TODO TODO try to figure out if anything can be done about tifffile using so much</span>
    <span class="c1"># memory on writing (says &quot;Killed&quot; and exits in the middle of writing when trying to</span>
    <span class="c1"># write what should be a ~5.5GB movie when i have close to 20GB of RAM free...).</span>
    <span class="c1"># maybe memory profile my own code to see if i&#39;m doing something stupid. related to</span>
    <span class="c1"># imagej=True kwarg?</span>
    <span class="c1"># TODO test read_movie on all thorimage .raw outputs i have to check which can</span>
    <span class="c1"># currently reproduce this issue</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Writing TIFF to </span><span class="si">{output_name}</span><span class="s1">...&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="n">write_tiff</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span> <span class="n">movie</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; done&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">check_round_trip</span><span class="p">:</span>
        <span class="c1"># Leaving this on verbose rather than _debug, because it could take some time</span>
        <span class="c1"># and we don&#39;t want it to become a core pare of a pipeline w/o being aware of</span>
        <span class="c1"># it.</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Reading written TIFF for round trip check...&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="n">round_tripped</span> <span class="o">=</span> <span class="n">tifffile</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">output_name</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">movie</span><span class="p">,</span> <span class="n">round_tripped</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; passed&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># TODO return as xarray? w/ flag to disable? maybe build a decorator to</span>
    <span class="c1"># automatically handle that conversion + add kwarg to toggle (how to get metadata</span>
    <span class="c1"># though...)?</span>
    <span class="k">return</span> <span class="n">movie</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Tom O&#39;Connell.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
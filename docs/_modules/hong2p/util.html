

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>hong2p.util &mdash; hong2p 0.0.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> hong2p
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../apidoc/modules.html">hong2p</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">hong2p</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>hong2p.util</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for hong2p.util</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Common functions for dealing with Thorlabs software output / stimulus metadata /</span>
<span class="sd">our databases / movies / CNMF output.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">join</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">exists</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">isdir</span><span class="p">,</span> <span class="n">getmtime</span><span class="p">,</span> <span class="n">splitext</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">platform</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">ModuleType</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">hashlib</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Generator</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Collection</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="k">as</span> <span class="nn">etree</span>
<span class="kn">from</span> <span class="nn">urllib.error</span> <span class="kn">import</span> <span class="n">URLError</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">yaml</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">tifffile</span>
<span class="kn">from</span> <span class="nn">tifffile</span> <span class="kn">import</span> <span class="n">TiffFile</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">pdist</span><span class="p">,</span> <span class="n">squareform</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">from</span> <span class="nn">hong2p</span> <span class="kn">import</span> <span class="n">matlab</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">thor</span><span class="p">,</span> <span class="n">olf</span>
<span class="kn">from</span> <span class="nn">hong2p.err</span> <span class="kn">import</span> <span class="n">NoStimulusFile</span><span class="p">,</span> <span class="n">TooManyStimulusFiles</span>
<span class="kn">from</span> <span class="nn">hong2p.types</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Pathlike</span><span class="p">,</span> <span class="n">PathPair</span><span class="p">,</span> <span class="n">Datelike</span><span class="p">,</span> <span class="n">FlyNum</span><span class="p">,</span> <span class="n">DateAndFlyNum</span><span class="p">,</span>
    <span class="n">DataFrameOrDataArray</span><span class="p">,</span> <span class="n">DataFrameOrSeries</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">hong2p.olf</span> <span class="kn">import</span> <span class="n">NO_ODOR</span>

<span class="c1"># Note: many imports were pushed down into the beginnings of the functions that</span>
<span class="c1"># use them, to reduce the number of hard dependencies.</span>


<span class="c1"># 1 to indicate computer is an acquisition computer, 0/unset otherwise.</span>
<span class="n">ACQUISITION_ENV_VAR</span> <span class="o">=</span> <span class="s1">&#39;HONG2P_ACQUISITION&#39;</span>

<div class="viewcode-block" id="is_acquisition_host"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.is_acquisition_host">[docs]</a><span class="k">def</span> <span class="nf">is_acquisition_host</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">_is_acquisition_host</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">ACQUISITION_ENV_VAR</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="n">ACQUISITION_ENV_VAR</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span>
            <span class="n">_is_acquisition_host</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">val</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
            <span class="n">_is_acquisition_host</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;invalid value </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s1"> for </span><span class="si">{</span><span class="n">ACQUISITION_ENV_VAR</span><span class="si">}</span><span class="s1">. must be &#39;</span>
                <span class="s1">&#39;0 or 1.&#39;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Returns the system/OS name, such as &#39;Linux&#39;,&#39;Darwin&#39;,&#39;Windows&#39;</span>
        <span class="k">if</span> <span class="n">platform</span><span class="o">.</span><span class="n">system</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;Windows&#39;</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;assuming this is an acquisition computer because it is &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;windows. set </span><span class="si">{</span><span class="n">ACQUISITION_ENV_VAR</span><span class="si">}</span><span class="s1"> to 0/1 to silence this.&#39;</span>
            <span class="p">)</span>
            <span class="n">_is_acquisition_host</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">_is_acquisition_host</span></div>


<span class="c1"># These three environment variables are in priority order (if first defined, it will be</span>
<span class="c1"># the one used).</span>
<span class="n">DATA_ROOT_ENV_VAR</span> <span class="o">=</span> <span class="s1">&#39;HONG2P_DATA&#39;</span>
<span class="n">NAS_PREFIX_ENV_VAR</span> <span class="o">=</span> <span class="s1">&#39;HONG_NAS&#39;</span>

<span class="c1"># If NAS_PREFIX_ENV_VAR is selected (i.e. DATA_ROOT_ENV_VAR is not defined), this is</span>
<span class="c1"># used to find a path on the NAS that would be suiteable as a value for</span>
<span class="c1"># DATA_ROOT_ENV_VAR (it&#39;s where I put my data on the NAS).</span>
<span class="n">NAS_PATH_TO_HONG2P_DATA</span> <span class="o">=</span> <span class="s1">&#39;mb_team&#39;</span>

<span class="c1"># Sets optional faster-storage directory that is checked first (currently just in</span>
<span class="c1"># `raw_fly_dir`).</span>
<span class="n">FAST_DATA_ROOT_ENV_VAR</span> <span class="o">=</span> <span class="s1">&#39;HONG2P_FAST_DATA&#39;</span>

<span class="n">STIMFILE_DIR_ENV_VAR</span> <span class="o">=</span> <span class="s1">&#39;HONG2P_STIMFILE_DIR&#39;</span>

<span class="n">_fast_data_root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Path</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">FAST_DATA_ROOT_ENV_VAR</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">FAST_DATA_ROOT_ENV_VAR</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span> <span class="k">else</span> <span class="kc">None</span>
<span class="p">)</span>
<span class="k">if</span> <span class="n">_fast_data_root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_fast_data_root</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>
    <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">FAST_DATA_ROOT_ENV_VAR</span><span class="si">}</span><span class="s1"> set but is not a directory&#39;</span><span class="p">)</span>

<span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># TODO maybe move all of these to __init__.py, or at least expose them there?</span>
<span class="c1"># or maybe to a hong2p.py module (maybe importing all of its contents in</span>
<span class="c1"># __init__.py ?)</span>
<span class="c1"># TODO migrate all &#39;prep_date&#39; -&gt; &#39;date&#39;? (seems i already use &#39;date&#39; in a lot</span>
<span class="c1"># of places...)</span>
<span class="n">recording_cols</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1"># TODO delete after refactoring all code that used this / add_fly_id</span>
    <span class="c1">#&#39;prep_date&#39;,</span>
    <span class="s1">&#39;date&#39;</span><span class="p">,</span>
    <span class="s1">&#39;fly_num&#39;</span><span class="p">,</span>
    <span class="s1">&#39;thorimage_id&#39;</span>
<span class="p">]</span>
<span class="c1"># TODO delete [/ update to (&#39;panel&#39;, &#39;odor1&#39;, &#39;odor2&#39;, &#39;repeat&#39;)]</span>
<span class="n">trial_only_cols</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;comparison&#39;</span><span class="p">,</span>
    <span class="s1">&#39;name1&#39;</span><span class="p">,</span>
    <span class="s1">&#39;name2&#39;</span><span class="p">,</span>
    <span class="s1">&#39;repeat_num&#39;</span>
<span class="p">]</span>
<span class="n">trial_cols</span> <span class="o">=</span> <span class="n">recording_cols</span> <span class="o">+</span> <span class="n">trial_only_cols</span>

<span class="n">date_fmt_str</span> <span class="o">=</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span>
<span class="n">dff_latex</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;$\frac{\Delta F}</span><span class="si">{F}</span><span class="s1">$&#39;</span>


<span class="c1"># Module level cache.</span>
<span class="n">_data_root</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1"># TODO add _fast_data_root setting as kwarg here?</span>
<div class="viewcode-block" id="set_data_root"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.set_data_root">[docs]</a><span class="k">def</span> <span class="nf">set_data_root</span><span class="p">(</span><span class="n">new_data_root</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Sets data root, so future calls to `data_root` will return the input.</span>

<span class="sd">    You may either use this function or set one of the environment variables</span>
<span class="sd">    that the `data_root` function checks.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_data_root</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">isdir</span><span class="p">(</span><span class="n">new_data_root</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">new_data_root</span><span class="si">}</span><span class="s1"> is not a directory!&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">_data_root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;data_root was already defined. usually set_data_root &#39;</span>
            <span class="s1">&#39;should only need to be called once.&#39;</span>
        <span class="p">)</span>

    <span class="n">_data_root</span> <span class="o">=</span> <span class="n">new_data_root</span></div>


<div class="viewcode-block" id="data_root"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.data_root">[docs]</a><span class="k">def</span> <span class="nf">data_root</span><span class="p">(</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
    <span class="k">global</span> <span class="n">_data_root</span>

    <span class="k">if</span> <span class="n">_data_root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># TODO print priority order of these env vars in any failure below</span>
        <span class="c1"># TODO TODO refactor (to loop, w/ break, probably) to also check if directories</span>
        <span class="c1"># exist before picking one to use?</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">DATA_ROOT_ENV_VAR</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">:</span>
            <span class="n">data_root_val</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="n">DATA_ROOT_ENV_VAR</span><span class="p">]</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">data_root_val</span><span class="p">)</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">DATA_ROOT_ENV_VAR</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;found </span><span class="si">{</span><span class="n">DATA_ROOT_ENV_VAR</span><span class="si">}</span><span class="s1">=</span><span class="si">{</span><span class="n">data_root_val</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">NAS_PREFIX_ENV_VAR</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">:</span>
            <span class="n">nas_prefix</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="n">NAS_PREFIX_ENV_VAR</span><span class="p">]</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">nas_prefix</span><span class="p">)</span> <span class="o">/</span> <span class="n">NAS_PATH_TO_HONG2P_DATA</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">NAS_PREFIX_ENV_VAR</span>

            <span class="c1"># TODO set flag if we are using NAS and only raise IOPerformanceWarning if</span>
            <span class="c1"># we actually try to load anything other than stimfiles from it</span>
            <span class="c1"># (assuming that if set via any other variables, it&#39;s at least fast enough</span>
            <span class="c1"># to not need warning, whether from the *_FAST_* variable or not)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;did not find </span><span class="si">{</span><span class="n">DATA_ROOT_ENV_VAR</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;found </span><span class="si">{</span><span class="n">NAS_PREFIX_ENV_VAR</span><span class="si">}</span><span class="s1">=</span><span class="si">{</span><span class="n">nas_prefix</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;either set one of the environment variables &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">DATA_ROOT_ENV_VAR</span><span class="si">}</span><span class="s1"> or </span><span class="si">{</span><span class="n">NAS_PREFIX_ENV_VAR</span><span class="si">}</span><span class="s1">) or call &#39;</span>
                <span class="s1">&#39;hong2p.util.set_data_root(&lt;data root&gt;) before this data_root call&#39;</span>
            <span class="p">)</span>

        <span class="n">_data_root</span> <span class="o">=</span> <span class="n">root</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_data_root</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;data root expected at </span><span class="si">{</span><span class="n">_data_root</span><span class="si">}</span><span class="s1">, but no directory exists&#39;</span>
                <span class="sa">f</span><span class="s1">&#39; there!</span><span class="se">\n</span><span class="s1">Directory chosen from environment variable </span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>

    <span class="c1"># TODO err if nothing in data_root, saying which env var to set and how</span>
    <span class="k">return</span> <span class="n">_data_root</span></div>


<div class="viewcode-block" id="check_dir_exists"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.check_dir_exists">[docs]</a><span class="k">def</span> <span class="nf">check_dir_exists</span><span class="p">(</span><span class="n">fn_returning_dir</span><span class="p">):</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">fn_returning_dir</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">optionally_checked_fn_returning_dir</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">create</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">directory</span> <span class="o">=</span> <span class="n">fn_returning_dir</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">isdir</span><span class="p">(</span><span class="n">directory</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">create</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Creating directory </span><span class="si">{</span><span class="n">directory</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="c1"># This will error if `directory` points to something that exists that</span>
                <span class="c1"># is NOT a directory (as intended).</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">directory</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">check</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;directory </span><span class="si">{</span><span class="n">directory</span><span class="si">}</span><span class="s1"> (returned by &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">fn_returning_dir</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">) does not exist! check the relevant &#39;</span>
                    <span class="s1">&#39;environment variables are set correctly.&#39;</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">directory</span>

    <span class="k">return</span> <span class="n">optionally_checked_fn_returning_dir</span></div>


<span class="c1"># TODO (for both below) support a local and a remote one ([optional] local copy</span>
<span class="c1"># for faster repeat analysis)?</span>
<span class="c1"># TODO use env var like kc_analysis currently does for prefix after refactoring</span>
<span class="c1"># (include mb_team in that part and rename from data_root?)</span>
<div class="viewcode-block" id="raw_data_root"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.raw_data_root">[docs]</a><span class="nd">@check_dir_exists</span>
<span class="k">def</span> <span class="nf">raw_data_root</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Pathlike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>

    <span class="c1"># TODO TODO also default to _fast_data_root?</span>

    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">data_root</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">root</span> <span class="o">/</span> <span class="s1">&#39;raw_data&#39;</span></div>


<span class="c1"># TODO kwarg / default to makeing dir if not exist (and for similar fns above)?</span>
<div class="viewcode-block" id="analysis_intermediates_root"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.analysis_intermediates_root">[docs]</a><span class="nd">@check_dir_exists</span>
<span class="k">def</span> <span class="nf">analysis_intermediates_root</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
    <span class="c1"># TODO probably prefer using $HONG2P_DATA over os.getcwd() (assuming it&#39;s not on NAS</span>
    <span class="c1"># and it therefore acceptably fast if not instead using $HONG_NAS)</span>
    <span class="k">if</span> <span class="n">_fast_data_root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;environment variable </span><span class="si">{</span><span class="n">FAST_DATA_ROOT_ENV_VAR</span><span class="si">}</span><span class="s1"> not set, so &#39;</span>
            <span class="s1">&#39;storing analysis intermediates under current directory&#39;</span>
        <span class="p">)</span>
        <span class="n">intermediates_root_parent</span> <span class="o">=</span> <span class="n">Path</span><span class="o">.</span><span class="n">cwd</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">intermediates_root_parent</span> <span class="o">=</span> <span class="n">_fast_data_root</span>

    <span class="n">intermediates_root</span> <span class="o">=</span> <span class="n">intermediates_root_parent</span> <span class="o">/</span> <span class="s1">&#39;analysis_intermediates&#39;</span>
    <span class="k">return</span> <span class="n">intermediates_root</span></div>


<div class="viewcode-block" id="stimfile_root"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.stimfile_root">[docs]</a><span class="nd">@check_dir_exists</span>
<span class="k">def</span> <span class="nf">stimfile_root</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">STIMFILE_DIR_ENV_VAR</span><span class="p">,</span>
        <span class="n">data_root</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">/</span> <span class="s1">&#39;stimulus_data_files&#39;</span>
    <span class="p">))</span></div>


<span class="c1"># TODO replace this w/ above (need to change kc_natural_mixes / natural_odors, or at</span>
<span class="c1"># least pin an older version of hong2p for them)</span>
<div class="viewcode-block" id="analysis_output_root"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.analysis_output_root">[docs]</a><span class="nd">@check_dir_exists</span>
<span class="k">def</span> <span class="nf">analysis_output_root</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">data_root</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">/</span> <span class="s1">&#39;analysis_output&#39;</span></div>


<div class="viewcode-block" id="IOPerformanceWarning"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.IOPerformanceWarning">[docs]</a><span class="k">class</span> <span class="nc">IOPerformanceWarning</span><span class="p">(</span><span class="ne">Warning</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Warning that data does not seem to be read/written from fast storage</span>
<span class="sd">    &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="format_date"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.format_date">[docs]</a><span class="k">def</span> <span class="nf">format_date</span><span class="p">(</span><span class="n">date</span><span class="p">:</span> <span class="n">Datelike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a pandas Timestamp or something that can be used to construct one</span>
<span class="sd">    and returns a str with the formatted date.</span>

<span class="sd">    Used to name directories by date, etc.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">date</span><span class="p">)</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">date_fmt_str</span><span class="p">)</span></div>


<div class="viewcode-block" id="format_timestamp"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.format_timestamp">[docs]</a><span class="k">def</span> <span class="nf">format_timestamp</span><span class="p">(</span><span class="n">timestamp</span><span class="p">:</span> <span class="n">Datelike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="c1"># TODO example of when this should be used. maybe explicitly say use</span>
    <span class="c1"># `format_date` for dates</span>
    <span class="sd">&quot;&quot;&quot;Returns human-readable str for timestamp accepted by `pd.Timestamp`, to minute.</span>

<span class="sd">    Ex: &#39;2022-04-07 16:53&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">timestamp</span><span class="p">))[:</span><span class="mi">16</span><span class="p">]</span></div>


<span class="c1"># TODO maybe rename to [get_]fly_basedir?</span>
<div class="viewcode-block" id="get_fly_dir"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.get_fly_dir">[docs]</a><span class="k">def</span> <span class="nf">get_fly_dir</span><span class="p">(</span><span class="n">date</span><span class="p">:</span> <span class="n">Datelike</span><span class="p">,</span> <span class="n">fly</span><span class="p">:</span> <span class="n">FlyNum</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns str path fragment as YYYY-MM-DD/&lt;n&gt; for variety of input types</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">date</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">date</span> <span class="o">=</span> <span class="n">format_date</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">fly</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">fly</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">fly</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">Path</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly</span><span class="p">)</span></div>


<div class="viewcode-block" id="raw_fly_dir"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.raw_fly_dir">[docs]</a><span class="k">def</span> <span class="nf">raw_fly_dir</span><span class="p">(</span><span class="n">date</span><span class="p">:</span> <span class="n">Datelike</span><span class="p">,</span> <span class="n">fly</span><span class="p">:</span> <span class="n">FlyNum</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">warn</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">short</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        short: If True, returns in format YYYY-MM-DD/&lt;fly #&gt;/&lt;ThorImage dir&gt;, without</span>
<span class="sd">            the prefix specifying the full path. Intended for creating more readable</span>
<span class="sd">            paths, where absolute paths are not required.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">raw_fly_basedir</span> <span class="o">=</span> <span class="n">get_fly_dir</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly</span><span class="p">)</span>

    <span class="c1"># TODO TODO maybe refactor for more granularity (might need to change a lot of usage</span>
    <span class="c1"># of data_root() and stuff that uses it though... perhaps also functions that</span>
    <span class="c1"># operate on directories like the fn to pair thor dirs)</span>
    <span class="c1"># TODO TODO move this logic into raw_data_root?</span>
    <span class="k">if</span> <span class="n">_fast_data_root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fast_raw_fly_dir</span> <span class="o">=</span> <span class="n">raw_data_root</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="n">_fast_data_root</span><span class="p">)</span> <span class="o">/</span> <span class="n">raw_fly_basedir</span>
        <span class="k">if</span> <span class="n">fast_raw_fly_dir</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">fast_raw_fly_dir</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">warn</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">FAST_DATA_ROOT_ENV_VAR</span><span class="si">}</span><span class="s1"> set (</span><span class="si">{</span><span class="n">_fast_data_root</span><span class="si">}</span><span class="s1">) but &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;raw data directory for fly (</span><span class="si">{</span><span class="n">date</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">fly</span><span class="si">}</span><span class="s1">) did not exist there&#39;</span><span class="p">,</span>
                    <span class="n">IOPerformanceWarning</span>
                <span class="p">)</span>

    <span class="k">return</span> <span class="n">raw_data_root</span><span class="p">()</span> <span class="o">/</span> <span class="n">raw_fly_basedir</span></div>


<div class="viewcode-block" id="thorimage_dir"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.thorimage_dir">[docs]</a><span class="k">def</span> <span class="nf">thorimage_dir</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly</span><span class="p">,</span> <span class="n">thorimage_id</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">raw_fly_dir</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">/</span> <span class="n">thorimage_id</span></div>


<div class="viewcode-block" id="thorsync_dir"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.thorsync_dir">[docs]</a><span class="k">def</span> <span class="nf">thorsync_dir</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly</span><span class="p">,</span> <span class="n">base_thorsync_dir</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">raw_fly_dir</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">/</span> <span class="n">base_thorsync_dir</span></div>


<span class="c1"># TODO test (also test w/ some that should be under fast data root)</span>
<div class="viewcode-block" id="thorimage_dir_input"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.thorimage_dir_input">[docs]</a><span class="k">def</span> <span class="nf">thorimage_dir_input</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wraps functions taking ThorImage path and adds option to call via fly keys</span>

<span class="sd">    Fly keys are (date, fly_num, thorimage_id)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped_fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">date</span><span class="p">,</span> <span class="n">fly</span><span class="p">,</span> <span class="n">thorimage_id</span> <span class="o">=</span> <span class="n">args</span>

            <span class="c1"># TODO is this getting fast dir when it is available?</span>
            <span class="n">image_dir</span> <span class="o">=</span> <span class="n">thorimage_dir</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly</span><span class="p">,</span> <span class="n">thorimage_id</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">image_dir</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO maybe just check if dir args[0] exists / if args[0:3] are all</span>
            <span class="c1"># parseable, and then pass thru any remaining args? or would it get too</span>
            <span class="c1"># complicated for too little benefit?</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;functions wrapped with thorimage_dir_input must be &#39;</span>
                <span class="s1">&#39;passed either date, fly_num, thorimage_id OR thorimage_dir&#39;</span>
            <span class="p">)</span>

        <span class="c1"># TODO also convert to Path, to avoid need in any wrapped fns?</span>

        <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="n">image_dir</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapped_fn</span></div>


<span class="c1"># TODO use new name in al_pair_grids + also handle fast data dir here.</span>
<span class="c1"># (maybe always returning directories under fast? or kwarg to behave that way?)</span>
<div class="viewcode-block" id="analysis_fly_dir"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.analysis_fly_dir">[docs]</a><span class="k">def</span> <span class="nf">analysis_fly_dir</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">analysis_output_root</span><span class="p">()</span> <span class="o">/</span> <span class="n">get_fly_dir</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly</span><span class="p">)</span></div>


<span class="c1"># TODO maybe this should stay returning a str? i&#39;m assuming a lot of what i do with this</span>
<span class="c1"># is print it / format it? or change to Path to be consistent w/ other path fns now?</span>
<div class="viewcode-block" id="shorten_path"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.shorten_path">[docs]</a><span class="k">def</span> <span class="nf">shorten_path</span><span class="p">(</span><span class="n">full_path</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns a string containing just the last `n` parts of input path.</span>

<span class="sd">    For making IDs / easier-to-read paths, when the full path isn&#39;t required.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s1">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="n">full_path</span><span class="p">)</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="p">:])</span></div>


<div class="viewcode-block" id="print_thor_paths"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.print_thor_paths">[docs]</a><span class="k">def</span> <span class="nf">print_thor_paths</span><span class="p">(</span><span class="n">image_dir</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">,</span> <span class="n">sync_dir</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">,</span> <span class="n">print_full_paths</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

    <span class="k">if</span> <span class="n">print_full_paths</span><span class="p">:</span>
        <span class="n">image_dir_toprint</span> <span class="o">=</span> <span class="n">image_dir</span>
        <span class="n">sync_dir_toprint</span> <span class="o">=</span> <span class="n">sync_dir</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">image_dir_toprint</span> <span class="o">=</span> <span class="n">shorten_path</span><span class="p">(</span><span class="n">image_dir</span><span class="p">)</span>
        <span class="n">sync_dir_toprint</span> <span class="o">=</span> <span class="n">shorten_path</span><span class="p">(</span><span class="n">sync_dir</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;thorimage_dir:&#39;</span><span class="p">,</span> <span class="n">image_dir_toprint</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;thorsync_dir:&#39;</span><span class="p">,</span> <span class="n">sync_dir_toprint</span><span class="p">)</span></div>


<span class="c1"># TODO maybe rename suffix here / thor.pair_thor_subdirs(-&gt;_dirs) for</span>
<span class="c1"># consistency. i think i was already thinking consolidating/renaming those two</span>
<span class="c1"># thor functions</span>
<span class="c1"># TODO maybe it would be better to have this return a data frame? maybe add</span>
<span class="c1"># another fn that converts output of this to that?</span>
<span class="c1"># TODO maybe also allow specification of optional third/additional keys to</span>
<span class="c1"># restrict to only some thorimage / thorsync dirs for a subset? or maybe it&#39;d</span>
<span class="c1"># make more sense to add other functions for blacklisting/whitelisting stuff?</span>
<span class="c1"># TODO TODO function like this but that returns everything, with kwargs for only getting</span>
<span class="c1"># stuff between a start and end date (w/ end date not specified as well, for analyzing</span>
<span class="c1"># ongoing experiments)</span>
<div class="viewcode-block" id="date_fly_list2paired_thor_dirs"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.date_fly_list2paired_thor_dirs">[docs]</a><span class="k">def</span> <span class="nf">date_fly_list2paired_thor_dirs</span><span class="p">(</span><span class="n">date_fly_list</span><span class="p">,</span> <span class="n">n_first</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">print_full_paths</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">pair_kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">DateAndFlyNum</span><span class="p">,</span> <span class="n">PathPair</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span>
    <span class="kc">None</span><span class="p">]:</span>
    <span class="c1"># TODO add code example to doc</span>
    <span class="sd">&quot;&quot;&quot;Takes list of (date, fly_num) tuples to pairs of their Thor outputs.</span>

<span class="sd">    Args:</span>
<span class="sd">        date_fly_list (list of (date-like, int)): (date, fly number) tuples</span>

<span class="sd">        n_first (None | int): If passed, only up to this many of pairs are enumerated.</span>
<span class="sd">            Intended for testing on subsets of data.</span>

<span class="sd">        verbose (bool): (default=False) If True, prints the fly/ThorImage/ThorSync</span>
<span class="sd">            directories as they are being iterated over.</span>

<span class="sd">        **pair_kwargs: Passed through to `thor.pair_thor_subdirs`. See arguments to</span>
<span class="sd">            `thor.pair_thor_dirs` (called by `thor.pair_thor_subdirs`) for most of the</span>
<span class="sd">            useful options.</span>

<span class="sd">    Each output is of the form:</span>
<span class="sd">    ((date, fly_num), (thorimage_dir&lt;i&gt;, thorsync_dir&lt;i&gt;))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n_first</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;only returning first </span><span class="si">{</span><span class="n">n_first</span><span class="si">}</span><span class="s1"> paired Thor[Image/Sync] outputs&#39;</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">date</span><span class="p">,</span> <span class="n">fly_num</span> <span class="ow">in</span> <span class="n">date_fly_list</span><span class="p">:</span>
        <span class="n">fly_dir</span> <span class="o">=</span> <span class="n">raw_fly_dir</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly_num</span><span class="p">)</span>

        <span class="c1"># TODO if verbose and ignore is in pair_kwargs, maybe thread some other</span>
        <span class="c1"># arguments through such that we can have the inner function print just which</span>
        <span class="c1"># pairs it is ignoring? (or [opt to] return them from pair_thor_subdirs and then</span>
        <span class="c1"># print here?)</span>

        <span class="n">paired_thor_dirs</span> <span class="o">=</span> <span class="n">thor</span><span class="o">.</span><span class="n">pair_thor_subdirs</span><span class="p">(</span><span class="n">fly_dir</span><span class="p">,</span> <span class="o">**</span><span class="n">pair_kwargs</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">image_dir</span><span class="p">,</span> <span class="n">sync_dir</span> <span class="ow">in</span> <span class="n">paired_thor_dirs</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">n_first</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">n_first</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">print_thor_paths</span><span class="p">(</span><span class="n">image_dir</span><span class="p">,</span> <span class="n">sync_dir</span><span class="p">,</span> <span class="n">print_full_paths</span><span class="o">=</span><span class="n">print_full_paths</span><span class="p">)</span>

            <span class="k">yield</span> <span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly_num</span><span class="p">),</span> <span class="p">(</span><span class="n">image_dir</span><span class="p">,</span> <span class="n">sync_dir</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span></div>


<span class="c1"># TODO TODO merge date_fly_list2paired_thor_dirs into this or just delete that and add</span>
<span class="c1"># kwarg here to replace above (too similar)</span>
<div class="viewcode-block" id="paired_thor_dirs"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.paired_thor_dirs">[docs]</a><span class="k">def</span> <span class="nf">paired_thor_dirs</span><span class="p">(</span><span class="n">matching_substrs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">start_date</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Datelike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">end_date</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Datelike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_first</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">skip_redone</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">print_skips</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">print_fast</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">print_full_paths</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">pair_kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">DateAndFlyNum</span><span class="p">,</span> <span class="n">PathPair</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="c1"># TODO add code example to doc</span>
    <span class="sd">&quot;&quot;&quot;Generates tuples of fly metadata and ThorImage output paths, in acquisition order</span>

<span class="sd">    Args:</span>
<span class="sd">        matching_substrs: If passed, only experiments whose ThorImage path contains at</span>
<span class="sd">            least one of these substring will be included.</span>

<span class="sd">        n_first: If passed, only up to this many of pairs are enumerated.</span>
<span class="sd">            Intended for testing on subsets of data.</span>

<span class="sd">        verbose: If True, prints the fly/ThorImage/ThorSync directories as they are</span>
<span class="sd">            being iterated over.</span>

<span class="sd">        **pair_kwargs: Passed through to `thor.pair_thor_subdirs`. See arguments to</span>
<span class="sd">            `thor.pair_thor_dirs` (called by `thor.pair_thor_subdirs`) for most of the</span>
<span class="sd">            useful options.</span>

<span class="sd">    Each output is of the form:</span>
<span class="sd">    ((date, fly_num), (thorimage_dir&lt;i&gt;, thorsync_dir&lt;i&gt;))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n_first</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;only returning first </span><span class="si">{</span><span class="n">n_first</span><span class="si">}</span><span class="s1"> paired Thor[Image/Sync] outputs&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">start_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">start_date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">start_date</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">end_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">end_date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">end_date</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">grandchildren</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="c1"># Returns without the trailing &#39;/&#39; glob would normally add using this syntax.</span>
        <span class="c1"># TODO replace join w/ pathlib alternative</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">split</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s1">&#39;*/*/&#39;</span><span class="p">))]</span>

    <span class="k">def</span> <span class="nf">date_fly_parts</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="n">rest</span><span class="p">,</span> <span class="n">fly_part</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">date_part</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">date_part</span><span class="p">,</span> <span class="n">fly_part</span>

    <span class="k">if</span> <span class="n">_fast_data_root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">candidate_grandchildren</span> <span class="o">=</span> <span class="n">grandchildren</span><span class="p">(</span><span class="n">raw_data_root</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="n">_fast_data_root</span><span class="p">))</span>
        <span class="n">fast_parts</span> <span class="o">=</span> <span class="p">{</span><span class="n">date_fly_parts</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">candidate_grandchildren</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">candidate_grandchildren</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Set of tuples representing deepest-level (&quot;leaf&quot;) directories under</span>
        <span class="c1"># `_fast_data_root`.</span>
        <span class="n">fast_parts</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">gs</span> <span class="o">=</span> <span class="n">grandchildren</span><span class="p">(</span><span class="n">raw_data_root</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gs</span><span class="p">:</span>
        <span class="n">date_fly</span> <span class="o">=</span> <span class="n">date_fly_parts</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">date_fly</span> <span class="ow">in</span> <span class="n">fast_parts</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">print_fast</span><span class="p">:</span>
                <span class="c1"># TODO maybe just warn for any we aren&#39;t using fast for (assuming we are</span>
                <span class="c1"># using fast for *any*), and generally don&#39;t print</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;not using </span><span class="si">{</span><span class="n">g</span><span class="si">}</span><span class="s1"> because had equivalent fast dir under &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">_fast_data_root</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="p">)</span>

            <span class="k">continue</span>
        <span class="n">candidate_grandchildren</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

    <span class="c1"># Sorting on (date, fly) parts (to the extent that&#39;s what they are)</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">candidate_grandchildren</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">g</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]):</span>
        <span class="n">date_part</span><span class="p">,</span> <span class="n">fly_part</span> <span class="o">=</span> <span class="n">date_fly_parts</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">fly_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fly_part</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">print_skips</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;skipping </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s1"> because could not parse fly_num from </span><span class="si">{</span><span class="n">fly_part</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">continue</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">date_part</span><span class="p">,</span> <span class="n">date_fmt_str</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">print_skips</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;skipping </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s1"> because could not parse date from </span><span class="si">{</span><span class="n">date_part</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">start_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">date</span> <span class="o">&lt;</span> <span class="n">start_date</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">print_skips</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;skipping </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s1"> because earlier than </span><span class="si">{</span><span class="n">format_date</span><span class="p">(</span><span class="n">start_date</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">end_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end_date</span> <span class="o">&lt;</span> <span class="n">date</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">print_skips</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;skipping </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s1"> because later than </span><span class="si">{</span><span class="n">format_date</span><span class="p">(</span><span class="n">end_date</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">continue</span>

        <span class="c1"># TODO if verbose and ignore is in pair_kwargs, maybe thread some other</span>
        <span class="c1"># arguments through such that we can have the inner function print just which</span>
        <span class="c1"># pairs it is ignoring? (or [opt to] return them from pair_thor_subdirs and then</span>
        <span class="c1"># print here?)</span>

        <span class="n">fly_dir</span> <span class="o">=</span> <span class="n">raw_fly_dir</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly_num</span><span class="p">)</span>

        <span class="n">paired_dirs</span> <span class="o">=</span> <span class="n">thor</span><span class="o">.</span><span class="n">pair_thor_subdirs</span><span class="p">(</span><span class="n">fly_dir</span><span class="p">,</span> <span class="o">**</span><span class="n">pair_kwargs</span><span class="p">)</span>

        <span class="c1"># TODO generalize to also match and similarly handle ThorImage-autogenerated</span>
        <span class="c1"># number suffixes that typically mean the same thing (though check the behavior</span>
        <span class="c1"># of diff ThorImage versions is supported)</span>
        <span class="k">if</span> <span class="n">skip_redone</span><span class="p">:</span>
            <span class="n">redo_suffix</span> <span class="o">=</span> <span class="s1">&#39;_redo&#39;</span>
            <span class="n">redone_thorimage_dirs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="c1"># TODO pathlib alternatives for these str ops?</span>
                <span class="n">Path</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ti</span><span class="p">)[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">redo_suffix</span><span class="p">)])</span> <span class="k">for</span> <span class="n">ti</span><span class="p">,</span> <span class="n">td</span> <span class="ow">in</span> <span class="n">paired_dirs</span>
                <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">ti</span><span class="p">)</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">redo_suffix</span><span class="p">)</span>
            <span class="p">}</span>

        <span class="k">for</span> <span class="n">image_dir</span><span class="p">,</span> <span class="n">sync_dir</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">paired_dirs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span>
            <span class="n">thor</span><span class="o">.</span><span class="n">get_thorimage_time</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>

            <span class="k">if</span> <span class="n">matching_substrs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">matching_substrs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">image_dir</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">matching_substrs</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">print_skips</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;skipping </span><span class="si">{</span><span class="n">image_dir</span><span class="si">}</span><span class="s1"> because did not contain &gt;=1 of &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;matching_substrs=&quot;</span><span class="si">{</span><span class="n">matching_substrs</span><span class="si">}</span><span class="s1">&quot;&#39;</span>
                        <span class="p">)</span>
                    <span class="k">continue</span>

            <span class="k">if</span> <span class="n">skip_redone</span> <span class="ow">and</span> <span class="n">image_dir</span> <span class="ow">in</span> <span class="n">redone_thorimage_dirs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">print_skips</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;skipping </span><span class="si">{</span><span class="n">image_dir</span><span class="si">}</span><span class="s1"> because matching redo exists</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">n_first</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">n_first</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">print_thor_paths</span><span class="p">(</span><span class="n">image_dir</span><span class="p">,</span> <span class="n">sync_dir</span><span class="p">,</span> <span class="n">print_full_paths</span><span class="o">=</span><span class="n">print_full_paths</span><span class="p">)</span>

            <span class="k">yield</span> <span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly_num</span><span class="p">),</span> <span class="p">(</span><span class="n">image_dir</span><span class="p">,</span> <span class="n">sync_dir</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span></div>


<span class="k">def</span> <span class="nf">_raw_data_root_grandchildren</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">Path</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="k">return</span> <span class="n">raw_data_root</span><span class="p">()</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;*/*/&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_all_thorimage_dirs</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns list of all ThorImage directories two levels under data root (where</span>
<span class="sd">    they should be given my folder structure conventions).</span>

<span class="sd">    For testing functions on all of the data under the root.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO fix so it&#39;s actually all children of these directories</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">_raw_data_root_grandchildren</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">thor</span><span class="o">.</span><span class="n">is_thorimage_dir</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="p">]</span>


<span class="k">def</span> <span class="nf">_all_thorsync_dirs</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns list of all ThorSync directories two levels under data root (where</span>
<span class="sd">    they should be given my folder structure conventions).</span>

<span class="sd">    For testing functions on all of the data under the root.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO fix so it&#39;s actually all children of these directories</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">_raw_data_root_grandchildren</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">thor</span><span class="o">.</span><span class="n">is_thorsync_dir</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="p">]</span>


<span class="k">def</span> <span class="nf">_all_paired_thor_dirs</span><span class="p">(</span><span class="n">skip_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">PathPair</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of all (ThorImage, ThorSync) directories that can be paired</span>
<span class="sd">    (i.e. determined to come from the same experiment) and that are both</span>
<span class="sd">    immediate children of (the same) one of the directories returned by</span>
<span class="sd">    `_raw_data_root_grandchildren()`.</span>

<span class="sd">    skip_errors (bool): (default=True) if False, will raise any caught</span>
<span class="sd">        `ValueError` rather than skipping results and continuing</span>

<span class="sd">    `kwargs` are passed to `thor.pair_thor_subdirs`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_pairs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">_raw_data_root_grandchildren</span><span class="p">():</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">d_pairs</span> <span class="o">=</span> <span class="n">thor</span><span class="o">.</span><span class="n">pair_thor_subdirs</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">skip_errors</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>

        <span class="n">all_pairs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">d_pairs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">all_pairs</span>


<span class="k">def</span> <span class="nf">_stimfile_dir</span><span class="p">(</span><span class="n">stimfile_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Pathlike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">stimfile_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">stimfile_dir</span> <span class="o">=</span> <span class="n">stimfile_root</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">stimfile_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">stimfile_dir</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">stimfile_dir</span><span class="o">.</span><span class="n">is_dir</span><span class="p">(</span><span class="n">stimfile_dir</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;passed stimfile_dir=</span><span class="si">{</span><span class="n">stimfile_dir</span><span class="si">}</span><span class="s1"> is not a directory!&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">stimfile_dir</span>


<div class="viewcode-block" id="shorten_stimfile_path"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.shorten_stimfile_path">[docs]</a><span class="k">def</span> <span class="nf">shorten_stimfile_path</span><span class="p">(</span><span class="n">stimfile_path</span><span class="p">,</span> <span class="n">stimfile_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Pathlike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Shortens absolute stimulus YAML path to one relative to stimfile_dir.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stimfile_dir</span> <span class="o">=</span> <span class="n">_stimfile_dir</span><span class="p">(</span><span class="n">stimfile_dir</span><span class="p">)</span>
    <span class="c1"># TODO convert to a pathlib call</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">stimfile_path</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">stimfile_dir</span><span class="p">))</span>

    <span class="c1"># + 1 to also exclude the os.sep character separating parent dir and relative</span>
    <span class="c1"># stimfile path.</span>
    <span class="c1"># TODO convert to pathlib</span>
    <span class="k">return</span> <span class="n">stimfile_path</span><span class="p">[(</span><span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">stimfile_dir</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):]</span></div>


<span class="c1"># TODO check no code would be broken by swapping output of this to Path</span>
<div class="viewcode-block" id="stimulus_yaml_from_thorimage"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.stimulus_yaml_from_thorimage">[docs]</a><span class="k">def</span> <span class="nf">stimulus_yaml_from_thorimage</span><span class="p">(</span><span class="n">thorimage_dir_or_xml</span><span class="p">,</span> <span class="n">stimfile_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns absolute path to stimulus YAML file from note field in ThorImage XML.</span>

<span class="sd">    Args:</span>
<span class="sd">        thorimage_dir_or_xml: path to ThorImage output directory or XML Element</span>
<span class="sd">            containing parsed contents of the corresponding Experiment.xml file.</span>

<span class="sd">        stimfile_dir (str): (optional) directory containing stimulus .yaml files.</span>
<span class="sd">            If not passed, `stimfile_root()` is used.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TooManyStimulusFiles if multiple substrings of note field end with .yaml</span>
<span class="sd">        NoStimulusFile if no substrings of note field end with .yaml</span>
<span class="sd">        IOError if stimulus file directory does not exist</span>

<span class="sd">    XML should contain a manually-entered path relative to where the olfactometer code</span>
<span class="sd">    that generated it was run, but assuming it was copied to the appropriate location</span>
<span class="sd">    (directly under `stimfile_dir` if passed or `stimfile_root()` otherwise), this</span>
<span class="sd">    absolute path should exist.</span>

<span class="sd">    My typical workflow is to paste this path into the ThorImage note field, while doing</span>
<span class="sd">    the experiment. `olf` will automatically populate clipboard with this path, when</span>
<span class="sd">    running the olfactometer program, to facilitate this.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stimfile_dir</span> <span class="o">=</span> <span class="n">_stimfile_dir</span><span class="p">(</span><span class="n">stimfile_dir</span><span class="p">)</span>

    <span class="n">notes</span> <span class="o">=</span> <span class="n">thor</span><span class="o">.</span><span class="n">get_thorimage_notes</span><span class="p">(</span><span class="n">thorimage_dir_or_xml</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">thorimage_dir_or_xml</span><span class="p">,</span> <span class="n">etree</span><span class="o">.</span><span class="n">Element</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">thor</span><span class="o">.</span><span class="n">get_thorimage_name</span><span class="p">(</span><span class="n">thorimage_dir_or_xml</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">thorimage_dir_or_xml</span>

    <span class="n">yaml_path</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># TODO ever any cases where i have other things on the line w/ yaml path?</span>
    <span class="c1"># i.e. can i use splitlines() instead? might make easier to share parse-ing of this</span>
    <span class="c1"># part w/ more general notes-&gt;dict parsing fn</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">notes</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.yaml&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">yaml_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TooManyStimulusFiles</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">: encountered multiple *.yaml substrings!&#39;</span>
                <span class="p">)</span>

            <span class="n">yaml_path</span> <span class="o">=</span> <span class="n">p</span>

    <span class="k">if</span> <span class="n">yaml_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">NoStimulusFile</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">: no string ending in .yaml found in ThorImage &#39;</span>
            <span class="s1">&#39;note field&#39;</span>
        <span class="p">)</span>

    <span class="c1"># Since paths copied/pasted within Windows may have &#39;\&#39; as a file</span>
    <span class="c1"># separator character.</span>
    <span class="n">yaml_path</span> <span class="o">=</span> <span class="n">yaml_path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>

    <span class="c1"># TODO change data that has this to expand paths + delete this hack</span>
    <span class="k">if</span> <span class="s1">&#39;&quot;&quot;&#39;</span> <span class="ow">in</span> <span class="n">yaml_path</span><span class="p">:</span>
        <span class="n">date_str</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">yaml_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[:</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">old_yaml_path</span> <span class="o">=</span> <span class="n">yaml_path</span>
        <span class="n">yaml_path</span> <span class="o">=</span> <span class="n">yaml_path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&quot;&quot;&#39;</span><span class="p">,</span> <span class="n">date_str</span><span class="p">)</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">: replacing stimulus YAML path of </span><span class="si">{</span><span class="n">old_yaml_path</span><span class="si">}</span><span class="s1"> &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;with </span><span class="si">{</span><span class="n">yaml_path</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="p">)</span>
    <span class="c1">#</span>

    <span class="c1"># TODO delete? what&#39;s reason for this branch? at least doc</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">stimfile_dir</span><span class="p">,</span> <span class="n">yaml_path</span><span class="p">)):</span>
        <span class="n">prefix</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">yaml_path</span><span class="p">)</span>
        <span class="c1"># TODO why :3? include reason in comment / rewrite. depend on a particular yaml</span>
        <span class="c1"># filename format i assume (that might sometimes be broken for manual ones tho,</span>
        <span class="c1"># right?)?</span>
        <span class="n">yaml_dir</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">prefix</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[:</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">subdir_path</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">stimfile_dir</span><span class="p">,</span> <span class="n">yaml_dir</span><span class="p">,</span> <span class="n">yaml_path</span><span class="p">)</span>
        <span class="c1"># TODO delete</span>
        <span class="nb">print</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">stimfile_dir</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">yaml_path</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">prefix</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">yaml_dir</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">subdir_path</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;doc reason for this branch&#39;</span><span class="p">)</span>
        <span class="c1">#import ipdb; ipdb.set_trace()</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">subdir_path</span><span class="p">):</span>
            <span class="n">yaml_path</span> <span class="o">=</span> <span class="n">subdir_path</span>
    <span class="c1">#</span>

    <span class="n">yaml_abspath</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">stimfile_dir</span><span class="p">,</span> <span class="n">yaml_path</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">yaml_abspath</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> references </span><span class="si">{</span><span class="n">yaml_path</span><span class="si">}</span><span class="s1">, but it did not &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;exist under stimfile_dir=</span><span class="si">{</span><span class="n">stimfile_dir</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">yaml_abspath</span></div>


<div class="viewcode-block" id="thorimage2yaml_info_and_odor_lists"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.thorimage2yaml_info_and_odor_lists">[docs]</a><span class="k">def</span> <span class="nf">thorimage2yaml_info_and_odor_lists</span><span class="p">(</span><span class="n">thorimage_dir_or_xml</span><span class="p">,</span> <span class="n">stimfile_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns yaml_path, yaml_data, odor_lists</span>

<span class="sd">    Args:</span>
<span class="sd">        thorimage_dir_or_xml: path to ThorImage output directory or XML Element object</span>
<span class="sd">            parsed from corresponding Experiment.xml file</span>

<span class="sd">        stimfile_dir (str): (optional) directory containing stimulus .yaml files.</span>
<span class="sd">            If not passed, `stimfile_root()` is used.</span>

<span class="sd">    Returns:</span>
<span class="sd">        yaml_path (str): path to YAML</span>

<span class="sd">        yaml_data (dict): loaded contents of `yaml_path`</span>

<span class="sd">        odor_lists (list-of-lists-of-dicts): each list this contains is a representation</span>
<span class="sd">            of all the odors presented together on a given trial</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">yaml_path</span> <span class="o">=</span> <span class="n">stimulus_yaml_from_thorimage</span><span class="p">(</span><span class="n">thorimage_dir_or_xml</span><span class="p">,</span>
        <span class="n">stimfile_dir</span><span class="o">=</span><span class="n">stimfile_dir</span>
    <span class="p">)</span>
    <span class="n">yaml_data</span><span class="p">,</span> <span class="n">odor_lists</span> <span class="o">=</span> <span class="n">olf</span><span class="o">.</span><span class="n">load_stimulus_yaml</span><span class="p">(</span><span class="n">yaml_path</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">yaml_path</span><span class="p">,</span> <span class="n">yaml_data</span><span class="p">,</span> <span class="n">odor_lists</span></div>


<div class="viewcode-block" id="most_recent_contained_file_mtime"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.most_recent_contained_file_mtime">[docs]</a><span class="k">def</span> <span class="nf">most_recent_contained_file_mtime</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">,</span> <span class="n">recurse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Recursively find the `os.path.getmtime` of the most recently modified file</span>

<span class="sd">    Args:</span>
<span class="sd">        path: directory within which to check mtime of files</span>

<span class="sd">        recurse: whether to check files under descendant directories of input</span>

<span class="sd">        verbose: prints which file had the most recent mtime (mostly for debugging)</span>

<span class="sd">    Returns None if there are no files in the directory.</span>

<span class="sd">    Testing on Ubuntu, this does not recurse into symlinks to directories, as I want for</span>
<span class="sd">    at least current use case.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO maybe need to actively exclude mtime on symlinks (to directories at least?)</span>
    <span class="c1"># because it will still have an mtime, but i forget whether it tracks the mtime of</span>
    <span class="c1"># the referenced directory, or whether it is just when the link is created...</span>
    <span class="k">if</span> <span class="n">recurse</span><span class="p">:</span>
        <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">rglob</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">is_file</span><span class="p">()]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">is_file</span><span class="p">()]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># TODO err if path doesn&#39;t exist (/ is not dir)? warn?</span>
        <span class="c1"># TODO also print if verbose and here</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">mtimes</span> <span class="o">=</span> <span class="p">[</span><span class="n">getmtime</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">]</span>
        <span class="n">max_mtime</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">mtimes</span><span class="p">)</span>
        <span class="n">most_recent_file</span> <span class="o">=</span> <span class="n">files</span><span class="p">[</span><span class="n">mtimes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">max_mtime</span><span class="p">)]</span>
        <span class="c1"># TODO also print modification time, appropriately formatted?</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;most recent modified file in </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="n">recurse</span><span class="si">=}</span><span class="s1">): &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">most_recent_file</span><span class="o">.</span><span class="n">relative_to</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">max_mtime</span>

    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">getmtime</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">)</span></div>


<span class="c1"># TODO support xarray.DataArrays? (isnull().sum().item(0) should work)</span>
<span class="c1"># TODO factor both to a pandas module</span>
<div class="viewcode-block" id="num_null"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.num_null">[docs]</a><span class="k">def</span> <span class="nf">num_null</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span></div>

<span class="c1"># TODO an issue that this returns a float type (at least in case where input is empty)?</span>
<div class="viewcode-block" id="num_notnull"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.num_notnull">[docs]</a><span class="k">def</span> <span class="nf">num_notnull</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span></div>


<span class="c1"># TODO maybe accept dict of names / values? which pd fn to copy the interfact of</span>
<span class="c1"># names/values from (DataFrame creation probably)?</span>
<span class="c1"># TODO TODO support xarray dataarrays?</span>
<span class="c1"># TODO test</span>
<span class="c1"># TODO TODO TODO add support for sequence of values (for a given name (/names entry)).</span>
<span class="c1"># at the moment, seems only scalar values supported. or at least rename to indicate it</span>
<span class="c1"># only supports scalars in values.</span>
<div class="viewcode-block" id="addlevel"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.addlevel">[docs]</a><span class="k">def</span> <span class="nf">addlevel</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Add level(s) to pandas MultiIndex</span>

<span class="sd">    Intended to be an inverse to pandas.DataFrame.droplevel. pandas.DataFrame.set_index</span>
<span class="sd">    with `append=True` would work *except* that there is no `axis` kwarg to that</span>
<span class="sd">    function, so it does not work for the columns. pandas.DataFrame.unstack is almost</span>
<span class="sd">    what I would want, but it can seemingly arbitrarily change order of rows.</span>

<span class="sd">    Args:</span>
<span class="sd">        df: DataFrame to add MultiIndex levels to</span>
<span class="sd">        names: `str`/sequence-of-`str` name(s) for the new levels</span>
<span class="sd">        values: values for the new levels. If `names` is a sequence, this should be of</span>
<span class="sd">            the same length.</span>
<span class="sd">        axis: 0/&#39;index&#39; or 1/&#39;columns&#39;, defauling to &#39;index&#39; as in pandas</span>

<span class="sd">    Returns: DataFrame with MultiIndex containing names/levels from input</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># https://stackoverflow.com/questions/14744068</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">values</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">values</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">],</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">value</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<span class="c1"># TODO replace w/ np.array_equal w/ equal_nan=True? maybe adding checks on index/cols</span>
<span class="c1"># for a similar DataFrame fn (or a path for DataFrame inputs here)?</span>
<span class="c1"># TODO test w/ ndarray/DataFrame[/DataArray?] input + typehint</span>
<span class="c1"># TODO type hint so that output type is same as input type (TypeVar?)</span>
<span class="c1"># TODO already have something like this in diff_dataframes? (didn&#39;t seem like it, but</span>
<span class="c1"># could maybe use this here)</span>
<div class="viewcode-block" id="nan_eq"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.nan_eq">[docs]</a><span class="k">def</span> <span class="nf">nan_eq</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Elementwise equality of arrays, but True if both are NaN at a location.</span>

<span class="sd">    Normally, NaN != NaN, but this is not the behavior I want when trying to check which</span>
<span class="sd">    parts of an array/DataFrame were changed by an operation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># https://stackoverflow.com/questions/19322506</span>
    <span class="c1"># Psuedocode: (x == y) or (isnan(x) and isnan(y))</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">arr1</span> <span class="o">==</span> <span class="n">arr2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span> <span class="p">(</span><span class="n">arr1</span> <span class="o">!=</span> <span class="n">arr2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">arr2</span> <span class="o">!=</span> <span class="n">arr2</span><span class="p">)</span> <span class="p">)</span></div>

    <span class="c1"># This is ugly, but should let this work on very large arrays without causing any</span>
    <span class="c1"># memory issues (not sure I need that...).</span>
    <span class="c1"># https://stackoverflow.com/questions/10819715</span>
    <span class="c1"># TODO does numexpr work w/ DataFrame inputs? returns same type?</span>
    <span class="c1">#return numexpr.evaluate(&#39;(arr1 == arr2) | ( (arr1 != arr1) &amp; (arr2 != arr2) )&#39;)</span>


<div class="viewcode-block" id="is_array_sorted"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.is_array_sorted">[docs]</a><span class="k">def</span> <span class="nf">is_array_sorted</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns whether 1-dimensional np.ndarray is sorted.&quot;&quot;&quot;</span>
    <span class="c1"># could implement an `axis` kwarg if i wanted to support multidimensional</span>
    <span class="c1"># arrays</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;only 1-dimensional arrays supported&#39;</span>
    <span class="c1"># https://stackoverflow.com/questions/47004506</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">array</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span></div>


<div class="viewcode-block" id="print_block_frames"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.print_block_frames">[docs]</a><span class="k">def</span> <span class="nf">print_block_frames</span><span class="p">(</span><span class="n">block_first_frames</span><span class="p">,</span> <span class="n">block_last_frames</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Prints block numbers and the corresponding start / stop frames.</span>

<span class="sd">    For subsetting TIFF in ImageJ / other manual analysis.</span>

<span class="sd">    Prints frame numbers 1-indexed, but takes 0-indexed frames.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Block frames:&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">b_first</span><span class="p">,</span> <span class="n">b_last</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">block_first_frames</span><span class="p">,</span>
        <span class="n">block_last_frames</span><span class="p">)):</span>
        <span class="c1"># Adding one to index frames as in ImageJ.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1"> - </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">b_first</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b_last</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="md5"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.md5">[docs]</a><span class="k">def</span> <span class="nf">md5</span><span class="p">(</span><span class="n">fname</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Calculates MD5 hash on file with name `fname`.</span>

<span class="sd">    Should match output of Linux utility md5sum.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hash_md5</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">()</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4096</span><span class="p">),</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
            <span class="n">hash_md5</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">hash_md5</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span></div>


<span class="c1"># TODO transition everything to as if include_val==True?</span>
<span class="c1"># TODO parameterize Sequence elemtents and (what is currently Any) value type in</span>
<span class="c1"># include_val=True branch into one value?</span>
<div class="viewcode-block" id="const_ranges"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.const_ranges">[docs]</a><span class="k">def</span> <span class="nf">const_ranges</span><span class="p">(</span><span class="n">xs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">include_val</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span>
    <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span>
    <span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Returns tuples of indices for largest contiguous constant-value ranges in input.</span>

<span class="sd">    All elements in input sequence should be included in exactly one (start, stop) index</span>
<span class="sd">    tuple. Range tuples should all be in order, and stop indices are inclusive, so the</span>
<span class="sd">    end of one range should be one less than the start of the next range.</span>

<span class="sd">    Args:</span>
<span class="sd">        include_val: if True, each tuple in output will be length 3, with the first</span>
<span class="sd">            element the value for the range specified by (start, stop) indices in the</span>
<span class="sd">            remaining elements of the tuple. If False, each tuple will be length 2, just</span>
<span class="sd">            containing these (start, stop) indices.</span>

<span class="sd">    &gt;&gt;&gt; const_ranges([&#39;MCH&#39;, &#39;MCH&#39;, &#39;OCT&#39;, &#39;OCT&#39;])</span>
<span class="sd">    [(0, 1), (2, 3)]</span>

<span class="sd">    &gt;&gt;&gt; const_ranges([&#39;MCH&#39;, &#39;MCH&#39;, &#39;OCT&#39;, &#39;OCT&#39;], include_val=True)</span>
<span class="sd">    [(&#39;MCH&#39;, 0, 1), (&#39;OCT&#39;, 2, 3)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Since I want to allow xs to contain None, the sentinel I would have otherwise used</span>
    <span class="c1"># https://python-patterns.guide/python/sentinel-object/</span>
    <span class="n">sentinel</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

    <span class="n">x_prev</span> <span class="o">=</span> <span class="n">sentinel</span>
    <span class="n">ranges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">curr_start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
        <span class="c1"># TODO want to support NaN? would prob need to special case in `x != x_prev`</span>
        <span class="c1"># check then... (cause NaN != NaN is True)</span>
        <span class="k">if</span> <span class="n">x_prev</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">sentinel</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">x_prev</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">include_val</span><span class="p">:</span>
                    <span class="n">range_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">curr_start</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">range_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_prev</span><span class="p">,</span> <span class="n">curr_start</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

                <span class="n">ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">range_data</span><span class="p">)</span>

            <span class="n">curr_start</span> <span class="o">=</span> <span class="n">i</span>

        <span class="n">x_prev</span> <span class="o">=</span> <span class="n">x</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">include_val</span><span class="p">:</span>
            <span class="n">range_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">curr_start</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Since elements are only added above at level *changes*, we will always</span>
            <span class="c1"># need to add one at the end of the list.</span>
            <span class="n">range_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">curr_start</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">range_data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ranges</span></div>


<span class="c1"># TODO move to project specific repo</span>
<div class="viewcode-block" id="odorset_name"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.odorset_name">[docs]</a><span class="k">def</span> <span class="nf">odorset_name</span><span class="p">(</span><span class="n">df_or_odornames</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns name for set of odors in DataFrame.</span>

<span class="sd">    Looks at odors in original_name1 column. Name used to lookup desired</span>
<span class="sd">    plotting order for the odors in the set.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;original_name1&#39;</span> <span class="ow">in</span> <span class="n">df_or_odornames</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">unique_odornames</span> <span class="o">=</span> <span class="n">df_or_odornames</span><span class="o">.</span><span class="n">original_name1</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            <span class="n">abbreviated</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="s1">&#39;name1&#39;</span> <span class="ow">in</span> <span class="n">df_or_odornames</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> \
                <span class="s1">&#39;need either original_name1 or name1 in df columns&#39;</span>
            <span class="c1"># Assuming abbreviated names now.</span>
            <span class="n">unique_odornames</span> <span class="o">=</span> <span class="n">df_or_odornames</span><span class="o">.</span><span class="n">name1</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            <span class="c1"># maybe don&#39;t assume abbreviated just b/c name1?</span>
            <span class="c1"># (particularly if supporting abbrev/not in iterable input</span>
            <span class="c1"># case, could also check name1 contents)</span>
            <span class="n">abbreviated</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">unique_odornames</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">df_or_odornames</span><span class="p">)</span>
        <span class="c1"># TODO maybe also support abbreviated names in this case?</span>
        <span class="n">abbreviated</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">odor_set</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># TODO TODO derive these diagnostic odors from odor_set2order? would that</span>
    <span class="c1"># still be redundant w/ something else i hardcoded (if so, further</span>
    <span class="c1"># de-dupe)?</span>
    <span class="c1"># TODO at least lookup abbreviations from full names?</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">abbreviated</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;ethyl butyrate&#39;</span> <span class="ow">in</span> <span class="n">unique_odornames</span><span class="p">:</span>
            <span class="n">odor_set</span> <span class="o">=</span> <span class="s1">&#39;kiwi&#39;</span>
        <span class="k">elif</span> <span class="s1">&#39;acetoin&#39;</span> <span class="ow">in</span> <span class="n">unique_odornames</span><span class="p">:</span>
            <span class="n">odor_set</span> <span class="o">=</span> <span class="s1">&#39;flyfood&#39;</span>
        <span class="k">elif</span> <span class="s1">&#39;1-octen-3-ol&#39;</span> <span class="ow">in</span> <span class="n">unique_odornames</span><span class="p">:</span>
            <span class="n">odor_set</span> <span class="o">=</span> <span class="s1">&#39;control&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;eb&#39;</span> <span class="ow">in</span> <span class="n">unique_odornames</span><span class="p">:</span>
            <span class="n">odor_set</span> <span class="o">=</span> <span class="s1">&#39;kiwi&#39;</span>
        <span class="k">elif</span> <span class="s1">&#39;atoin&#39;</span> <span class="ow">in</span> <span class="n">unique_odornames</span><span class="p">:</span>
            <span class="n">odor_set</span> <span class="o">=</span> <span class="s1">&#39;flyfood&#39;</span>
        <span class="k">elif</span> <span class="s1">&#39;1o3ol&#39;</span> <span class="ow">in</span> <span class="n">unique_odornames</span><span class="p">:</span>
            <span class="n">odor_set</span> <span class="o">=</span> <span class="s1">&#39;control&#39;</span>

    <span class="k">if</span> <span class="n">odor_set</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;none of diagnostic odors in odor column&#39;</span><span class="p">)</span>

    <span class="c1"># TODO probably just find single odor that satisfies is_mix and derive from</span>
    <span class="c1"># that, for more generality (would only work in original name case)</span>
    <span class="k">return</span> <span class="n">odor_set</span></div>


<span class="c1"># TODO move to olf/io (along w/ other similar fns)?</span>
<div class="viewcode-block" id="load_stimfile"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.load_stimfile">[docs]</a><span class="k">def</span> <span class="nf">load_stimfile</span><span class="p">(</span><span class="n">stimfile_path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Loads odor metadata stored in a pickle.</span>

<span class="sd">    These metadata files are generated by scripts under</span>
<span class="sd">    `ejhonglab/cutpast_arduino_stimuli`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO better check for path already containing stimfile_root?</span>
    <span class="c1"># string prefix check might be too fragile...</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">stimfile_path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">stimfile_root</span><span class="p">()):</span>
        <span class="n">stimfile_path</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">stimfile_root</span><span class="p">(),</span> <span class="n">stimfile_path</span><span class="p">)</span>

    <span class="c1"># TODO also err if not readable / valid</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">stimfile_path</span><span class="p">):</span>
        <span class="n">stimfile_just_fname</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">stimfile_path</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;copy missing stimfile </span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">stimfile_just_fname</span><span class="p">,</span> <span class="n">stimfile_root</span>
        <span class="p">))</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">stimfile_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span></div>


<span class="c1"># TODO either generalize / allow passing additional functions / keys or move to</span>
<span class="c1"># project specific repo</span>
<span class="c1"># TODO delete (subsuming contents into load_experiment) if i&#39;d never want to</span>
<span class="c1"># call this in other circumstances</span>
<span class="c1"># TODO can this be generalized nicely to load YAML files output by my newer</span>
<span class="c1"># olfactometer code?</span>
<div class="viewcode-block" id="load_odor_metadata"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.load_odor_metadata">[docs]</a><span class="k">def</span> <span class="nf">load_odor_metadata</span><span class="p">(</span><span class="n">stimfile_path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns odor metadata loaded from pickle and additional computed values.</span>

<span class="sd">    Additional values are added into the dictionary loaded from the pickle.</span>
<span class="sd">    In some cases, this can overwrite the loaded values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">load_stimfile</span><span class="p">(</span><span class="n">stimfile_path</span><span class="p">)</span>
    <span class="c1"># TODO infer from data if no stimfile and not specified in</span>
    <span class="c1"># metadata (is there actually any value in this? maybe if we have</span>
    <span class="c1"># a sufficient amount of other data about the odor order in metadata</span>
    <span class="c1"># yaml (though this is not supported now...)?)</span>

    <span class="c1"># TODO delete this hack (which is currently just using new pickle</span>
    <span class="c1"># format as a proxy for the experiment being a supermixture experiment)</span>
    <span class="k">if</span> <span class="s1">&#39;odor_lists&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">pair_case</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># The 3 is because 3 odors are compared in each repeat for the</span>
        <span class="c1"># natural_odors odor-pair experiments.</span>
        <span class="n">presentations_per_repeat</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">odor_list</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;odor_pair_list&#39;</span><span class="p">]</span>

        <span class="c1"># could delete eventually. b/c originally i was casting to int,</span>
        <span class="c1"># though it&#39;s likely it was always int anyway...</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_repeats&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">int</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pair_case</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">n_expected_real_blocks</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">odor_list</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;odor_lists&#39;</span><span class="p">]</span>
        <span class="c1"># because of &quot;block&quot; def in arduino / get_stiminfo code</span>
        <span class="c1"># not matching def in randomizer / stimfile code</span>
        <span class="c1"># (scopePin pulses vs. randomization units, depending on settings)</span>
        <span class="n">presentations_per_repeat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">odor_list</span><span class="p">)</span> <span class="o">//</span> <span class="n">n_expected_real_blocks</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">odor_list</span><span class="p">)</span> <span class="o">%</span> <span class="n">n_expected_real_blocks</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="c1"># Hardcode to break up into more blocks, to align defs of blocks.</span>
        <span class="c1"># TODO (maybe just for experiments on 2019-07-25 ?) or change block</span>
        <span class="c1"># handling in here? make more flexible?</span>

        <span class="c1"># Will overwrite existing value.</span>
        <span class="k">assert</span> <span class="s1">&#39;n_repeats&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_repeats&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># TODO check that overwriting of presentations_per_block with newest</span>
        <span class="c1"># data in this case is still accurate (post fixing some of the values</span>
        <span class="c1"># in pickle data) (also check similar values)</span>

    <span class="n">presentations_per_block</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_repeats&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">presentations_per_repeat</span>

    <span class="c1"># Overwriting exisiting value.</span>
    <span class="k">assert</span> <span class="s1">&#39;presentations_per_block&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;presentations_per_block&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">presentations_per_block</span>

    <span class="c1"># NOT overwriting an existing value.</span>
    <span class="k">assert</span> <span class="s1">&#39;pair_case&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;pair_case&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pair_case</span>

    <span class="c1"># NOT overwriting existing value.</span>
    <span class="k">assert</span> <span class="s1">&#39;presentations_per_repeat&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;presentations_per_repeat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">presentations_per_repeat</span>

    <span class="c1"># NOT overwriting an existing value.</span>
    <span class="k">assert</span> <span class="s1">&#39;odor_list&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;odor_list&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">odor_list</span>

    <span class="k">return</span> <span class="n">data</span></div>


<span class="c1"># TODO maybe break into a kc_mix_analysis repo (or something else appropriately</span>
<span class="c1"># project specific)</span>
<div class="viewcode-block" id="print_trial_odors"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.print_trial_odors">[docs]</a><span class="k">def</span> <span class="nf">print_trial_odors</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">odor_onset_frames</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    data should be as the output of `load_odor_metadata`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">chemutils</span> <span class="k">as</span> <span class="nn">cu</span>

    <span class="n">n_repeats</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_repeats&#39;</span><span class="p">]</span>
    <span class="n">odor_list</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;odor_list&#39;</span><span class="p">]</span>
    <span class="n">presentations_per_block</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;presentations_per_block&#39;</span><span class="p">]</span>
    <span class="n">pair_case</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;pair_case&#39;</span><span class="p">]</span>

    <span class="n">n_blocks</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">odor_list</span><span class="p">),</span> <span class="n">presentations_per_block</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">remainder</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="c1"># TODO add extra input data / add extra values to `data` in fn that already</span>
    <span class="c1"># augments that as necessary, for all values used below to still be defined</span>
    <span class="k">if</span> <span class="n">pair_case</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> comparisons ({{A, B, A+B}} in random order x &#39;</span> <span class="o">+</span>
            <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> repeats)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_blocks</span><span class="p">,</span> <span class="n">n_repeats</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mix_names</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">odor_list</span> <span class="k">if</span> <span class="s1">&#39;@&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">x</span><span class="p">}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mix_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">mix_name</span> <span class="o">=</span> <span class="n">mix_names</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> randomized blocks of &quot;</span><span class="si">{}</span><span class="s1">&quot; and its components&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">n_blocks</span><span class="p">,</span> <span class="n">mix_name</span>
            <span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">mix_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No mixtures, so presumably this is a calibration experiment&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">n_blocks</span><span class="si">}</span><span class="s1"> randomized blocks&#39;</span><span class="p">)</span>

    <span class="c1"># TODO maybe print this in tabular form?</span>
    <span class="n">trial</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_blocks</span><span class="p">):</span>
        <span class="n">p_start</span> <span class="o">=</span> <span class="n">presentations_per_block</span> <span class="o">*</span> <span class="n">i</span>
        <span class="n">p_end</span> <span class="o">=</span> <span class="n">presentations_per_block</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">cline</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="n">odor_strings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">odor_list</span><span class="p">[</span><span class="n">p_start</span><span class="p">:</span><span class="n">p_end</span><span class="p">]:</span>
            <span class="c1"># TODO maybe always have odor_list hold str repr?</span>
            <span class="c1"># or unify str repr generation -&gt; don&#39;t handle use odor_lists</span>
            <span class="c1"># for str representation in supermixture case?</span>
            <span class="c1"># would also be a good time to unify name + *concentration*</span>
            <span class="c1"># handling</span>
            <span class="k">if</span> <span class="n">pair_case</span><span class="p">:</span>
                <span class="c1"># TODO odor2abbrev here too probably... be more uniform</span>
                <span class="k">if</span> <span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;paraffin&#39;</span><span class="p">:</span>
                    <span class="n">odor_string</span> <span class="o">=</span> <span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">odor_string</span> <span class="o">=</span> <span class="s1">&#39; + &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span>

                <span class="n">parts</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;@&#39;</span><span class="p">)</span>
                <span class="n">odor_name</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="n">abbrev</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">abbrev</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">odor2abbrev</span><span class="p">(</span><span class="n">odor_name</span><span class="p">)</span>
                <span class="c1"># For a chemutils conversion failure.</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">pass</span>

                <span class="k">if</span> <span class="n">abbrev</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">abbrev</span> <span class="o">=</span> <span class="n">odor_name</span>

                <span class="n">odor_string</span> <span class="o">=</span> <span class="n">abbrev</span>
                <span class="c1"># TODO also don&#39;t append stuff if conc is @ 0.0 (log)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                    <span class="n">odor_string</span> <span class="o">+=</span> <span class="s1">&#39; @&#39;</span> <span class="o">+</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Adding one to index frames as in ImageJ.</span>
            <span class="k">if</span> <span class="n">odor_onset_frames</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">odor_string</span> <span class="o">+=</span> <span class="s1">&#39; (</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">odor_onset_frames</span><span class="p">[</span><span class="n">trial</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">trial</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">odor_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">odor_string</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">cline</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">odor_strings</span><span class="p">))</span></div>


<span class="c1"># TODO delete</span>
<div class="viewcode-block" id="tiff_ijroi_filename"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.tiff_ijroi_filename">[docs]</a><span class="k">def</span> <span class="nf">tiff_ijroi_filename</span><span class="p">(</span><span class="n">tiff</span><span class="p">,</span> <span class="n">confirm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">gui_confirm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">gui_fallback</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">gui</span><span class="o">=</span><span class="s1">&#39;qt5&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a tiff path to corresponding ImageJ ROI file, assuming a certain</span>
<span class="sd">    naming convention and folder structure.</span>

<span class="sd">    Automatic search for ROI will only check same folder as the TIFF passed in.</span>

<span class="sd">    Options for fallback to manual selection / confirmation of appropriate</span>
<span class="sd">    ROI file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">gui_confirm</span> <span class="ow">and</span> <span class="n">confirm</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;only specify either gui_confirm or confirm&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">gui_confirm</span> <span class="ow">or</span> <span class="n">gui_fallback</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">gui</span> <span class="o">==</span> <span class="s1">&#39;qt5&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">PyQt5.QtWidgets</span> <span class="kn">import</span> <span class="n">QMessageBox</span><span class="p">,</span> <span class="n">QFileDialog</span>

        <span class="c1"># TODO maybe implement some version w/ a builtin python gui like</span>
        <span class="c1"># tkinter?</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;gui </span><span class="si">{</span><span class="n">gui</span><span class="si">}</span><span class="s1"> not supported. see function.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">confirm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">confirm</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">curr_tiff_dir</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">tiff</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># TODO check that *.zip glob still matches in case where it is the empty</span>
    <span class="c1"># string (fix if it doesn&#39;t)</span>
    <span class="n">thorimage_id</span> <span class="o">=</span> <span class="n">tiff_thorimage_id</span><span class="p">(</span><span class="n">tiff</span><span class="p">)</span>
    <span class="n">possible_ijroi_files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">curr_tiff_dir</span><span class="p">,</span>
        <span class="n">thorimage_id</span> <span class="o">+</span> <span class="s1">&#39;*.zip&#39;</span>
    <span class="p">))</span>

    <span class="n">ijroiset_filename</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># TODO fix automatic first choice in _NNN naming convention case</span>
    <span class="c1"># (seemed to not work on 2019-07-25/2/_008)</span>
    <span class="c1"># but actually it did work in */_007 case... so idk what&#39;s happening</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_ijroi_files</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ijroiset_filename</span> <span class="o">=</span> <span class="n">possible_ijroi_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">confirm</span><span class="p">:</span>
            <span class="c1"># TODO factor into a fn to always get a Yy/Nn answer?</span>
            <span class="n">prompt</span> <span class="o">=</span> <span class="p">(</span><span class="n">format_keys</span><span class="p">(</span><span class="o">*</span><span class="n">tiff_filename2keys</span><span class="p">(</span><span class="n">tiff</span><span class="p">)</span> <span class="o">+</span>
                <span class="sa">f</span><span class="s1">&#39;: use ImageJ ROIs in </span><span class="si">{</span><span class="n">ijroiset_filename</span><span class="si">}</span><span class="s1">? [y/n] &#39;</span>
            <span class="p">))</span>
            <span class="n">response</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">while</span> <span class="n">response</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">):</span>
                <span class="n">response</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">response</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
                <span class="n">ijroiset_filename</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1"># TODO manual text entry of appropriate filename in this case?</span>
                <span class="c1"># ...or maybe just totally unsupport terminal interaction?</span>

        <span class="k">elif</span> <span class="n">gui_confirm</span><span class="p">:</span>
            <span class="n">confirmation_choice</span> <span class="o">=</span> <span class="n">QMessageBox</span><span class="o">.</span><span class="n">question</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Confirm ROI file&#39;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s1">&#39;Use ImageJ ROIs in </span><span class="si">{</span><span class="n">ijroiset_filename</span><span class="si">}</span><span class="s1">?&#39;</span><span class="p">,</span>
                <span class="n">QMessageBox</span><span class="o">.</span><span class="n">Yes</span> <span class="o">|</span> <span class="n">QMessageBox</span><span class="o">.</span><span class="n">No</span><span class="p">,</span> <span class="n">QMessageBox</span><span class="o">.</span><span class="n">No</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">confirmation_choice</span> <span class="o">!=</span> <span class="n">QMessageBox</span><span class="o">.</span><span class="n">Yes</span><span class="p">:</span>
                <span class="n">ijroiset_filename</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">elif</span> <span class="ow">not</span> <span class="n">gui_fallback</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_ijroi_files</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;too many candidate ImageJ ROI files&#39;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="ow">not</span> <span class="n">gui_fallback</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_ijroi_files</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;no candidate ImageJ ROI files&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">gui_fallback</span> <span class="ow">and</span> <span class="n">ijroiset_filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">options</span> <span class="o">=</span> <span class="n">QFileDialog</span><span class="o">.</span><span class="n">Options</span><span class="p">()</span>
        <span class="n">options</span> <span class="o">|=</span> <span class="n">QFileDialog</span><span class="o">.</span><span class="n">DontUseNativeDialog</span>

        <span class="c1"># TODO restrict *.zip files shown to those also following some</span>
        <span class="c1"># naming convention (to indicate it&#39;s for the currently loaded TIFF,</span>
        <span class="c1"># and not a TIFF from some other experiment on the same fly)?</span>
        <span class="c1"># maybe checkbox / diff option to show all?</span>

        <span class="c1"># TODO need to pass in parent widget (what `self` was) or leave null if</span>
        <span class="c1"># that works? / define in here?</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;see comment above&#39;</span><span class="p">)</span>
        <span class="n">ijroiset_filename</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">QFileDialog</span><span class="o">.</span><span class="n">getOpenFileName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="s1">&#39;Select ImageJ ROI zip...&#39;</span><span class="p">,</span> <span class="n">curr_tiff_dir</span><span class="p">,</span>
            <span class="s1">&#39;ImageJ ROIs (*.zip)&#39;</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span>
        <span class="p">)</span>
        <span class="c1"># TODO (opt?) to not allow no selection? (so downstream code can assume</span>
        <span class="c1"># it&#39;s defined...) (should also probably change confirmation behavior</span>
        <span class="c1"># above)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ijroiset_filename</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No ImageJ ROI zipfile selected.&#39;</span><span class="p">)</span>
            <span class="n">ijroiset_filename</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">ijroiset_filename</span></div>


<span class="c1"># TODO TODO TODO may want to change how this fn operates (so it operates on</span>
<span class="c1"># blocks rather than all of them concatenated + to provide different baselining</span>
<span class="c1"># options)</span>
<span class="c1"># TODO maybe replace w/ (/ borrow some ideas from) al_analysis.delta_f_over_f</span>
<div class="viewcode-block" id="calculate_df_over_f"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.calculate_df_over_f">[docs]</a><span class="k">def</span> <span class="nf">calculate_df_over_f</span><span class="p">(</span><span class="n">raw_f</span><span class="p">,</span> <span class="n">trial_start_frames</span><span class="p">,</span> <span class="n">odor_onset_frames</span><span class="p">,</span>
    <span class="n">trial_stop_frames</span><span class="p">):</span>
    <span class="c1"># TODO TODO maybe factor this into some kind of util fn that applies</span>
    <span class="c1"># another fn (perhaps inplace, perhaps onto new array) to each</span>
    <span class="c1"># (cell, block) (or maybe just each block, if smooth_1d can be vectorized,</span>
    <span class="c1"># so it could also apply in frame-shape-preserved case?)</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    for b_start, b_end in zip(block_first_frames, block_last_frames):</span>

<span class="sd">        for c in range(n_footprints):</span>
<span class="sd">            # TODO TODO TODO TODO need to be (b_end + 1) since not</span>
<span class="sd">            # inclusive? (&lt;-fixed) other problems like this elsewhere?????</span>
<span class="sd">            # TODO maybe smooth less now that df/f is being calculated more</span>
<span class="sd">            # sensibly...</span>
<span class="sd">            raw_f[b_start:(b_end + 1), c] = smooth_1d(</span>
<span class="sd">                raw_f[b_start:(b_end + 1), c], window_len=11</span>
<span class="sd">            )</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">df_over_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">raw_f</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">for</span> <span class="n">t_start</span><span class="p">,</span> <span class="n">odor_onset</span><span class="p">,</span> <span class="n">t_end</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">trial_start_frames</span><span class="p">,</span> <span class="n">odor_onset_frames</span><span class="p">,</span>
        <span class="n">trial_stop_frames</span><span class="p">):</span>

        <span class="c1"># TODO TODO maybe use diff way of calculating baseline</span>
        <span class="c1"># (include stuff at end of response? just some percentile over a big</span>
        <span class="c1"># window or something?)</span>
        <span class="c1"># TODO kwargs to control method of calculating baseline</span>

        <span class="c1"># TODO maybe display baseline period on plots for debugging?</span>
        <span class="c1"># maybe frame numbers got shifted?</span>
        <span class="n">baselines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">raw_f</span><span class="p">[</span><span class="n">t_start</span><span class="p">:(</span><span class="n">odor_onset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">trial_f</span> <span class="o">=</span> <span class="n">raw_f</span><span class="p">[</span><span class="n">t_start</span><span class="p">:(</span><span class="n">t_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">:]</span>
        <span class="n">df_over_f</span><span class="p">[</span><span class="n">t_start</span><span class="p">:(</span><span class="n">t_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">trial_f</span> <span class="o">-</span> <span class="n">baselines</span><span class="p">)</span> <span class="o">/</span> <span class="n">baselines</span>

    <span class="c1"># TODO some check that no value in df_over_f are currently NaN?</span>

    <span class="k">return</span> <span class="n">df_over_f</span></div>


<span class="c1"># TODO move to project specific repo</span>
<div class="viewcode-block" id="stimfile_odorset"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.stimfile_odorset">[docs]</a><span class="k">def</span> <span class="nf">stimfile_odorset</span><span class="p">(</span><span class="n">stimfile_path</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">load_stimfile</span><span class="p">(</span><span class="n">stimfile_path</span><span class="p">)</span>

    <span class="c1"># TODO did i use some other indicator elsewhere? anything more robust than</span>
    <span class="c1"># this?</span>
    <span class="k">if</span> <span class="s1">&#39;odor_pair_list&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="c1"># Just because I don&#39;t believe the pair experiment analysis</span>
        <span class="c1"># made any use of something like an odorset, so trying to</span>
        <span class="c1"># get one from those stimfiles is likely a mistake.</span>
        <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
            <span class="c1"># TODO maybe this err should happen whether or not strict is</span>
            <span class="c1"># true...?</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;trying to get complex mixture odor set &#39;</span>
                <span class="s1">&#39;from old pair experiment stimfile&#39;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="n">odors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;odor_lists&#39;</span><span class="p">])</span>
    <span class="c1"># TODO TODO TODO what caused this error where some fields were empty?</span>
    <span class="c1"># this corrupt or test data / not intended to be saved?</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">odors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;empty odor lists in </span><span class="si">{</span><span class="n">stimfile_path</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;odor_lists&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">str</span>

    <span class="c1"># TODO TODO TODO fix how stimfile generation stuff doesn&#39;t save</span>
    <span class="c1"># hardcoded real stuff into odors (+ maybe other vars?)</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    print(len(odors))</span>
<span class="sd">    pprint(odors)</span>
<span class="sd">    print(len(set(data[&#39;odors2pins&#39;].keys())))</span>
<span class="sd">    pprint(set(data[&#39;odors2pins&#39;].keys()))</span>
<span class="sd">    print(len(set(data[&#39;pins2odors&#39;].values())))</span>
<span class="sd">    pprint(set(data[&#39;pins2odors&#39;].values()))</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">#assert odors == set(data[&#39;odors&#39;])</span>
    <span class="k">assert</span> <span class="n">odors</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;odors2pins&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">assert</span> <span class="n">odors</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;pins2odors&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="c1"># Not this accessor syntax, because .name is a property of all pandas</span>
    <span class="c1"># objects.</span>
    <span class="n">odor_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">split_odor_w_conc</span><span class="p">(</span><span class="n">oc</span><span class="p">)[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">oc</span> <span class="ow">in</span> <span class="n">odors</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">odorset_name</span><span class="p">(</span><span class="n">odor_names</span><span class="p">)</span></div>


<div class="viewcode-block" id="print_all_stimfile_odorsets"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.print_all_stimfile_odorsets">[docs]</a><span class="k">def</span> <span class="nf">print_all_stimfile_odorsets</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">stimfiles</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">stimfile_root</span><span class="p">(),</span> <span class="s1">&#39;*.p&#39;</span><span class="p">)))</span>
    <span class="n">stimfile_odorsets</span> <span class="o">=</span> <span class="p">[</span><span class="n">stimfile_odorset</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sf</span> <span class="ow">in</span> <span class="n">stimfiles</span>
    <span class="p">]</span>
    <span class="c1"># TODO maybe print grouped by day</span>
    <span class="n">pprint</span><span class="p">([(</span><span class="n">split</span><span class="p">(</span><span class="n">f</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">stimfiles</span><span class="p">,</span> <span class="n">stimfile_odorsets</span><span class="p">)</span> <span class="k">if</span> <span class="n">s</span>
    <span class="p">])</span></div>


<span class="c1"># TODO TODO move all of this kc mix stuff to project specific repo</span>
<span class="n">solvents</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;pfo&#39;</span><span class="p">,</span> <span class="s1">&#39;water&#39;</span><span class="p">)</span>
<span class="n">natural</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;kiwi&#39;</span><span class="p">,</span> <span class="s1">&#39;fly food&#39;</span><span class="p">)</span>
<span class="c1"># TODO maybe load (on demand) + cache the abbreviated versions of these, if</span>
<span class="c1"># chemutils is available?</span>
<span class="n">odor_set2order</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;kiwi&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;pfo&#39;</span><span class="p">,</span>
        <span class="s1">&#39;ethyl butyrate&#39;</span><span class="p">,</span>
        <span class="s1">&#39;ethyl acetate&#39;</span><span class="p">,</span>
        <span class="s1">&#39;isoamyl acetate&#39;</span><span class="p">,</span>
        <span class="s1">&#39;isoamyl alcohol&#39;</span><span class="p">,</span>
        <span class="s1">&#39;ethanol&#39;</span><span class="p">,</span>
        <span class="c1"># TODO check that changing the order of these last two hasn&#39;t broken</span>
        <span class="c1"># stuff...</span>
        <span class="s1">&#39;kiwi approx.&#39;</span><span class="p">,</span>
        <span class="s1">&#39;d3 kiwi&#39;</span>
    <span class="p">],</span>
    <span class="s1">&#39;control&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;pfo&#39;</span><span class="p">,</span>
        <span class="s1">&#39;1-octen-3-ol&#39;</span><span class="p">,</span>
        <span class="s1">&#39;furfural&#39;</span><span class="p">,</span>
        <span class="s1">&#39;valeric acid&#39;</span><span class="p">,</span>
        <span class="s1">&#39;methyl salicylate&#39;</span><span class="p">,</span>
        <span class="s1">&#39;2-heptanone&#39;</span><span class="p">,</span>
        <span class="c1"># Only one of these will actually be present, they just take the same</span>
        <span class="c1"># place in the order.</span>
        <span class="s1">&#39;control mix 1&#39;</span><span class="p">,</span>
        <span class="s1">&#39;control mix 2&#39;</span>
    <span class="p">],</span>
    <span class="s1">&#39;flyfood&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;water&#39;</span><span class="p">,</span>
        <span class="s1">&#39;propanoic acid&#39;</span><span class="p">,</span>
        <span class="s1">&#39;isobutyric acid&#39;</span><span class="p">,</span>
        <span class="s1">&#39;acetic acid&#39;</span><span class="p">,</span>
        <span class="s1">&#39;acetoin&#39;</span><span class="p">,</span>
        <span class="s1">&#39;ethanol&#39;</span><span class="p">,</span>
        <span class="s1">&#39;fly food approx.&#39;</span><span class="p">,</span>
        <span class="s1">&#39;fly food b&#39;</span>
    <span class="p">]</span>
<span class="p">}</span>
<div class="viewcode-block" id="df_to_odor_order"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.df_to_odor_order">[docs]</a><span class="k">def</span> <span class="nf">df_to_odor_order</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">observed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_name1</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes a complex-mixture DataFrame to odor names in desired plot order.</span>

<span class="sd">    Args:</span>
<span class="sd">    df (pd.DataFrame): should have a &#39;original_name1&#39; column, with names of</span>
<span class="sd">        odors from complex mixture experiments we have pre-defined odor orders</span>
<span class="sd">        for.</span>

<span class="sd">    observed (bool): (optional, default=True) If True, only return odor names</span>
<span class="sd">        in `df`.</span>

<span class="sd">    return_name1 (bool): (optional, default=False) If True, corresponding</span>
<span class="sd">        values in &#39;name1&#39; will be returned for each value in &#39;original_name1&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO might need to use name1 if original_name1 not there...</span>
    <span class="c1"># (for gui case)</span>
    <span class="n">odor_set</span> <span class="o">=</span> <span class="n">odorset_name</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">odor_set2order</span><span class="p">[</span><span class="n">odor_set</span><span class="p">]</span>
    <span class="n">observed_odors</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">original_name1</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">observed</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">order</span> <span class="k">if</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">observed_odors</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># TODO maybe just handle this externally (force all data w/in some</span>
        <span class="c1"># analysis to only have one or the other control mix) and then delete</span>
        <span class="c1"># this special casing</span>
        <span class="n">cm1</span> <span class="o">=</span> <span class="s1">&#39;control mix 1&#39;</span>
        <span class="n">cm2</span> <span class="o">=</span> <span class="s1">&#39;control mix 2&#39;</span>
        <span class="n">have_cm1</span> <span class="o">=</span> <span class="n">cm1</span> <span class="ow">in</span> <span class="n">observed_odors</span>
        <span class="n">have_cm2</span> <span class="o">=</span> <span class="n">cm2</span> <span class="ow">in</span> <span class="n">observed_odors</span>
        <span class="n">order</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">order</span> <span class="k">if</span> <span class="n">o</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">cm1</span><span class="p">,</span> <span class="n">cm2</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">have_cm1</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">have_cm2</span><span class="p">,</span> <span class="s1">&#39;df should only have either cm1 or cm2&#39;</span>
            <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cm1</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">have_cm2</span><span class="p">:</span>
            <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cm2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_name1</span><span class="p">:</span>
        <span class="n">o2n</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;original_name1&#39;</span><span class="p">,</span><span class="s1">&#39;name1&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span>
            <span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;original_name1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">name1</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">o2n</span><span class="p">[</span><span class="n">order</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">order</span></div>


<span class="c1"># TODO TODO delete no_append_gid code? still used (at least in mb_team_gsheet below)?</span>
<span class="c1"># (also seems like natural_odors/literature_data expects this, tho kwarg not passed.</span>
<span class="c1"># maybe default changed?)</span>
<span class="c1"># TODO get rid of gid kwarg and just require it to be in url?</span>
<div class="viewcode-block" id="gsheet_csv_export_link"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.gsheet_csv_export_link">[docs]</a><span class="k">def</span> <span class="nf">gsheet_csv_export_link</span><span class="p">(</span><span class="n">file_with_edit_link</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Pathlike</span><span class="p">],</span>
    <span class="n">gid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">no_append_gid</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">extra_search_dirs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Pathlike</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a gsheet link copied from browser while editing it, and returns a</span>
<span class="sd">    URL suitable for reading it as a CSV into a DataFrame.</span>

<span class="sd">    GID seems to default to 0 for the first sheet, but seems unpredictable for further</span>
<span class="sd">    sheets in the same document, though you can extract it from the URL in those cases.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">file_with_edit_link</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;http&#39;</span><span class="p">):</span>
        <span class="n">url</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">file_with_edit_link</span><span class="p">)</span>

    <span class="c1"># If the input wasn&#39;t a link itself, then it should be a path to a file containing</span>
    <span class="c1"># the link.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># with hong2p installed editable as I typically have it, this will be the root</span>
        <span class="c1"># of hong2p (e.g. ~/src/hong2p, not ~/src/hong2p/hong2p)</span>
        <span class="n">hong2p_root</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span>

        <span class="n">dirs_to_try</span> <span class="o">=</span> <span class="p">(</span><span class="n">Path</span><span class="o">.</span><span class="n">cwd</span><span class="p">(),</span> <span class="n">hong2p_root</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">extra_search_dirs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dirs_to_try</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">extra_search_dirs</span><span class="p">)</span> <span class="o">+</span> <span class="n">dirs_to_try</span>

        <span class="c1"># .txt file containing link</span>
        <span class="n">link_txt_path</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dirs_to_try</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">d</span> <span class="o">/</span> <span class="n">file_with_edit_link</span>
            <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="n">link_txt_path</span> <span class="o">=</span> <span class="n">path</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">link_txt_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">file_with_edit_link</span><span class="si">}</span><span class="s1"> not found in any of </span><span class="si">{</span><span class="n">dirs_to_try</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">url</span> <span class="o">=</span> <span class="n">link_txt_path</span><span class="o">.</span><span class="n">read_text</span><span class="p">()</span>

    <span class="n">base_url_and_param_seperator</span> <span class="o">=</span> <span class="s1">&#39;/edit&#39;</span>
    <span class="k">if</span> <span class="n">base_url_and_param_seperator</span> <span class="ow">in</span> <span class="n">url</span><span class="p">:</span>
        <span class="n">base_url</span><span class="p">,</span> <span class="n">http_params</span> <span class="o">=</span> <span class="n">url</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">base_url_and_param_seperator</span><span class="p">)</span>

        <span class="c1"># TODO test in places called w/ str input (where presumably &#39;/edit&#39; (and</span>
        <span class="c1"># following) isn&#39;t in URL (tho it probably should be now)</span>
        <span class="c1"># TODO use this code in other path too</span>
        <span class="n">http_param_parts</span> <span class="o">=</span> <span class="n">http_params</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)</span>
        <span class="n">gid_param_prefix</span> <span class="o">=</span> <span class="s1">&#39;gid=&#39;</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">http_param_parts</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">gid_param_prefix</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">gid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;gid specified in both file_with_edit_link and gid&#39;</span>
                        <span class="s1">&#39; args&#39;</span>
                    <span class="p">)</span>

                <span class="n">gid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">gid_param_prefix</span><span class="p">):])</span>
                <span class="c1"># Assuming gid=&lt;x&gt; not specified more than once in URL</span>
                <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">base_url</span> <span class="o">=</span> <span class="n">url</span>

    <span class="c1"># TODO get proper error in gsheet_to_frame if we default to gid=0 and that gid</span>
    <span class="c1"># somehow doesn&#39;t exist on sheet (possible? maybe if first sheet deleted?)</span>
    <span class="c1"># TODO warn in this case?</span>
    <span class="k">if</span> <span class="n">gid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Seems to be default for first sheet</span>
        <span class="n">gid</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">gsheet_link</span> <span class="o">=</span> <span class="n">base_url</span> <span class="o">+</span> <span class="s1">&#39;/export?format=csv&amp;gid=&#39;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">no_append_gid</span><span class="p">:</span>
        <span class="n">gsheet_link</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">gid</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">gsheet_link</span></div>


<span class="c1"># TODO add option to strip whitespace + replace whitespace-only cells with NaN</span>
<span class="c1"># (then maybe use in natural_odors/literature_data)</span>
<div class="viewcode-block" id="gsheet_to_frame"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.gsheet_to_frame">[docs]</a><span class="k">def</span> <span class="nf">gsheet_to_frame</span><span class="p">(</span><span class="n">file_with_edit_link</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">gid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">bool_fillna_false</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">convert_date_col</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">drop_trailing_bools</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">restore_ints</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">normalize_col_names</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">use_cache</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">extra_search_dirs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Pathlike</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="c1"># TODO doc file_with_edit_link / gid (w/ expected format + how to get them)</span>
    <span class="c1"># TODO want to allow str url for file_with_edit_link too (allowed in called fn)?</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        file_with_edit_link: </span>

<span class="sd">        gid: </span>

<span class="sd">        bool_fillna_false: whether to replace missing values in columns that otherwise</span>
<span class="sd">            only contain True/False with False. will convert column dtype to &#39;bool&#39; as</span>
<span class="sd">            well.</span>

<span class="sd">        convert_date_col: whether to convert the contents of any columns named &#39;date&#39;</span>
<span class="sd">            (case insensitive) to `pd.Timestamp`</span>

<span class="sd">        drop_trailing_bools: whether to drop blocks of False in bool columns beyond the</span>
<span class="sd">            last row where all non-bool columns have any non-NaN values.</span>

<span class="sd">            If a column has data validation for a boolean, the frame will have values</span>
<span class="sd">            (False as I&#39;ve seen it so far) through to the end of the validation range,</span>
<span class="sd">            despite the fact that no data has been entered.</span>

<span class="sd">        restore_ints: whether to convert columns parsed as floats (because missing data</span>
<span class="sd">            in rows where only default values for bool cols are present) to an integer</span>
<span class="sd">            type. Requires that drop_trailing_bools actually gets rid of all the NaN</span>
<span class="sd">            values in the columns to be converted to ints (float columns with only whole</span>
<span class="sd">            number / NaN values).</span>

<span class="sd">        normalize_col_names: whether to rename columns using the</span>
<span class="sd">            `hong2p.util.to_filename` (with `period=False` to that function) as well as</span>
<span class="sd">            lowercasing.</span>

<span class="sd">        use_cache: whether to try loading cached Google sheet data, if there is a</span>
<span class="sd">            connection error when trying to load the sheet data from online. Each call</span>
<span class="sd">            will unconditionally write to this cache, saved as a hidden file in the same</span>
<span class="sd">            directory as `file_with_edit_link`.</span>

<span class="sd">        extra_search_dirs: extra directories to search for file with name</span>
<span class="sd">            `file_with_edit_link`. will be searched before defaults (current directory</span>
<span class="sd">            and hong2p root)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">file_with_edit_link</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">file_with_edit_link</span><span class="p">)</span>

    <span class="n">gsheet_link</span> <span class="o">=</span> <span class="n">gsheet_csv_export_link</span><span class="p">(</span><span class="n">file_with_edit_link</span><span class="p">,</span> <span class="n">gid</span><span class="o">=</span><span class="n">gid</span><span class="p">,</span>
        <span class="n">extra_search_dirs</span><span class="o">=</span><span class="n">extra_search_dirs</span>
    <span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">gsheet_link</span><span class="p">)</span>

    <span class="c1"># This might not always be the error, depending on the pandas version.</span>
    <span class="c1"># Tested with 1.3.1</span>
    <span class="k">except</span> <span class="n">URLError</span><span class="p">:</span>
        <span class="n">use_cache</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># TODO support file_with_edit_link being url str too (+ change type hint), or maybe</span>
    <span class="c1"># unsupport that in other gsheet fn</span>
    <span class="n">cache_path</span> <span class="o">=</span> <span class="n">file_with_edit_link</span><span class="o">.</span><span class="n">parent</span> <span class="o">/</span> <span class="sa">f</span><span class="s1">&#39;.</span><span class="si">{</span><span class="n">file_with_edit_link</span><span class="o">.</span><span class="n">stem</span><span class="si">}</span><span class="s1">_cache.p&#39;</span>

    <span class="k">if</span> <span class="n">use_cache</span> <span class="ow">and</span> <span class="n">cache_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;using Google sheet cache at </span><span class="si">{</span><span class="n">cache_path</span><span class="si">}</span><span class="s1">. may be out-of-date!&#39;</span><span class="p">)</span>

        <span class="c1"># TODO factor this + writing below into [load|write]_pickle(Path, ...) fns?</span>
        <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">cache_path</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">())</span>

    <span class="n">bool_col_unique_vals</span> <span class="o">=</span> <span class="p">{</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">}</span>
    <span class="c1"># TODO may want to change issubset call to exclude cols where there is somehow only</span>
    <span class="c1"># NaN with dtype is still being &#39;object&#39; (shouldn&#39;t be possible though, at least as</span>
    <span class="c1"># long as this is the first step?)</span>
    <span class="n">bool_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;bool&#39;</span> <span class="ow">or</span>
        <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;object&#39;</span> <span class="ow">and</span> <span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">bool_col_unique_vals</span><span class="p">))</span>
    <span class="p">]</span>

    <span class="k">if</span> <span class="n">bool_fillna_false</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">bool_cols</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>

    <span class="c1"># Could consider replacing this w/ just parse_dates [+ infer_datetime_format] kwargs</span>
    <span class="c1"># to pd.read_csv</span>
    <span class="k">if</span> <span class="n">convert_date_col</span><span class="p">:</span>
        <span class="n">date_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;date&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">date_cols</span><span class="p">:</span>
           <span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">drop_trailing_bools</span><span class="p">:</span>
        <span class="n">nonbool_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bool_cols</span><span class="p">]</span>
        <span class="n">nonbool_cols_some_data</span> <span class="o">=</span> <span class="o">~</span> <span class="n">df</span><span class="p">[</span><span class="n">nonbool_cols</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>

        <span class="n">last_row_with_data_idx</span> <span class="o">=</span> <span class="n">nonbool_cols_some_data</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nonbool_cols_some_data</span>
            <span class="p">)</span><span class="o">.</span><span class="n">last_valid_index</span><span class="p">()</span>

        <span class="n">will_be_dropped</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[(</span><span class="n">last_row_with_data_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):]</span>

        <span class="c1"># We expect all bool_cols beyond last data in non-bool cols to be False</span>
        <span class="c1"># (default value as I currently have the data validation for those columns in</span>
        <span class="c1"># most / all Gsheets where I use them)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">will_be_dropped</span><span class="p">[</span><span class="n">bool_cols</span><span class="p">]</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">len_before</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

        <span class="c1"># TODO still works if last row actually does have data, right?</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:(</span><span class="n">last_row_with_data_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">assert</span> <span class="n">len_before</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">will_be_dropped</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">restore_ints</span><span class="p">:</span>
        <span class="c1"># (works for &#39;float64&#39; at least, presumably all float types)</span>
        <span class="n">float_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;float&#39;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">float_cols</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>

            <span class="c1"># If dropping trailing NaN values didn&#39;t get rid of all the NaN, we can&#39;t</span>
            <span class="c1"># change the dtype of the column to a numpy integer type.</span>
            <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">continue</span>

            <span class="n">mod1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># TODO actually a risk of floats not exactly having mod 1 of 0 if input is</span>
            <span class="c1"># indeed an integer for all of them? assuming no for now.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">mod1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">normalize_col_names</span><span class="p">:</span>
        <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">to_filename</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">cache_path</span><span class="o">.</span><span class="n">write_bytes</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">df</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">df</span></div>


<span class="c1"># TODO TODO for this and other stuff that depends on network access (if not</span>
<span class="c1"># cached), fallback to cache (unless explicitly prevented?), and warn</span>
<span class="c1"># that we are doing so (unless cached version explicitly requested)</span>
<span class="n">_mb_team_gsheet</span> <span class="o">=</span> <span class="kc">None</span>
<div class="viewcode-block" id="mb_team_gsheet"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.mb_team_gsheet">[docs]</a><span class="k">def</span> <span class="nf">mb_team_gsheet</span><span class="p">(</span><span class="n">use_cache</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">natural_odors_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">drop_nonexistant_dirs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show_inferred_paths</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">print_excluded_on_disk</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Returns a pandas.DataFrame with data on flies and MB team recordings.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">global</span> <span class="n">_mb_team_gsheet</span>
    <span class="k">if</span> <span class="n">_mb_team_gsheet</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_mb_team_gsheet</span>

    <span class="n">gsheet_cache_file</span> <span class="o">=</span> <span class="s1">&#39;.gsheet_cache.p&#39;</span>
    <span class="k">if</span> <span class="n">use_cache</span> <span class="ow">and</span> <span class="n">exists</span><span class="p">(</span><span class="n">gsheet_cache_file</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Loading MB team sheet data from cache at </span><span class="si">{</span><span class="n">gsheet_cache_file</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">gsheet_cache_file</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">sheets</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># TODO TODO maybe env var pointing to this? or w/ link itself?</span>
        <span class="c1"># TODO maybe just get relative path from __file__ w/ /.. or something?</span>
        <span class="c1"># TODO give this an [add_]default_gid=True (set to False here) so other code of</span>
        <span class="c1"># mine can use this function (this not served by no_append_gid?)</span>
        <span class="n">gsheet_link</span> <span class="o">=</span> <span class="n">gsheet_csv_export_link</span><span class="p">(</span><span class="s1">&#39;mb_team_sheet_link.txt&#39;</span><span class="p">,</span>
            <span class="n">no_append_gid</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># If you want to add more sheets, when you select the new sheet in your</span>
        <span class="c1"># browser, the GID will be at the end of the URL in the address bar.</span>
        <span class="n">sheet_gids</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;fly_preps&#39;</span><span class="p">:</span> <span class="s1">&#39;269082112&#39;</span><span class="p">,</span>
            <span class="s1">&#39;recordings&#39;</span><span class="p">:</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span>
            <span class="s1">&#39;daily_settings&#39;</span><span class="p">:</span> <span class="s1">&#39;229338960&#39;</span>
        <span class="p">}</span>

        <span class="n">sheets</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">df_name</span><span class="p">,</span> <span class="n">gid</span> <span class="ow">in</span> <span class="n">sheet_gids</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># TODO replace w/ gsheet_to_frame?</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">gsheet_link</span> <span class="o">+</span> <span class="n">gid</span><span class="p">)</span>

            <span class="c1"># TODO convert any other dtypes?</span>
            <span class="k">if</span> <span class="s1">&#39;date&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">])</span>

            <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Unnamed: &#39;</span><span class="p">)],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="s1">&#39;fly_num&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">last_with_fly_num</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">fly_num</span><span class="o">.</span><span class="n">notnull</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()</span>
                <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[(</span><span class="n">last_with_fly_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):]</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">sheets</span><span class="p">[</span><span class="n">df_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>

        <span class="n">boolean_columns</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;attempt_analysis&#39;</span><span class="p">,</span>
            <span class="s1">&#39;raw_data_discarded&#39;</span><span class="p">,</span>
            <span class="s1">&#39;raw_data_lost&#39;</span>
        <span class="p">}</span>
        <span class="n">na_cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sheets</span><span class="p">[</span><span class="s1">&#39;recordings&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">-</span> <span class="n">boolean_columns</span><span class="p">)</span>
        <span class="n">sheets</span><span class="p">[</span><span class="s1">&#39;recordings&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="n">na_cols</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">gsheet_cache_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">sheets</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

    <span class="c1"># TODO maybe make df some merge of the three sheets?</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">sheets</span><span class="p">[</span><span class="s1">&#39;recordings&#39;</span><span class="p">]</span>

    <span class="c1"># TODO TODO maybe flag to disable path inference / rethink how it should</span>
    <span class="c1"># interact w/ timestamp based correspondence between thorsync/image and</span>
    <span class="c1"># mapping that to the recordings in the gsheet</span>
    <span class="c1"># TODO should inference that reads the metadata happen in this fn?</span>
    <span class="c1"># maybe yes, but still factor it out and just call here?</span>

    <span class="c1"># TODO maybe start by not filling in fully-empty groups / flagging</span>
    <span class="c1"># them for later -&gt; preferring to infer those from local files -&gt;</span>
    <span class="c1"># then inferring fully-empty groups from default numbering as before</span>

    <span class="c1"># TODO try to replace w/ central key definition (module level)</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">,</span> <span class="s1">&#39;fly_num&#39;</span><span class="p">]</span>
    <span class="c1"># These should happen before rows start being dropped, because the dropped</span>
    <span class="c1"># rows might have the information needed to ffill.</span>
    <span class="c1"># This should NOT ffill a fly_past a change in date.</span>

    <span class="c1"># Assuming that if date changes, even if fly_nums keep going up, that was</span>
    <span class="c1"># intentional.</span>
    <span class="n">df</span><span class="o">.</span><span class="n">date</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;ffill&#39;</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">fly_num</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;date&#39;</span><span class="p">)[</span><span class="s1">&#39;fly_num&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">ffill</span><span class="p">()</span><span class="o">.</span><span class="n">bfill</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="c1"># This will only apply to groups (dates) where there are ONLY missing</span>
    <span class="c1"># fly_nums, given filling logic above.</span>
    <span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;fly_num&#39;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">df</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>

    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;stimulus_data_file&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;stimulus_data_file&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;ffill&#39;</span><span class="p">)</span>

    <span class="n">df</span><span class="o">.</span><span class="n">raw_data_discarded</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">raw_data_discarded</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># TODO say when this happens?</span>
    <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">raw_data_discarded</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># TODO TODO warn if &#39;attempt_analysis&#39; and either discard / lost is checked</span>

    <span class="c1"># Not sure where there were any NaN here anyway...</span>
    <span class="n">df</span><span class="o">.</span><span class="n">raw_data_lost</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">raw_data_lost</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">raw_data_lost</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># TODO as per note below, any thorimage/thorsync dirs entered in spreadsheet</span>
    <span class="c1"># should probably cause warning/err if either of above rejection reason</span>
    <span class="c1"># is checked</span>

    <span class="c1"># This happens after data is dropped for the above two reasons, because</span>
    <span class="c1"># generally those mistakes do not consume any of our sequential filenames.</span>
    <span class="c1"># They should not have files associated with them, and the Google sheet</span>
    <span class="c1"># information on them is just for tracking problems / efficiency.</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;recording_num&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span><span class="o">.</span><span class="n">cumcount</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">show_inferred_paths</span><span class="p">:</span>
        <span class="n">missing_thorimage</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">thorimage_dir</span><span class="p">)</span>
        <span class="n">missing_thorsync</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">thorsync_dir</span><span class="p">)</span>

    <span class="n">my_project</span> <span class="o">=</span> <span class="s1">&#39;natural_odors&#39;</span>

    <span class="c1"># TODO TODO fix current behavior where key groups that have nothing filled</span>
    <span class="c1"># in on gsheet (for dirs) will default to old format.  misbehaving for</span>
    <span class="c1"># 8-27/1 and all of 11-21, for example. (fixed?)</span>

    <span class="n">check_and_set</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">gn</span><span class="p">,</span> <span class="n">gdf</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">project</span> <span class="o">==</span> <span class="n">my_project</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">gdf</span><span class="p">[[</span><span class="s1">&#39;thorimage_dir&#39;</span><span class="p">,</span><span class="s1">&#39;thorsync_dir&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">fly_dir</span> <span class="o">=</span> <span class="n">raw_fly_dir</span><span class="p">(</span><span class="o">*</span><span class="n">gn</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">fly_dir</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">fly_dir</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Since we are disabling check that ThorImage nums (from naming</span>
                <span class="c1"># convention) are unique, we must check this before</span>
                <span class="c1"># mb_team_gsheet returns.</span>
                <span class="n">image_and_sync_pairs</span> <span class="o">=</span> <span class="n">thor</span><span class="o">.</span><span class="n">pair_thor_subdirs</span><span class="p">(</span><span class="n">fly_dir</span><span class="p">,</span>
                     <span class="n">check_against_naming_conv</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">check_unique_thorimage_nums</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pairs:&#39;</span><span class="p">)</span>
                    <span class="n">pprint</span><span class="p">(</span><span class="n">image_and_sync_pairs</span><span class="p">)</span>

            <span class="c1"># TODO TODO should ValueError actually be caught?</span>
            <span class="c1"># (from comments in other fns) it seems it will only be raised</span>
            <span class="c1"># when they are not 1:1, which should maybe cause failure in the way</span>
            <span class="c1"># AssertionErrors do now...</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">gn_str</span> <span class="o">=</span> <span class="n">format_keys</span><span class="p">(</span><span class="o">*</span><span class="n">gn</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;For </span><span class="si">{</span><span class="n">gn_str</span><span class="si">}</span><span class="s1">:&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;could not pair thor dirs automatically!&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s1">)</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># could maybe try to sort things into &quot;prep checking&quot; / real</span>
            <span class="c1"># experiment based on time length or something (and maybe try</span>
            <span class="c1"># to fall back to just pairing w/ real experiments? and extending</span>
            <span class="c1"># condition below to # real experiments in gdf)</span>
            <span class="n">n_matched</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">image_and_sync_pairs</span><span class="p">)</span>
            <span class="n">ng</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span>
            <span class="c1"># TODO should this be an error (was previously just a</span>
            <span class="c1"># print + continue)?</span>
            <span class="k">if</span> <span class="n">n_matched</span> <span class="o">&lt;</span> <span class="n">ng</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;more rows for (date, fly) pair than matched outputs&#39;</span>
                    <span class="sa">f</span><span class="s1">&#39; (</span><span class="si">{</span><span class="n">n_matched</span><span class="si">}</span><span class="s1"> &lt; </span><span class="si">{</span><span class="n">ng</span><span class="si">}</span><span class="s1">)&#39;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="c1">#print(msg)</span>
                <span class="c1">#continue</span>

            <span class="n">all_group_in_old_dir_fmt</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">group_tids</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">group_tsds</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">tid</span><span class="p">,</span> <span class="n">tsd</span> <span class="ow">in</span> <span class="n">image_and_sync_pairs</span><span class="p">:</span>
                <span class="n">tid</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">tid</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">thor</span><span class="o">.</span><span class="n">old_fmt_thorimage_num</span><span class="p">(</span><span class="n">tid</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">tid</span><span class="si">}</span><span class="s1"> not in old format&#39;</span><span class="p">)</span>
                    <span class="n">all_group_in_old_dir_fmt</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="n">group_tids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tid</span><span class="p">)</span>
                <span class="n">group_tsds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">tsd</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Not immediately setting df in this case, so that I can check</span>
            <span class="c1"># these results against the old way of doing things.</span>
            <span class="k">if</span> <span class="n">all_group_in_old_dir_fmt</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;all in old dir format&#39;</span><span class="p">)</span>

                <span class="n">check_and_set</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">gn</span><span class="p">,</span> <span class="n">gdf</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">group_tids</span><span class="p">,</span> <span class="n">group_tsds</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;filling in b/c not (all) in old dir format&#39;</span><span class="p">)</span>

                <span class="c1"># TODO is it ok to modify df used to create groupby while</span>
                <span class="c1"># iterating over groupby?</span>
                <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gdf</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;thorimage_dir&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_tids</span>
                <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gdf</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;thorsync_dir&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_tsds</span>

    <span class="k">if</span> <span class="n">print_excluded_on_disk</span><span class="p">:</span>
        <span class="c1"># So that we can exclude these directories when printing stuff on disk</span>
        <span class="c1"># (but not in df) later, to reduce noise (because of course other</span>
        <span class="c1"># project stuff is dropped and will not be mentioned in df).</span>
        <span class="n">ti_from_other_projects</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">ts_from_other_projects</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">gn</span><span class="p">,</span> <span class="n">gdf</span> <span class="ow">in</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">project</span> <span class="o">!=</span> <span class="n">my_project</span><span class="p">]</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
            <span class="n">fly_dir</span> <span class="o">=</span> <span class="n">raw_fly_dir</span><span class="p">(</span><span class="o">*</span><span class="n">gn</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">fly_dir</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">gdf_ti</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">thorimage_dir</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="n">fly_dir</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="n">gdf_ts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">thorsync_dir</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="n">fly_dir</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
            <span class="p">)</span>

            <span class="n">ti_from_other_projects</span> <span class="o">|=</span> <span class="n">gdf_ti</span>
            <span class="n">ts_from_other_projects</span> <span class="o">|=</span> <span class="n">gdf_ts</span>

    <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">project</span> <span class="o">!=</span> <span class="n">my_project</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># TODO TODO implement option to (at least) also keep prep checking that</span>
    <span class="c1"># preceded natural_odors (or maybe just that was on the same day)</span>
    <span class="c1"># (so that i can get all that ethyl acetate data for use as a reference</span>
    <span class="c1"># odor)</span>

    <span class="c1"># TODO display stuff inferred from files separately from stuff inferred</span>
    <span class="c1"># from combination of gsheet info and convention</span>

    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;thorimage_num&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">thorimage_dir</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">thor</span><span class="o">.</span><span class="n">old_fmt_thorimage_num</span><span class="p">)</span>
    <span class="c1"># TODO TODO should definition of consistency be changed to just check that</span>
    <span class="c1"># the ranking of the two are the same?</span>
    <span class="c1"># (maybe just if the group is all new format (which will have first real</span>
    <span class="c1"># experiments start w/ thorimage_num zero more often, b/c fn / fn_0000</span>
    <span class="c1"># thing)</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;numbering_consistent&#39;</span><span class="p">]</span> <span class="o">=</span> \
        <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">thorimage_num</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">thorimage_num</span> <span class="o">==</span> <span class="n">df</span><span class="o">.</span><span class="n">recording_num</span><span class="p">)</span>

    <span class="c1"># TODO unit test this</span>
    <span class="c1"># TODO TODO check that, if there are mismatches here, that they *never*</span>
    <span class="c1"># happen when recording num will be used for inference in rows in the group</span>
    <span class="c1"># *after* the mismatch (?)</span>
    <span class="n">gkeys</span> <span class="o">=</span> <span class="n">keys</span> <span class="o">+</span> <span class="p">[</span>
        <span class="s1">&#39;thorimage_dir&#39;</span><span class="p">,</span>
        <span class="s1">&#39;thorsync_dir&#39;</span><span class="p">,</span>
        <span class="s1">&#39;thorimage_num&#39;</span><span class="p">,</span>
        <span class="s1">&#39;recording_num&#39;</span><span class="p">,</span>
        <span class="s1">&#39;numbering_consistent&#39;</span>
    <span class="p">]</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">group_df</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
        <span class="c1"># TODO maybe refactor above so case 3 collapses into case 1?</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Case 1: all consistent</span>
<span class="sd">        Case 2: not all consistent, but all thorimage_dir filled in</span>
<span class="sd">        Case 3: not all consistent, but just because thorimage_dir was null</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#print(group_df[gkeys])</span>

        <span class="c1"># TODO check that first_mismatch based approach includes this case</span>
        <span class="c1">#if pd.notnull(group_df.thorimage_dir).all():</span>
        <span class="c1">#    continue</span>

        <span class="n">mismatches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="o">~</span> <span class="n">group_df</span><span class="o">.</span><span class="n">numbering_consistent</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mismatches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">first_mismatch_idx</span> <span class="o">=</span> <span class="n">mismatches</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#print(&#39;first_mismatch:\n&#39;, group_df[gkeys].iloc[first_mismatch_idx])</span>

        <span class="c1"># TODO test case where the first mismatch is last</span>
        <span class="n">following_thorimage_dirs</span> <span class="o">=</span> \
            <span class="n">group_df</span><span class="o">.</span><span class="n">thorimage_dir</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">first_mismatch_idx</span><span class="p">:]</span>
        <span class="c1">#print(&#39;checking these are not null:\n&#39;, following_thorimage_dirs)</span>
        <span class="k">assert</span> <span class="n">pd</span><span class="o">.</span><span class="n">notnull</span><span class="p">(</span><span class="n">following_thorimage_dirs</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

    <span class="n">df</span><span class="o">.</span><span class="n">thorsync_dir</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">thorimage_num</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;SyncData</span><span class="si">{:03d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">))),</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>

    <span class="c1"># Leaving recording_num because it might be prettier to use that for</span>
    <span class="c1"># IDs in figure than whatever Thor output directory naming convention.</span>
    <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;thorimage_num&#39;</span><span class="p">,</span><span class="s1">&#39;numbering_consistent&#39;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># TODO TODO check for conditions in which we might need to renumber</span>
    <span class="c1"># recording num? (dupes / any entered numbers along the way that are</span>
    <span class="c1"># inconsistent w/ recording_num results)</span>
    <span class="c1"># TODO update to handle case where thorimage dir does not start w/</span>
    <span class="c1"># _ and is not just 3 digits after that?</span>
    <span class="c1"># (see what format other stuff from day is?)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">thorimage_dir</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">recording_num</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;_</span><span class="si">{:03d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">))),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">thorsync_dir</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">recording_num</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;SyncData</span><span class="si">{:03d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">))),</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>

    <span class="k">for</span> <span class="n">gn</span><span class="p">,</span> <span class="n">gidx</span><span class="p">,</span> <span class="n">gtids</span><span class="p">,</span> <span class="n">gtsds</span> <span class="ow">in</span> <span class="n">check_and_set</span><span class="p">:</span>
        <span class="c1"># Since some stuff may have been dropped (prep checking stuff, etc).</span>
        <span class="n">still_in_idx</span> <span class="o">=</span> <span class="n">gidx</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="c1"># No group w/ files on NAS should have been dropped completely.</span>
        <span class="k">assert</span> <span class="n">still_in_idx</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;group </span><span class="si">{</span><span class="n">gn</span><span class="si">}</span><span class="s1"> dropped completely&#39;</span>

        <span class="n">gidx</span> <span class="o">=</span> <span class="n">gidx</span><span class="p">[</span><span class="n">still_in_idx</span><span class="p">]</span>
        <span class="n">gtids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gtids</span><span class="p">)[</span><span class="n">still_in_idx</span><span class="p">]</span>
        <span class="n">gtsds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gtsds</span><span class="p">)[</span><span class="n">still_in_idx</span><span class="p">]</span>

        <span class="n">from_gsheet</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gidx</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;thorimage_dir&#39;</span><span class="p">,</span> <span class="s1">&#39;thorsync_dir&#39;</span><span class="p">]]</span>
        <span class="n">from_thor</span> <span class="o">=</span> <span class="p">[</span><span class="n">gtids</span><span class="p">,</span> <span class="n">gtsds</span><span class="p">]</span>
        <span class="n">consistent</span> <span class="o">=</span> <span class="p">(</span><span class="n">from_gsheet</span> <span class="o">==</span> <span class="n">from_thor</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">consistent</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Inconsistency between path infererence methods!&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">gn</span><span class="p">)))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Derived from Google sheet:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">from_gsheet</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;From matching Thor output files:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">from_gsheet</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">from_thor</span><span class="p">))</span>
                <span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;inconsistent rankings w/ old format&#39;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">df</span><span class="o">.</span><span class="n">fly_num</span><span class="o">.</span><span class="n">notnull</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">astype</span><span class="p">({</span><span class="s1">&#39;fly_num&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">})</span>

    <span class="n">cols</span> <span class="o">=</span> <span class="n">keys</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;thorimage_dir&#39;</span><span class="p">,</span> <span class="s1">&#39;thorsync_dir&#39;</span><span class="p">,</span> <span class="s1">&#39;attempt_analysis&#39;</span><span class="p">]</span>
    <span class="c1"># TODO flag to do this only for stuff marked attempt_analysis</span>
    <span class="k">if</span> <span class="n">show_inferred_paths</span><span class="p">:</span>
        <span class="c1"># TODO only do this if any actually *were* inferred</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Inferred ThorImage directories:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">missing_thorimage</span><span class="p">,</span> <span class="n">cols</span><span class="p">]</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Inferred ThorSync directories:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">missing_thorsync</span><span class="p">,</span> <span class="n">cols</span><span class="p">]</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="n">duped_thorimage</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="n">keys</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;thorimage_dir&#39;</span><span class="p">],</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">duped_thorsync</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="n">keys</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;thorsync_dir&#39;</span><span class="p">],</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">duped_thorimage</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">duped_thorsync</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Duplicated ThorImage directories after path inference:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">duped_thorimage</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Duplicated ThorSync directories after path inference:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">duped_thorsync</span><span class="p">])</span>
        <span class="k">raise</span>

    <span class="n">flies</span> <span class="o">=</span> <span class="n">sheets</span><span class="p">[</span><span class="s1">&#39;fly_preps&#39;</span><span class="p">]</span>
    <span class="n">flies</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">flies</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;ffill&#39;</span><span class="p">)</span>
    <span class="n">flies</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">,</span><span class="s1">&#39;fly_num&#39;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># TODO maybe flag to not update database? or just don&#39;t?</span>
    <span class="c1"># TODO groups all inserts into transactions across tables, and as few as</span>
    <span class="c1"># possible (i.e. only do this later)?</span>
    <span class="n">db</span><span class="o">.</span><span class="n">to_sql_with_duplicates</span><span class="p">(</span><span class="n">flies</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="s1">&#39;prep_date&#39;</span><span class="p">}),</span> <span class="s1">&#39;flies&#39;</span>
    <span class="p">)</span>

    <span class="c1"># For manual sanity checking that important data isn&#39;t being excluded</span>
    <span class="c1"># inappropriately.</span>
    <span class="k">if</span> <span class="n">print_excluded_on_disk</span><span class="p">:</span>
        <span class="n">ti_ondisk_not_in_df</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">ts_ondisk_not_in_df</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">gn</span><span class="p">,</span> <span class="n">gdf</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
            <span class="n">fly_dir</span> <span class="o">=</span> <span class="n">raw_fly_dir</span><span class="p">(</span><span class="o">*</span><span class="n">gn</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">fly_dir</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Need them somewhat absolute (w/ date + fly info at least), so that</span>
            <span class="c1"># set operations on directories across (date, fly) combinations are</span>
            <span class="c1"># meaningful.</span>
            <span class="n">gdf_ti</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">thorimage_dir</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="n">fly_dir</span><span class="p">,</span> <span class="n">d</span><span class="p">)))</span>
            <span class="n">gdf_ts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">thorsync_dir</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="n">fly_dir</span><span class="p">,</span> <span class="n">d</span><span class="p">)))</span>

            <span class="n">thorimage_dirs</span><span class="p">,</span> <span class="n">thorsync_dirs</span> <span class="o">=</span> <span class="n">thor</span><span class="o">.</span><span class="n">thor_subdirs</span><span class="p">(</span><span class="n">fly_dir</span><span class="p">)</span>
            <span class="n">ti_ondisk_not_in_df</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">thorimage_dirs</span><span class="p">)</span> <span class="o">-</span> <span class="n">gdf_ti</span>
            <span class="n">ts_ondisk_not_in_df</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">thorsync_dirs</span><span class="p">)</span> <span class="o">-</span> <span class="n">gdf_ts</span>

        <span class="c1"># Excluding other-project stuff that was dropped from df earlier.</span>
        <span class="n">ti_ondisk_not_in_df</span> <span class="o">-=</span> <span class="n">ti_from_other_projects</span>
        <span class="n">ts_ondisk_not_in_df</span> <span class="o">-=</span> <span class="n">ts_from_other_projects</span>

        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> directories on disk but not in DataFrame (from gsheet):&#39;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ti_ondisk_not_in_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;ThorImage&#39;</span><span class="p">))</span>
            <span class="n">pprint</span><span class="p">(</span><span class="n">ti_ondisk_not_in_df</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ts_ondisk_not_in_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;ThorSync&#39;</span><span class="p">))</span>
            <span class="n">pprint</span><span class="p">(</span><span class="n">ts_ondisk_not_in_df</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="n">fly_dirs</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">raw_fly_dir</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">date</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">fly_num</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">abs_thorimage_dirs</span> <span class="o">=</span> <span class="n">fly_dirs</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">others</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">thorimage_dir</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
    <span class="n">abs_thorsync_dirs</span> <span class="o">=</span> <span class="n">fly_dirs</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">others</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">thorsync_dir</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
    <span class="n">thorimage_exists</span> <span class="o">=</span> <span class="n">abs_thorimage_dirs</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">isdir</span><span class="p">)</span>
    <span class="n">thorsync_exists</span> <span class="o">=</span> <span class="n">abs_thorsync_dirs</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">isdir</span><span class="p">)</span>
    <span class="n">any_dir_missing</span> <span class="o">=</span> <span class="o">~</span> <span class="p">(</span><span class="n">thorimage_exists</span> <span class="o">&amp;</span> <span class="n">thorsync_exists</span><span class="p">)</span>

    <span class="n">any_missing_marked_attempt</span> <span class="o">=</span> <span class="p">(</span><span class="n">any_dir_missing</span> <span class="o">&amp;</span> <span class="n">df</span><span class="o">.</span><span class="n">attempt_analysis</span><span class="p">)</span>
    <span class="c1"># TODO maybe an option to just warn here, rather than failing</span>
    <span class="k">if</span> <span class="n">any_missing_marked_attempt</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Directories marked attempt analysis with missing data:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">any_missing_marked_attempt</span><span class="p">,</span> <span class="n">cols</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">to_string</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;some experiments marked attempt_analysis &#39;</span>
            <span class="s1">&#39;had some data directories missing&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">drop_nonexistant_dirs</span><span class="p">:</span>
        <span class="n">n_to_drop</span> <span class="o">=</span> <span class="n">any_dir_missing</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">n_to_drop</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Dropping </span><span class="si">{</span><span class="n">n_to_drop</span><span class="si">}</span><span class="s1"> rows because directories did not exist.&#39;</span>
            <span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">any_dir_missing</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># TODO TODO is 2019-08-27 fn_0000 stuff inferred correctly?</span>
    <span class="c1"># (will have same thorimage num as fn) (?)</span>
    <span class="c1"># (not critical apart from value as test case, b/c all stuff used from</span>
    <span class="c1"># that day has explicit paths in gsheet)</span>

    <span class="n">_mb_team_gsheet</span> <span class="o">=</span> <span class="n">df</span>

    <span class="c1"># TODO handle case where database is empty but gsheet cache still exists</span>
    <span class="c1"># (all inserts will probably fail, for lack of being able to reference fly</span>
    <span class="c1"># table)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="arraylike_cols"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.arraylike_cols">[docs]</a><span class="k">def</span> <span class="nf">arraylike_cols</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a list of columns that have only lists or arrays as elements.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="s1">&#39;object&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">o</span><span class="p">:</span>
        <span class="nb">type</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()]</span></div>


<span class="c1"># TODO use in other places that duplicate this functionality</span>
<span class="c1"># (like in natural_odors/kc_analysis ?)</span>
<div class="viewcode-block" id="expand_array_cols"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.expand_array_cols">[docs]</a><span class="k">def</span> <span class="nf">expand_array_cols</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Expands any list/array entries, with new rows for each entry.</span>

<span class="sd">    For any columns in `df` that have all list/array elements (at each row),</span>
<span class="sd">    the column in `out_df` will have the type of single elements from those</span>
<span class="sd">    arrays.</span>

<span class="sd">    The length of `out_df` will be the length of the input `df`, multiplied by</span>
<span class="sd">    the length (should be common in each input row) of each set of list/array</span>
<span class="sd">    elements.</span>

<span class="sd">    Other columns have their values duplicated, to match the lengths of the</span>
<span class="sd">    expanded array values.</span>

<span class="sd">    Args:</span>
<span class="sd">    `df` (pd.DataFrame)</span>

<span class="sd">    Returns:</span>
<span class="sd">    `out_df` (pd.DataFrame)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;numpy repeating may not handle index. &#39;</span>
            <span class="s1">&#39;reset_index first.&#39;</span><span class="p">)</span>

    <span class="c1"># Will be [&#39;raw_f&#39;, &#39;df_over_f&#39;, &#39;from_onset&#39;] in the main way I&#39;m using</span>
    <span class="c1"># this function.</span>
    <span class="n">array_cols</span> <span class="o">=</span> <span class="n">arraylike_cols</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">array_cols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;df did not appear to have any columns with all &#39;</span>
            <span class="s1">&#39;arraylike elements&#39;</span><span class="p">)</span>

    <span class="n">orig_dtypes</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">ac</span> <span class="ow">in</span> <span class="n">array_cols</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="n">ac</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">ac</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">ac</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">ac</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">orig_dtypes</span><span class="p">[</span><span class="n">ac</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">ac</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>

    <span class="n">non_array_cols</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">array_cols</span><span class="p">)</span>

    <span class="c1"># TODO true vectorized way to do this?</span>
    <span class="c1"># is str.len (on either rows/columns) faster (+equiv)?</span>
    <span class="n">array_lengths</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">array_cols</span><span class="p">]</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span><span class="nb">len</span><span class="p">)</span>
    <span class="n">c0</span> <span class="o">=</span> <span class="n">array_lengths</span><span class="p">[</span><span class="n">array_cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">array_cols</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">c0</span><span class="p">,</span> <span class="n">array_lengths</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
    <span class="n">array_lengths</span> <span class="o">=</span> <span class="n">c0</span>

    <span class="c1"># TODO more idiomatic / faster way to do what this loop is doing?</span>
    <span class="n">n_non_array_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_array_cols</span><span class="p">)</span>
    <span class="n">expanded_rows_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">n_repeats</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">non_array_cols</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">array_lengths</span><span class="p">):</span>
        <span class="c1"># could try subok=True if want to use pandas obj as input rather than</span>
        <span class="c1"># stuff from .values?</span>
        <span class="n">expanded_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="p">(</span><span class="n">n_repeats</span><span class="p">,</span> <span class="n">n_non_array_cols</span><span class="p">))</span>
        <span class="n">expanded_rows_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expanded_rows</span><span class="p">)</span>
    <span class="n">nac_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">expanded_rows_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">ac_data</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">array_cols</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">nac_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ac_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">nac_data</span><span class="p">,</span> <span class="n">ac_data</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">new_cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">non_array_cols</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">array_cols</span><span class="p">)</span>
    <span class="c1"># TODO copy=False is fine here, right? measure the time difference?</span>
    <span class="n">out_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">new_cols</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">orig_dtypes</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">out_df</span></div>


<span class="c1"># TODO work with NaN in inputs? i don&#39;t want NaN != NaN being reported as a difference.</span>
<span class="c1"># use my new nan_eq if needed/helpful.</span>
<span class="c1"># TODO possible to replace (some of?) this w/ pandas.DataFrame.compare?</span>
<div class="viewcode-block" id="diff_dataframes"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.diff_dataframes">[docs]</a><span class="k">def</span> <span class="nf">diff_dataframes</span><span class="p">(</span><span class="n">df1</span><span class="p">,</span> <span class="n">df2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Returns a DataFrame summarizing input differences, or None if no differences.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO do i want df1 and df2 to be allowed to be series?</span>
    <span class="c1"># (is that what they are now? need to modify anything?)</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">df1</span><span class="o">.</span><span class="n">columns</span> <span class="o">==</span> <span class="n">df2</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s1">&#39;DataFrame column names are different&#39;</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">df1</span><span class="o">.</span><span class="n">dtypes</span> <span class="o">!=</span> <span class="n">df2</span><span class="o">.</span><span class="n">dtypes</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Data Types are different, trying to convert&#39;</span><span class="p">)</span>
        <span class="n">df2</span> <span class="o">=</span> <span class="n">df2</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">df1</span><span class="o">.</span><span class="n">dtypes</span><span class="p">)</span>

    <span class="c1"># TODO is this really necessary? not an empty df in this case anyway?</span>
    <span class="k">if</span> <span class="n">df1</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">df2</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># TODO unit test w/ descrepencies in each of the cases.</span>
        <span class="c1"># TODO also test w/ nan in list / nan in float column (one / both nan)</span>
        <span class="n">floats1</span> <span class="o">=</span> <span class="n">df1</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="n">floats2</span> <span class="o">=</span> <span class="n">df2</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">floats1</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">floats2</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">diff_mask_floats</span> <span class="o">=</span> <span class="o">~</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">floats1</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">df1</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
            <span class="c1"># TODO TODO does this already deal w/ nan correctly?</span>
            <span class="c1"># otherwise, this part needs to handle possibility of nan</span>
            <span class="c1"># (it does not. need to handle.)</span>
            <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">floats1</span><span class="p">,</span> <span class="n">floats2</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">diff_mask_floats</span> <span class="o">=</span> <span class="p">(</span><span class="n">diff_mask_floats</span> <span class="o">&amp;</span>
            <span class="o">~</span><span class="p">(</span><span class="n">floats1</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">floats2</span><span class="o">.</span><span class="n">isnull</span><span class="p">()))</span>

        <span class="c1"># Just assuming, for now, that array-like cols are same across two dfs.</span>
        <span class="n">arr_cols</span> <span class="o">=</span> <span class="n">arraylike_cols</span><span class="p">(</span><span class="n">df1</span><span class="p">)</span>
        <span class="c1"># Also assuming, for now, that no elements of these lists / arrays will</span>
        <span class="c1"># be nan (which is currently true).</span>
        <span class="n">diff_mask_arr</span> <span class="o">=</span> <span class="o">~</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">arr_cols</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">df1</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">)(</span><span class="n">df1</span><span class="p">[</span><span class="n">arr_cols</span><span class="p">],</span> <span class="n">df2</span><span class="p">[</span><span class="n">arr_cols</span><span class="p">])</span>
        <span class="p">)</span>

        <span class="n">other_cols</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">df1</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">floats1</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">arr_cols</span><span class="p">)</span>
        <span class="n">other_diff_mask</span> <span class="o">=</span> <span class="n">df1</span><span class="p">[</span><span class="n">other_cols</span><span class="p">]</span> <span class="o">!=</span> <span class="n">df2</span><span class="p">[</span><span class="n">other_cols</span><span class="p">]</span>

        <span class="n">diff_mask</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">diff_mask_floats</span><span class="p">,</span> <span class="n">diff_mask_arr</span><span class="p">,</span> <span class="n">other_diff_mask</span><span class="p">],</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">diff_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">ne_stacked</span> <span class="o">=</span> <span class="n">diff_mask</span><span class="o">.</span><span class="n">stack</span><span class="p">()</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="n">ne_stacked</span><span class="p">[</span><span class="n">ne_stacked</span><span class="p">]</span>
        <span class="c1"># TODO are these what i want? prob change id (basically just to index?)?</span>
        <span class="c1"># TODO get id from index name of input dfs? and assert only one index</span>
        <span class="c1"># (assuming this wouldn&#39;t work w/ multiindex w/o modification)?</span>
        <span class="n">changed</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;col&#39;</span><span class="p">]</span>
        <span class="n">difference_locations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diff_mask</span><span class="p">)</span>
        <span class="n">changed_from</span> <span class="o">=</span> <span class="n">df1</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">difference_locations</span><span class="p">]</span>
        <span class="n">changed_to</span> <span class="o">=</span> <span class="n">df2</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">difference_locations</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;from&#39;</span><span class="p">:</span> <span class="n">changed_from</span><span class="p">,</span> <span class="s1">&#39;to&#39;</span><span class="p">:</span> <span class="n">changed_to</span><span class="p">},</span>
            <span class="n">index</span><span class="o">=</span><span class="n">changed</span><span class="o">.</span><span class="n">index</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="first_group"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.first_group">[docs]</a><span class="k">def</span> <span class="nf">first_group</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">group_cols</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns key tuple and df of first group, grouping df on group_cols.</span>

<span class="sd">    Just for ease of interactively testing out functions on DataFrames of a</span>
<span class="sd">    groupby.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gb</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">group_cols</span><span class="p">)</span>
    <span class="n">first_group_tuple</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gb</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gb</span><span class="o">.</span><span class="n">get_group</span><span class="p">(</span><span class="n">first_group_tuple</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">first_group_tuple</span><span class="p">,</span> <span class="n">gdf</span></div>


<div class="viewcode-block" id="git_hash"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.git_hash">[docs]</a><span class="k">def</span> <span class="nf">git_hash</span><span class="p">(</span><span class="n">repo_file</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes any file in a git directory and returns current hash.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">git</span>
    <span class="n">repo</span> <span class="o">=</span> <span class="n">git</span><span class="o">.</span><span class="n">Repo</span><span class="p">(</span><span class="n">repo_file</span><span class="p">,</span> <span class="n">search_parent_directories</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">current_hash</span> <span class="o">=</span> <span class="n">repo</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">hexsha</span>
    <span class="k">return</span> <span class="n">current_hash</span></div>


<span class="c1"># TODO TODO maybe check that remote seems to be valid, and fail if not.</span>
<span class="c1"># don&#39;t want to assume we have an online (backed up) record of git repo when we</span>
<span class="c1"># don&#39;t...</span>
<div class="viewcode-block" id="version_info"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.version_info">[docs]</a><span class="k">def</span> <span class="nf">version_info</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">used_for</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">force_git</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes module or string path to file in Git repo to a dict with version</span>
<span class="sd">    information (with keys and values the database will accept).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">git</span>
    <span class="kn">import</span> <span class="nn">pkg_resources</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">module_or_path</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">module_or_path</span> <span class="o">=</span> <span class="vm">__file__</span>
        <span class="n">force_git</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;too many arguments&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module_or_path</span><span class="p">,</span> <span class="n">ModuleType</span><span class="p">):</span>
        <span class="n">module</span> <span class="o">=</span> <span class="n">module_or_path</span>
        <span class="n">pkg_path</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="vm">__file__</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">module_or_path</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;must path either a Python module or str path&#39;</span><span class="p">)</span>
        <span class="n">pkg_path</span> <span class="o">=</span> <span class="n">module_or_path</span>
        <span class="n">module</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">repo</span> <span class="o">=</span> <span class="n">git</span><span class="o">.</span><span class="n">Repo</span><span class="p">(</span><span class="n">pkg_path</span><span class="p">,</span> <span class="n">search_parent_directories</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">repo</span><span class="o">.</span><span class="n">working_tree_dir</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">remote_urls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">repo</span><span class="o">.</span><span class="n">remotes</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">urls</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">remote_urls</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">remote_url</span> <span class="o">=</span> <span class="n">remote_urls</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">current_hash</span> <span class="o">=</span> <span class="n">repo</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">hexsha</span>

        <span class="n">index</span> <span class="o">=</span> <span class="n">repo</span><span class="o">.</span><span class="n">index</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">create_patch</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">changes</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">diff</span><span class="p">:</span>
            <span class="n">changes</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
            <span class="s1">&#39;used_for&#39;</span><span class="p">:</span> <span class="n">used_for</span><span class="p">,</span>
            <span class="s1">&#39;git_remote&#39;</span><span class="p">:</span> <span class="n">remote_url</span><span class="p">,</span>
            <span class="s1">&#39;git_hash&#39;</span><span class="p">:</span> <span class="n">current_hash</span><span class="p">,</span>
            <span class="s1">&#39;git_uncommitted_changes&#39;</span><span class="p">:</span> <span class="n">changes</span>
        <span class="p">}</span>

    <span class="k">except</span> <span class="n">git</span><span class="o">.</span><span class="n">exc</span><span class="o">.</span><span class="n">InvalidGitRepositoryError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">force_git</span><span class="p">:</span>
            <span class="k">raise</span>

        <span class="k">if</span> <span class="n">module</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># TODO try to find module from str</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s1">&#39;pass module for non-source installations&#39;</span><span class="p">)</span>

        <span class="c1"># There may be circumstances in which module name isn&#39;t the right name</span>
        <span class="c1"># to use here, but assuming we won&#39;t encounter that for now.</span>
        <span class="n">version</span> <span class="o">=</span> <span class="n">pkg_resources</span><span class="o">.</span><span class="n">get_distribution</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span><span class="o">.</span><span class="n">version</span>

        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s1">&#39;used_for&#39;</span><span class="p">:</span> <span class="n">used_for</span><span class="p">,</span> <span class="s1">&#39;version&#39;</span><span class="p">:</span> <span class="n">version</span><span class="p">}</span></div>


<div class="viewcode-block" id="motion_corrected_tiff_filename"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.motion_corrected_tiff_filename">[docs]</a><span class="k">def</span> <span class="nf">motion_corrected_tiff_filename</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly_num</span><span class="p">,</span> <span class="n">thorimage_id</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes vars identifying recording to the name of a motion corrected TIFF</span>
<span class="sd">    for it. Non-rigid preferred over rigid. Relies on naming convention.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tif_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">analysis_fly_dir</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly_num</span><span class="p">),</span> <span class="s1">&#39;tif_stacks&#39;</span><span class="p">)</span>
    <span class="n">nr_tif</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">tif_dir</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_nr.tif&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">thorimage_id</span><span class="p">))</span>
    <span class="n">rig_tif</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">tif_dir</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_rig.tif&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">thorimage_id</span><span class="p">))</span>
    <span class="n">tif</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">nr_tif</span><span class="p">):</span>
        <span class="n">tif</span> <span class="o">=</span> <span class="n">nr_tif</span>
    <span class="k">elif</span> <span class="n">exists</span><span class="p">(</span><span class="n">rig_tif</span><span class="p">):</span>
        <span class="n">tif</span> <span class="o">=</span> <span class="n">rig_tif</span>

    <span class="k">if</span> <span class="n">tif</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;No motion corrected TIFs found in </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tif_dir</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">tif</span></div>


<span class="c1"># TODO use this in other places that normalize to thorimage_ids</span>
<div class="viewcode-block" id="tiff_thorimage_id"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.tiff_thorimage_id">[docs]</a><span class="k">def</span> <span class="nf">tiff_thorimage_id</span><span class="p">(</span><span class="n">tiff_filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a path to a TIFF and returns ID to identify recording within</span>
<span class="sd">    (date, fly). Relies on naming convention.</span>

<span class="sd">    Works for input that is either a raw TIFF or a motion corrected TIFF,</span>
<span class="sd">    the latter of which should have a conventional suffix indicating the</span>
<span class="sd">    type of motion correction (&#39;_nr&#39; / &#39;_rig&#39;).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Behavior of os.path.split makes this work even if tiff_filename does not</span>
    <span class="c1"># have any directories in it.</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">tiff_filename</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="s1">&#39;.tif&#39;</span><span class="p">)])[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>

    <span class="c1"># Last part of the filename, which I use to indicate the type of motion</span>
    <span class="c1"># correction applied. Should only apply in TIFFs under analysis directory.</span>
    <span class="k">if</span> <span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;nr&#39;</span><span class="p">,</span> <span class="s1">&#39;rig&#39;</span><span class="p">):</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span></div>


<span class="c1"># TODO test that date, fly_num, thorimage_id args still work here after refactoring to</span>
<span class="c1"># use wrapper</span>
<span class="c1"># TODO option to keep this under analysis_dir type tree instead? or just fully switch to</span>
<span class="c1"># that maybe?</span>
<div class="viewcode-block" id="metadata_filename"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.metadata_filename">[docs]</a><span class="nd">@thorimage_dir_input</span>
<span class="k">def</span> <span class="nf">metadata_filename</span><span class="p">(</span><span class="n">thorimage_dir</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns filename of YAML for extra metadata.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO port over any metadata yamls i have in the raw data tree in this old location</span>
    <span class="c1">#return join(raw_fly_dir(date, fly_num), thorimage_id + &#39;_metadata.yaml&#39;)</span>
    <span class="k">return</span> <span class="n">join</span><span class="p">(</span><span class="n">thorimage_dir</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly</span><span class="p">,</span> <span class="n">thorimage_id</span><span class="p">),</span> <span class="s1">&#39;metadata.yaml&#39;</span><span class="p">)</span></div>


<span class="c1"># TODO maybe something to indicate various warnings</span>
<span class="c1"># (like mb team not being able to pair things) should be suppressed?</span>
<span class="c1"># TODO wrap this + read_movie into loading that can also flip according to a key in the</span>
<span class="c1"># yaml (L/R, for more easily comparing data from diff AL sides in flies in the same</span>
<span class="c1"># orientation, for example)</span>
<span class="c1">#def load_metadata(date, fly_num, thorimage_id):</span>
<div class="viewcode-block" id="load_metadata"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.load_metadata">[docs]</a><span class="k">def</span> <span class="nf">load_metadata</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns metadata from YAML, with defaults added.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">metadata_file</span> <span class="o">=</span> <span class="n">metadata_filename</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="c1"># TODO another var specifying number of frames that has *already* been</span>
    <span class="c1"># cropped out of raw tiff (start/end), to resolve any descrepencies wrt</span>
    <span class="c1"># thorsync data</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;flip_lr&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="s1">&#39;drop_first_n_frames&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">metadata_file</span><span class="p">):</span>
        <span class="c1"># TODO also load single odors (or maybe other trial structures) from stuff like</span>
        <span class="c1"># this, so analysis does not need my own pickle based stim format</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">metadata_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mdf</span><span class="p">:</span>
            <span class="n">yaml_metadata</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">mdf</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">metadata</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">yaml_metadata</span><span class="p">:</span>
                <span class="n">metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">yaml_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">metadata</span></div>


<span class="c1"># TODO move to an io module?</span>
<div class="viewcode-block" id="load_movie"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.load_movie">[docs]</a><span class="k">def</span> <span class="nf">load_movie</span><span class="p">(</span><span class="n">thorimage_dir</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Loads movie and pre-processes (e.g. flipping) if metadata requests it.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">movie</span> <span class="o">=</span> <span class="n">thor</span><span class="o">.</span><span class="n">read_movie</span><span class="p">(</span><span class="n">thorimage_dir</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="c1"># TODO TODO TODO finish implementing</span>
    <span class="c1">#metadata = load_metadata(</span>


<div class="viewcode-block" id="dir2keys"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.dir2keys">[docs]</a><span class="k">def</span> <span class="nf">dir2keys</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Returns (date, fly_num, thorimage_id) for dir with these as last three parts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="n">date_str</span><span class="p">,</span> <span class="n">fly_num_str</span><span class="p">,</span> <span class="n">thorimage_dirname</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span>

    <span class="n">date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">date_str</span><span class="p">)</span>
    <span class="n">fly_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fly_num_str</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">date</span><span class="p">,</span> <span class="n">fly_num</span><span class="p">,</span> <span class="n">thorimage_dirname</span></div>


<div class="viewcode-block" id="tiff_filename2keys"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.tiff_filename2keys">[docs]</a><span class="k">def</span> <span class="nf">tiff_filename2keys</span><span class="p">(</span><span class="n">tiff_filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes TIFF filename to pd.Series w/ &#39;date&#39;,&#39;fly_num&#39;,&#39;thorimage_id&#39; keys.</span>

<span class="sd">    TIFF must be placed and named according to convention, because the</span>
<span class="sd">    date and fly_num are taken from names of some of the containing directories.</span>

<span class="sd">    Works with TIFFs either under `raw_data_root` or `analysis_output_root`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">tiff_filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)[</span><span class="o">-</span><span class="mi">5</span><span class="p">:]</span>
    <span class="n">date</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parts</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">date_fmt_str</span><span class="p">))</span>
            <span class="n">fly_num_idx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">break</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">if</span> <span class="n">date</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;no date directory found in TIFF path&#39;</span><span class="p">)</span>

    <span class="n">fly_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="n">fly_num_idx</span><span class="p">])</span>
    <span class="n">thorimage_id</span> <span class="o">=</span> <span class="n">tiff_thorimage_id</span><span class="p">(</span><span class="n">tiff_filename</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">({</span>
        <span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="n">date</span><span class="p">,</span> <span class="s1">&#39;fly_num&#39;</span><span class="p">:</span> <span class="n">fly_num</span><span class="p">,</span> <span class="s1">&#39;thorimage_id&#39;</span><span class="p">:</span> <span class="n">thorimage_id</span>
    <span class="p">})</span></div>


<span class="c1"># TODO delete?</span>
<div class="viewcode-block" id="recording_df2keys"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.recording_df2keys">[docs]</a><span class="k">def</span> <span class="nf">recording_df2keys</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="n">dupes</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">recording_cols</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">dupes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dupes</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


<span class="c1"># TODO delete?</span>
<div class="viewcode-block" id="list_motion_corrected_tifs"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.list_motion_corrected_tifs">[docs]</a><span class="k">def</span> <span class="nf">list_motion_corrected_tifs</span><span class="p">(</span><span class="n">include_rigid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">attempt_analysis_only</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;List motion corrected TIFFs in conventional directory structure on NAS.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">motion_corrected_tifs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">mb_team_gsheet</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">full_date_dir</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">analysis_output_root</span><span class="p">(),</span> <span class="s1">&#39;**&#39;</span><span class="p">))):</span>
        <span class="k">for</span> <span class="n">full_fly_dir</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">full_date_dir</span><span class="p">,</span> <span class="s1">&#39;**&#39;</span><span class="p">))):</span>
            <span class="n">date_dir</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">full_date_dir</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">fly_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">full_fly_dir</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

                <span class="n">fly_used</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">attempt_analysis</span> <span class="o">&amp;</span>
                    <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">date</span> <span class="o">==</span> <span class="n">date_dir</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">fly_num</span> <span class="o">==</span> <span class="n">fly_num</span><span class="p">)]</span>

                <span class="n">used_thorimage_dirs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">fly_used</span><span class="o">.</span><span class="n">thorimage_dir</span><span class="p">)</span>

                <span class="n">tif_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">full_fly_dir</span><span class="p">,</span> <span class="s1">&#39;tif_stacks&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">tif_dir</span><span class="p">):</span>
                    <span class="n">tif_glob</span> <span class="o">=</span> <span class="s1">&#39;*.tif&#39;</span> <span class="k">if</span> <span class="n">include_rigid</span> <span class="k">else</span> <span class="s1">&#39;*_nr.tif&#39;</span>
                    <span class="n">fly_tifs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">tif_dir</span><span class="p">,</span> <span class="n">tif_glob</span><span class="p">)))</span>

                    <span class="n">used_tifs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">fly_tifs</span> <span class="k">if</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="n">split</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">in</span> <span class="n">used_thorimage_dirs</span><span class="p">]</span>

                    <span class="n">motion_corrected_tifs</span> <span class="o">+=</span> <span class="n">used_tifs</span>

            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">continue</span>

    <span class="k">return</span> <span class="n">motion_corrected_tifs</span></div>


<span class="c1"># TODO still work w/ parens added around initial .+ ? i want to match the parent</span>
<span class="c1"># id...</span>
<span class="n">shared_subrecording_regex</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(.+)_\db\d_from_(nr|rig)&#39;</span>
<div class="viewcode-block" id="is_subrecording"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.is_subrecording">[docs]</a><span class="k">def</span> <span class="nf">is_subrecording</span><span class="p">(</span><span class="n">thorimage_id</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns whether a recording id matches my GUIs naming convention for the</span>
<span class="sd">    &quot;sub-recordings&quot; it can create.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">shared_subrecording_regex</span> <span class="o">+</span> <span class="s1">&#39;$&#39;</span><span class="p">,</span> <span class="n">thorimage_id</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="is_subrecording_tiff"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.is_subrecording_tiff">[docs]</a><span class="k">def</span> <span class="nf">is_subrecording_tiff</span><span class="p">(</span><span class="n">tiff_filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a TIFF filename to whether it matches the GUI&#39;s naming convention for</span>
<span class="sd">    the &quot;sub-recordings&quot; it can create.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO technically, nr|rig should be same across two...</span>
    <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">shared_subrecording_regex</span> <span class="o">+</span> <span class="s1">&#39;_(nr|rig).tif$&#39;</span><span class="p">,</span> <span class="n">tiff_filename</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="subrecording_tiff_blocks"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.subrecording_tiff_blocks">[docs]</a><span class="k">def</span> <span class="nf">subrecording_tiff_blocks</span><span class="p">(</span><span class="n">tiff_filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns tuple of int (start, stop) block numbers subrecording contains.</span>

<span class="sd">    Block numbers start at 0.</span>

<span class="sd">    Requires that is_subrecording_tiff(tiff_filename) would return True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">tiff_filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>

    <span class="n">first_block</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">last_block</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">first_block</span><span class="p">,</span> <span class="n">last_block</span></div>


<div class="viewcode-block" id="subrecording_tiff_blocks_df"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.subrecording_tiff_blocks_df">[docs]</a><span class="k">def</span> <span class="nf">subrecording_tiff_blocks_df</span><span class="p">(</span><span class="n">series</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes a series w/ TIFF name in series.name to (start, stop) block nums.</span>

<span class="sd">    (series.name must be a TIFF path)</span>

<span class="sd">    Same behavior as `subrecording_tiff_blocks`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO maybe fail in this case?</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">series</span><span class="o">.</span><span class="n">is_subrecording</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="n">tiff_filename</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">name</span>
    <span class="n">first_block</span><span class="p">,</span> <span class="n">last_block</span> <span class="o">=</span> <span class="n">subrecording_tiff_blocks</span><span class="p">(</span><span class="n">tiff_filename</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">first_block</span><span class="p">,</span> <span class="n">last_block</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    return {</span>
<span class="sd">        &#39;first_block&#39;: first_block,</span>
<span class="sd">        &#39;last_block&#39;: last_block</span>
<span class="sd">    }</span>
<span class="sd">    &#39;&#39;&#39;</span></div>


<div class="viewcode-block" id="parent_recording_id"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.parent_recording_id">[docs]</a><span class="k">def</span> <span class="nf">parent_recording_id</span><span class="p">(</span><span class="n">tiffname_or_thorimage_id</span><span class="p">):</span>
    <span class="c1"># TODO provide example of naming convention / manipulation in doc</span>
    <span class="sd">&quot;&quot;&quot;Returns recording id for recording subrecording was derived from.</span>

<span class="sd">    Input can be a TIFF filename or recording id.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">last_part</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">tiffname_or_thorimage_id</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">shared_subrecording_regex</span><span class="p">,</span> <span class="n">last_part</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;not a subrecording&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></div>


<span class="c1"># TODO test this works w/ both Path and str input</span>
<div class="viewcode-block" id="write_tiff"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.write_tiff">[docs]</a><span class="k">def</span> <span class="nf">write_tiff</span><span class="p">(</span><span class="n">tiff_filename</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">,</span> <span class="n">movie</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">strict_dtype</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">dims</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">_debug</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># TODO also handle diff color channels</span>
    <span class="sd">&quot;&quot;&quot;Write a TIFF loading the same as the TIFFs we create with ImageJ.</span>

<span class="sd">    TIFFs are written in big-endian byte order to be readable by `imread_big`</span>
<span class="sd">    from MATLAB file exchange.</span>

<span class="sd">    Dimensions of input should be (t,[z,],y,x).</span>

<span class="sd">    Metadata may not be correct.</span>

<span class="sd">    Args:</span>
<span class="sd">        dims: may or may not have the same meaning as `tifffile.imsave` `axes` kwarg</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">tifffile</span>

    <span class="k">if</span> <span class="n">strict_dtype</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">unsignedinteger</span><span class="p">)):</span>

            <span class="c1"># TODO TODO TODO handle casting from float (for df/f images, for example)</span>
            <span class="c1"># (how does imagej do this type of casting? i would think it would also need</span>
            <span class="c1"># to do something like that?) (at least if not strict_dtype)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;movie must have uint16 dtype&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s1">&#39;|&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;movie must have explicit endianness&#39;</span><span class="p">)</span>

        <span class="c1"># If little-endian, convert to big-endian before saving TIFF, almost</span>
        <span class="c1"># exclusively for the benefit of MATLAB imread_big, which doesn&#39;t seem</span>
        <span class="c1"># able to discern the byteorder.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s1">&#39;&lt;&#39;</span> <span class="ow">or</span>
            <span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s1">&#39;=&#39;</span> <span class="ow">and</span> <span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s1">&#39;little&#39;</span><span class="p">)):</span>
            <span class="n">movie</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="n">byteswap</span><span class="p">()</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">dtype</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s1">&#39;&gt;&#39;</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># To avoid `ValueError: ImageJ does not support data type &#39;d&#39;` from tifffile.py</span>
        <span class="k">if</span> <span class="n">movie</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;float64&#39;</span><span class="p">:</span>
            <span class="n">movie</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>

    <span class="c1"># TODO TODO maybe change so ImageJ considers appropriate dimension the time</span>
    <span class="c1"># dimension (both in 2d x T and 3d x T cases)</span>
    <span class="c1"># TODO convert from thor data to appropriate dimension order (w/</span>
    <span class="c1"># singleton dimensions as necessary) (or keep dimensions + dimension order</span>
    <span class="c1"># of array, and pass metadata={&#39;axes&#39;: &#39;TCXY&#39;}, w/ the value constructed</span>
    <span class="c1"># appropriately? that work w/ imagej=True?) (i dont think it did)</span>

    <span class="c1"># TODO TODO since scipy docs say [their version] of tifffile expects</span>
    <span class="c1"># channels in TZCYXS order</span>
    <span class="c1"># https://scikit-image.org/docs/0.14.x/api/skimage.external.tifffile.html</span>

    <span class="n">imagej_dims</span> <span class="o">=</span> <span class="s1">&#39;TZCYX&#39;</span>

    <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;wrong number of dimensions&#39;</span><span class="p">)</span>

        <span class="n">dims</span> <span class="o">=</span> <span class="n">dims</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">imagej_dims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;dimension </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s1"> not among </span><span class="si">{</span><span class="n">imagej_dims</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="s1">&#39;TYX&#39;</span>
            <span class="c1"># Z and C</span>
            <span class="c1">#new_dim_indices = (1, 2)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="s1">&#39;TZYX&#39;</span>
            <span class="c1"># C</span>
            <span class="c1">#new_dim_indices = (2,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;unexpected number of dimensions to movie. have &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="s1">. expected 3 (TYX) or 4 (TZYX).&#39;</span>
            <span class="p">)</span>

    <span class="c1"># TODO delete?</span>
    <span class="k">if</span> <span class="n">_debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;initial: </span><span class="si">{</span><span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="c1">#</span>

    <span class="n">n_dims_to_add</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">imagej_dims</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">movie</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">movie</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_dims_to_add</span><span class="p">)))</span>

    <span class="n">new_dims</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">imagej_dims</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">])</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="n">new_dims</span> <span class="o">+</span> <span class="n">dims</span>
    <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">imagej_dims</span><span class="p">)</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">dims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">imagej_dims</span><span class="p">]</span>

    <span class="c1"># TODO delete?</span>
    <span class="k">if</span> <span class="n">_debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;after expand_dims: </span><span class="si">{</span><span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dims</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;for np.transpose: </span><span class="si">{</span><span class="n">axes</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="c1">#</span>

    <span class="n">movie</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">movie</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>

    <span class="c1"># TODO delete?</span>
    <span class="k">if</span> <span class="n">_debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;right before imsave: </span><span class="si">{</span><span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="c1">#</span>

    <span class="c1"># some docs (suite2p?) say bigtiff is not supported w/ imagej=True, and switching to</span>
    <span class="c1"># ome=True seemed to produce TIFFs i can roundtrip test w/ low memory TiffFile</span>
    <span class="c1"># pages-based method (but suite2p ScanImageReader based reading doesn&#39;t work w/</span>
    <span class="c1"># these ome tiffs, so it defaults to reading w/ tifffile and that was still causing</span>
    <span class="c1"># memory issues for Sam), and w/o the warning about truncating for large inputs.</span>
    <span class="c1"># round trip tests still passing (for at least 2 test files from Sam, one old and</span>
    <span class="c1"># one new) after switching from imagej=True to ome=True</span>
    <span class="c1"># TODO try just removing all kwargs to imsave?</span>
    <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">UserWarning</span><span class="p">,</span>
            <span class="n">message</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;.*truncating ImageJ file&#39;</span>
        <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tifffile</span><span class="o">.</span><span class="n">imsave</span><span class="p">(</span><span class="n">tiff_filename</span><span class="p">,</span> <span class="n">movie</span><span class="p">,</span> <span class="n">imagej</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">UserWarning</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;saving TIFF with ome=True, because ImageJ TIFF would have &#39;</span>
                <span class="s1">&#39;been truncated&#39;</span>
            <span class="p">)</span>
            <span class="n">tifffile</span><span class="o">.</span><span class="n">imsave</span><span class="p">(</span><span class="n">tiff_filename</span><span class="p">,</span> <span class="n">movie</span><span class="p">,</span> <span class="n">ome</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="full_frame_avg_trace"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.full_frame_avg_trace">[docs]</a><span class="k">def</span> <span class="nf">full_frame_avg_trace</span><span class="p">(</span><span class="n">movie</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes a (t,[z,]x,y) movie to t-length vector of frame averages.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Averages all dims but first, which is assumed to be time.</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">movie</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">movie</span><span class="o">.</span><span class="n">ndim</span><span class="p">)))</span></div>


<div class="viewcode-block" id="exp_decay"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.exp_decay">[docs]</a><span class="k">def</span> <span class="nf">exp_decay</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
    <span class="c1"># TODO is this the usual definition of tau (as in RC time constant?)</span>
    <span class="k">return</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span> <span class="o">/</span> <span class="n">tau</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span></div>


<span class="c1"># TODO call for each odor onset (after fixed onset period?)</span>
<span class="c1"># est onset period? est rise kinetics jointly? how does cnmf do it?</span>
<div class="viewcode-block" id="fit_exp_decay"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.fit_exp_decay">[docs]</a><span class="k">def</span> <span class="nf">fit_exp_decay</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">numerical_scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns fit parameters for an exponential decay in the input signal.</span>

<span class="sd">    Args:</span>
<span class="sd">        signal (1 dimensional np.ndarray): time series, beginning at decay onset</span>
<span class="sd">        sampling_rate (float): sampling rate in Hz</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>

    <span class="k">if</span> <span class="n">sampling_rate</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;pass either sampling_rate or times as keyword arg&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sampling_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sampling_interval</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sampling_rate</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
        <span class="n">end_time</span> <span class="o">=</span> <span class="n">n_samples</span> <span class="o">*</span> <span class="n">sampling_interval</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># TODO make sure input is not modified here. copy?</span>
    <span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span> <span class="o">*</span> <span class="n">numerical_scale</span>

    <span class="c1"># TODO constrain params somehow? for example, so scale stays positive</span>
    <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">exp_decay</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span>
        <span class="n">p0</span><span class="o">=</span><span class="p">(</span><span class="mf">1.8</span> <span class="o">*</span> <span class="n">numerical_scale</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="n">numerical_scale</span><span class="p">))</span>

    <span class="c1"># TODO is this correct to scale after converting variance to stddev?</span>
    <span class="n">sigmas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">pcov</span><span class="p">))</span>
    <span class="n">sigmas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigmas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">numerical_scale</span>
    <span class="c1"># skipping tau, which shouldn&#39;t need to change (?)</span>
    <span class="n">sigmas</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigmas</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">numerical_scale</span>

    <span class="c1"># TODO only keep this if signal is modified s.t. it affects calling fn.</span>
    <span class="c1"># in this case, maybe still just copy above?</span>
    <span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span> <span class="o">/</span> <span class="n">numerical_scale</span>

    <span class="n">scale</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">popt</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">scale</span> <span class="o">/</span> <span class="n">numerical_scale</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">offset</span> <span class="o">/</span> <span class="n">numerical_scale</span><span class="p">),</span> <span class="n">sigmas</span></div>


<div class="viewcode-block" id="n_expected_repeats"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.n_expected_repeats">[docs]</a><span class="k">def</span> <span class="nf">n_expected_repeats</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns expected # repeats given DataFrame w/ repeat_num col.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">max_repeat</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">repeat_num</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">max_repeat</span> <span class="o">+</span> <span class="mi">1</span></div>


<span class="c1"># TODO TODO could now probably switch to using block metadata in recording table</span>
<span class="c1"># (n_repeats should be in there)</span>
<span class="c1"># TODO move to project specific repo unless stimulus metadata can be</span>
<span class="c1"># meaningfully generalized</span>
<div class="viewcode-block" id="missing_repeats"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.missing_repeats">[docs]</a><span class="k">def</span> <span class="nf">missing_repeats</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Requires at least recording_from, comparison, name1, name2, and repeat_num</span>
<span class="sd">    columns. Can also take prep_date, fly_num, thorimage_id.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO n_repeats default to 3 or None?</span>
    <span class="k">if</span> <span class="n">n_repeats</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># TODO or should i require input is merged w/ recordings for stimuli</span>
        <span class="c1"># data file paths and then just load for n_repeats and stuff?</span>
        <span class="n">n_repeats</span> <span class="o">=</span> <span class="n">n_expected_repeats</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

    <span class="c1"># Expect repeats to include {0,1,2} for 3 repeat experiments.</span>
    <span class="n">expected_repeats</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_repeats</span><span class="p">))</span>

    <span class="n">repeat_cols</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">opt_repeat_cols</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;prep_date&#39;</span><span class="p">,</span>
        <span class="s1">&#39;fly_num&#39;</span><span class="p">,</span>
        <span class="s1">&#39;thorimage_id&#39;</span>
    <span class="p">]</span>
    <span class="k">for</span> <span class="n">oc</span> <span class="ow">in</span> <span class="n">opt_repeat_cols</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">oc</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">repeat_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oc</span><span class="p">)</span>

    <span class="n">repeat_cols</span> <span class="o">+=</span> <span class="p">[</span>
        <span class="s1">&#39;recording_from&#39;</span><span class="p">,</span>
        <span class="s1">&#39;comparison&#39;</span><span class="p">,</span>
        <span class="s1">&#39;name1&#39;</span><span class="p">,</span>
        <span class="s1">&#39;name2&#39;</span><span class="c1">#,</span>
        <span class="c1">#&#39;log10_conc_vv1&#39;,</span>
        <span class="c1">#&#39;log10_conc_vv2&#39;</span>
    <span class="p">]</span>
    <span class="c1"># TODO some issue created by using float concs as a key?</span>
    <span class="c1"># TODO use odor ids instead?</span>
    <span class="n">missing_repeat_dfs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">gdf</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">repeat_cols</span><span class="p">):</span>
        <span class="n">comparison_n_repeats</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">repeat_num</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

        <span class="n">no_extra_repeats</span> <span class="o">=</span> <span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">repeat_num</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">no_extra_repeats</span>

        <span class="n">missing_repeats</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">expected_repeats</span>
            <span class="k">if</span> <span class="n">r</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">comparison_n_repeats</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_repeats</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">gmeta</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">repeat_cols</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">missing_repeats</span><span class="p">:</span>
            <span class="n">new_row</span> <span class="o">=</span> <span class="n">gmeta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_row</span><span class="p">[</span><span class="s1">&#39;repeat_num&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
            <span class="n">missing_repeat_dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_row</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_repeat_dfs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">missing_repeats_df</span> <span class="o">=</span> \
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="n">r</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">repeat_cols</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;repeat_num&#39;</span><span class="p">]})</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># TODO maybe merge w/ odor info so caller doesn&#39;t have to, if thats the</span>
        <span class="c1"># most useful for troubleshooting?</span>
        <span class="n">missing_repeats_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">missing_repeat_dfs</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">missing_repeats_df</span><span class="o">.</span><span class="n">recording_from</span> <span class="o">=</span> \
        <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">missing_repeats_df</span><span class="o">.</span><span class="n">recording_from</span><span class="p">)</span>

    <span class="c1"># TODO should expected # blocks be passed in?</span>

    <span class="k">return</span> <span class="n">missing_repeats_df</span></div>


<div class="viewcode-block" id="have_all_repeats"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.have_all_repeats">[docs]</a><span class="k">def</span> <span class="nf">have_all_repeats</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if a recording has all blocks gsheet says it has, w/ full</span>
<span class="sd">    number of repeats for each. False otherwise.</span>

<span class="sd">    Requires at least recording_from, comparison, name1, name2, and repeat_num</span>
<span class="sd">    columns. Can also take prep_date, fly_num, thorimage_id.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">missing_repeats_df</span> <span class="o">=</span> <span class="n">missing_repeats</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span><span class="n">n_repeats</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_repeats_df</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="missing_odor_pairs"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.missing_odor_pairs">[docs]</a><span class="k">def</span> <span class="nf">missing_odor_pairs</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Requires at least recording_from, comparison, name1, name2 columns.</span>
<span class="sd">    Can also take prep_date, fly_num, thorimage_id.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO check that for each comparison, both A, B, and A+B are there</span>
    <span class="c1"># (3 combos of name1, name2, or whichever other odor ids)</span>
    <span class="n">comp_cols</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">opt_rec_cols</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;prep_date&#39;</span><span class="p">,</span>
        <span class="s1">&#39;fly_num&#39;</span><span class="p">,</span>
        <span class="s1">&#39;thorimage_id&#39;</span>
    <span class="p">]</span>
    <span class="k">for</span> <span class="n">oc</span> <span class="ow">in</span> <span class="n">opt_rec_cols</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">oc</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">comp_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oc</span><span class="p">)</span>

    <span class="n">comp_cols</span> <span class="o">+=</span> <span class="p">[</span>
        <span class="s1">&#39;recording_from&#39;</span><span class="p">,</span>
        <span class="s1">&#39;comparison&#39;</span>
    <span class="p">]</span>

    <span class="n">odor_cols</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;name1&#39;</span><span class="p">,</span>
        <span class="s1">&#39;name2&#39;</span>
    <span class="p">]</span>

    <span class="n">incomplete_comparison_dfs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">gdf</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">comp_cols</span><span class="p">):</span>
        <span class="n">comp_odor_pairs</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">odor_cols</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_odor_pairs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">incomplete_comparison_dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gdf</span><span class="p">[</span><span class="n">comp_cols</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span>
                <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="c1"># TODO generate expected combinations of name1,name2</span>
        <span class="c1"># TODO possible either odor not in db, in which case, would need extra</span>
        <span class="c1"># information to say which odor is actually missing... (would need</span>
        <span class="c1"># stimulus data)</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        if len(missing_odor_pairs) &gt; 0:</span>
<span class="sd">            gmeta = gdf[comp_cols].drop_duplicates().reset_index(drop=True)</span>

<span class="sd">        for r in missing_odor_pairs:</span>
<span class="sd">            new_row = gmeta.copy()</span>
<span class="sd">            new_row[&#39;repeat_num&#39;] = r</span>
<span class="sd">            missing_odor_pair_dfs.append(new_row)</span>
<span class="sd">        &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">incomplete_comparison_dfs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">incomplete_comparison_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="n">r</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">comp_cols</span><span class="p">})</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">incomplete_comparison_df</span> <span class="o">=</span> \
            <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">incomplete_comparison_dfs</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">incomplete_comparison_df</span><span class="o">.</span><span class="n">recording_from</span> <span class="o">=</span> \
        <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">incomplete_comparison_df</span><span class="o">.</span><span class="n">recording_from</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">incomplete_comparison_df</span></div>


<div class="viewcode-block" id="have_full_comparisons"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.have_full_comparisons">[docs]</a><span class="k">def</span> <span class="nf">have_full_comparisons</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Requires at least recording_from, comparison, name1, name2 columns.</span>
<span class="sd">    Can also take prep_date, fly_num, thorimage_id.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO docstring</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_odor_pairs</span><span class="p">(</span><span class="n">df</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="skipped_comparison_nums"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.skipped_comparison_nums">[docs]</a><span class="k">def</span> <span class="nf">skipped_comparison_nums</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="c1"># TODO doc</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Requires at least recording_from and comparison columns.</span>
<span class="sd">    Can also take prep_date, fly_num, and thorimage_id.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rec_cols</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">opt_rec_cols</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;prep_date&#39;</span><span class="p">,</span>
        <span class="s1">&#39;fly_num&#39;</span><span class="p">,</span>
        <span class="s1">&#39;thorimage_id&#39;</span>
    <span class="p">]</span>
    <span class="k">for</span> <span class="n">oc</span> <span class="ow">in</span> <span class="n">opt_rec_cols</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">oc</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">rec_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oc</span><span class="p">)</span>

    <span class="n">rec_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;recording_from&#39;</span><span class="p">)</span>

    <span class="n">skipped_comparison_dfs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">gdf</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">rec_cols</span><span class="p">):</span>
        <span class="n">max_comp_num</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">comparison</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">min_comp_num</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">comparison</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">skipped_comp_nums</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_comp_num</span><span class="p">,</span> <span class="n">max_comp_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">comparison</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skipped_comp_nums</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">gmeta</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">rec_cols</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">skipped_comp_nums</span><span class="p">:</span>
            <span class="n">new_row</span> <span class="o">=</span> <span class="n">gmeta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_row</span><span class="p">[</span><span class="s1">&#39;comparison&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
            <span class="n">skipped_comparison_dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_row</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skipped_comparison_dfs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">skipped_comparison_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="n">r</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span>
            <span class="n">rec_cols</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;comparison&#39;</span><span class="p">]})</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">skipped_comparison_df</span> <span class="o">=</span> \
            <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">skipped_comparison_dfs</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># TODO move this out of each of these check fns, and put wherever this</span>
    <span class="c1"># columns is generated (in the way that required this cast...)</span>
    <span class="n">skipped_comparison_df</span><span class="o">.</span><span class="n">recording_from</span> <span class="o">=</span> \
        <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">skipped_comparison_df</span><span class="o">.</span><span class="n">recording_from</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">skipped_comparison_df</span></div>


<div class="viewcode-block" id="no_skipped_comparisons"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.no_skipped_comparisons">[docs]</a><span class="k">def</span> <span class="nf">no_skipped_comparisons</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="c1"># TODO doc</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Requires at least recording_from and comparison columns.</span>
<span class="sd">    Can also take prep_date, fly_num, and thorimage_id.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skipped_comparison_nums</span><span class="p">(</span><span class="n">df</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<span class="c1"># TODO also check recording has as many blocks (in df / in db) as it&#39;s supposed</span>
<span class="c1"># to, given what the metadata + gsheet say</span>


<div class="viewcode-block" id="drop_orphaned_presentations"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.drop_orphaned_presentations">[docs]</a><span class="k">def</span> <span class="nf">drop_orphaned_presentations</span><span class="p">():</span>
    <span class="c1"># TODO only stuff that isn&#39;t also most recent response params?</span>
    <span class="c1"># TODO find presentation rows that don&#39;t have response row referring to them</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<span class="c1"># TODO TODO maybe implement check fns above as wrappers around another fn that</span>
<span class="c1"># finds inomplete stuff? (check if len is 0), so that these fns can just wrap</span>
<span class="c1"># the same thing...</span>
<div class="viewcode-block" id="drop_incomplete_presentations"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.drop_incomplete_presentations">[docs]</a><span class="k">def</span> <span class="nf">drop_incomplete_presentations</span><span class="p">():</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="smooth_1d"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.smooth_1d">[docs]</a><span class="k">def</span> <span class="nf">smooth_1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">window_len</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hanning&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;smooth the data using a window with requested size.</span>

<span class="sd">    This method is based on the convolution of a scaled window with the signal.</span>
<span class="sd">    The signal is prepared by introducing reflected copies of the signal</span>
<span class="sd">    (with the window size) in both ends so that transient parts are minimized</span>
<span class="sd">    in the begining and end part of the output signal.</span>

<span class="sd">    input:</span>
<span class="sd">        x: the input signal</span>
<span class="sd">        window_len: the dimension of the smoothing window; should be an odd</span>
<span class="sd">            integer</span>
<span class="sd">        window: the type of window from &#39;flat&#39;, &#39;hanning&#39;, &#39;hamming&#39;,</span>
<span class="sd">            &#39;bartlett&#39;, &#39;blackman&#39; flat window will produce a moving average</span>
<span class="sd">            smoothing.</span>

<span class="sd">    output:</span>
<span class="sd">        the smoothed signal</span>

<span class="sd">    example:</span>

<span class="sd">    t=linspace(-2,2,0.1)</span>
<span class="sd">    x=sin(t)+randn(len(t))*0.1</span>
<span class="sd">    y=smooth_1d(x)</span>

<span class="sd">    see also:</span>

<span class="sd">    numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman, numpy.convolve</span>
<span class="sd">    scipy.signal.lfilter</span>

<span class="sd">    TODO: the window parameter could be the window itself if an array instead of</span>
<span class="sd">    a string</span>
<span class="sd">    NOTE: length(output) != length(input), to correct this: return</span>
<span class="sd">    y[(window_len/2-1):-(window_len/2)] instead of just y.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;smooth_1d only accepts 1 dimension arrays.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">window_len</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input vector needs to be bigger than window size.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">window_len</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">window</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;flat&#39;</span><span class="p">,</span> <span class="s1">&#39;hanning&#39;</span><span class="p">,</span> <span class="s1">&#39;hamming&#39;</span><span class="p">,</span> <span class="s1">&#39;bartlett&#39;</span><span class="p">,</span> <span class="s1">&#39;blackman&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Window is on of &#39;flat&#39;, &#39;hanning&#39;, &quot;</span> <span class="o">+</span>
            <span class="s2">&quot;&#39;hamming&#39;, &#39;bartlett&#39;, &#39;blackman&#39;&quot;</span><span class="p">)</span>

    <span class="c1"># is this necessary?</span>
    <span class="c1">#s = np.r_[x[window_len-1:0:-1],x,x[-2:-window_len-1:-1]]</span>

    <span class="c1">#print(len(s))</span>
    <span class="k">if</span> <span class="n">window</span> <span class="o">==</span> <span class="s1">&#39;flat&#39;</span><span class="p">:</span> <span class="c1">#moving average</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">window_len</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;np.&#39;</span> <span class="o">+</span> <span class="n">window</span> <span class="o">+</span> <span class="s1">&#39;(window_len)&#39;</span><span class="p">)</span>

    <span class="c1">#y = np.convolve(w/w.sum(), s, mode=&#39;valid&#39;)</span>
    <span class="c1"># not sure what to change above to get this to work...</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">x</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span></div>


<span class="c1"># TODO finish translating. was directly translating matlab registration script</span>
<span class="c1"># to python.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">def motion_correct_to_tiffs(image_dir, output_dir):</span>
<span class="sd">    # TODO only read this if at least one motion correction would be run</span>
<span class="sd">    movie = thor.read_movie(image_dir)</span>

<span class="sd">    # TODO do i really want to basically just copy the matlab version?</span>
<span class="sd">    # opportunity for some refactoring?</span>

<span class="sd">    output_subdir = &#39;tif_stacks&#39;</span>

<span class="sd">    _, thorimage_id = split(image_dir)</span>

<span class="sd">    rig_tif = join(output_dir, output_subdir, thorimage_id + &#39;_rig.tif&#39;)</span>
<span class="sd">    avg_rig_tif = join(output_dir, output_subdir, &#39;AVG&#39;, &#39;rigid&#39;,</span>
<span class="sd">        &#39;AVG{}_rig.tif&#39;.format(thorimage_id))</span>

<span class="sd">    nr_tif = join(output_dir, output_subdir, thorimage_id + &#39;_nr.tif&#39;)</span>
<span class="sd">    avg_nr_tif = join(output_dir, output_subdir, &#39;AVG&#39;, &#39;nonrigid&#39;,</span>
<span class="sd">        &#39;AVG{}_nr.tif&#39;.format(thorimage_id))</span>

<span class="sd">    need_rig_tif = not exist(rig_tif)</span>
<span class="sd">    need_avg_rig_tif = not exist(avg_rig_tif)</span>
<span class="sd">    need_nr_tif = not exist(nr_tif)</span>
<span class="sd">    need_avg_nr_tif = not exist(avg_nr_tif)</span>

<span class="sd">    if not (need_rig_tif or need_avg_rig_tif or need_nr_tif or need_avg_nr_tif):</span>
<span class="sd">        print(&#39;All registration already done.&#39;)</span>
<span class="sd">        return</span>

<span class="sd">    # Remy: this seems like it might just be reading in the first frame?</span>
<span class="sd">    ###Y = input_tif_path</span>
<span class="sd">    # TODO maybe can just directly use filename for python version though? raw</span>
<span class="sd">    # even?</span>

<span class="sd">    # rigid moco (normcorre)</span>
<span class="sd">    # TODO just pass filename instead of Y, and compute dimensions or whatever</span>
<span class="sd">    # separately, so that normcorre can (hopefully?) take up less memory</span>
<span class="sd">    if need_rig_tif:</span>
<span class="sd">        MC_rigid = MotionCorrection(Y)</span>

<span class="sd">        options_rigid = NoRMCorreSetParms(&#39;d1&#39;,MC_rigid.dims(1),</span>
<span class="sd">            &#39;d2&#39;,MC_rigid.dims(2),</span>
<span class="sd">            &#39;bin_width&#39;,50,</span>
<span class="sd">            &#39;max_shift&#39;,15,</span>
<span class="sd">            &#39;phase_flag&#39;, 1,</span>
<span class="sd">            &#39;us_fac&#39;, 50,</span>
<span class="sd">            &#39;init_batch&#39;, 100,</span>
<span class="sd">            &#39;plot_flag&#39;, false,</span>
<span class="sd">            &#39;iter&#39;, 2)</span>

<span class="sd">        # TODO so is nothing actually happening in parallel?</span>
<span class="sd">        ## rigid moco</span>
<span class="sd">        MC_rigid.motionCorrectSerial(options_rigid)  # can also try parallel</span>
<span class="sd">        # TODO which (if any) of these do i still want?</span>
<span class="sd">        MC_rigid.computeMean()</span>
<span class="sd">        MC_rigid.correlationMean()</span>
<span class="sd">        #####MC_rigid.crispness()</span>
<span class="sd">        print(&#39;normcorre done&#39;)</span>

<span class="sd">        ## plot shifts</span>
<span class="sd">        #plt.plot(MC_rigid.shifts_x)</span>
<span class="sd">        #plt.plot(MC_rigid.shifts_y)</span>

<span class="sd">        # save .tif</span>
<span class="sd">        M = MC_rigid.M</span>
<span class="sd">        M = uint16(M)</span>
<span class="sd">        tiffoptions.overwrite = true</span>

<span class="sd">        print([&#39;saving tiff to &#39; rig_tif])</span>
<span class="sd">        saveastiff(M, rig_tif, tiffoptions)</span>

<span class="sd">    if need_avg_rig_tif:</span>
<span class="sd">        ##</span>
<span class="sd">        # save average image</span>
<span class="sd">        #AVG = single(mean(MC_rigid.M,3))</span>
<span class="sd">        AVG = single(MC_rigid.template)</span>
<span class="sd">        tiffoptions.overwrite = true</span>

<span class="sd">        print([&#39;saving tiff to &#39; avg_rig_tif])</span>
<span class="sd">        saveastiff(AVG, avg_rig_tif, tiffoptions)</span>

<span class="sd">    if need_nr_tif:</span>
<span class="sd">        MC_nonrigid = MotionCorrection(Y)</span>
<span class="sd">        options_nonrigid = NoRMCorreSetParms(&#39;d1&#39;,MC_nonrigid.dims(1),</span>
<span class="sd">            &#39;d2&#39;,MC_nonrigid.dims(2),</span>
<span class="sd">            &#39;grid_size&#39;,[64,64],</span>
<span class="sd">            &#39;mot_uf&#39;,4,</span>
<span class="sd">            &#39;bin_width&#39;,50,</span>
<span class="sd">            &#39;max_shift&#39;,[15 15],</span>
<span class="sd">            &#39;max_dev&#39;,3,</span>
<span class="sd">            &#39;us_fac&#39;,50,</span>
<span class="sd">            &#39;init_batch&#39;,200,</span>
<span class="sd">            &#39;iter&#39;, 2)</span>

<span class="sd">        MC_nonrigid.motionCorrectParallel(options_nonrigid)</span>
<span class="sd">        MC_nonrigid.computeMean()</span>
<span class="sd">        MC_nonrigid.correlationMean()</span>
<span class="sd">        MC_nonrigid.crispness()</span>
<span class="sd">        print(&#39;non-rigid normcorre done&#39;)</span>

<span class="sd">        # save .tif</span>
<span class="sd">        M = uint16(MC_nonrigid.M)</span>
<span class="sd">        tiffoptions.overwrite  = true</span>
<span class="sd">        print([&#39;saving tiff to &#39; nr_tif])</span>
<span class="sd">        saveastiff(M, nr_tif, tiffoptions)</span>

<span class="sd">    if need_avg_nr_tif:</span>
<span class="sd">        # TODO flag to disable saving this average</span>
<span class="sd">        #AVG = single(mean(MC_nonrigid.M,3))</span>
<span class="sd">        AVG = single(MC_nonrigid.template)</span>
<span class="sd">        tiffoptions.overwrite = true</span>
<span class="sd">        print([&#39;saving tiff to &#39; avg_nr_tif])</span>
<span class="sd">        saveastiff(AVG, avg_nr_tif, tiffoptions)</span>

<span class="sd">    raise NotImplementedError</span>
<span class="sd">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="cell_ids"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.cell_ids">[docs]</a><span class="k">def</span> <span class="nf">cell_ids</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes a DataFrame with &#39;cell&#39; in MultiIndex or columns to unique values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s1">&#39;cell&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">to_series</span><span class="p">()</span>
    <span class="k">elif</span> <span class="s1">&#39;cell&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">cids</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;cell&#39;</span><span class="p">)</span>
        <span class="n">cids</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;cell&#39;</span>
        <span class="k">return</span> <span class="n">cids</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;cell&#39; not in index or columns of DataFrame&quot;</span><span class="p">)</span></div>


<span class="c1"># TODO move to olf / delete</span>
<div class="viewcode-block" id="format_odor_conc"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.format_odor_conc">[docs]</a><span class="k">def</span> <span class="nf">format_odor_conc</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">log10_conc</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes `str` odor name and log10 concentration to a formatted `str`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">log10_conc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">name</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># TODO tex formatting for exponent</span>
        <span class="c1">#return r&#39;{} @ $10^{{&#39;.format(name) + &#39;{:.2f}}}$&#39;.format(log10_conc)</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> @ $10^{{</span><span class="si">{:.2f}</span><span class="s1">}}$&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">log10_conc</span><span class="p">)</span></div>


<span class="c1"># TODO move to olf / delete</span>
<div class="viewcode-block" id="format_mixture"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.format_mixture">[docs]</a><span class="k">def</span> <span class="nf">format_mixture</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns `str` representing 2-component odor mixture.</span>

<span class="sd">    Input can be any of:</span>
<span class="sd">    - 2 `str` names</span>
<span class="sd">    - 2 names and concs (n1, n2, c1, c2)</span>
<span class="sd">    - a pandas.Series / dict with keys `name1`, `name2`, and (optionally)</span>
<span class="sd">      `log10_concvv&lt;1/2&gt;`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">log10_c1</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">log10_c2</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">args</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">log10_c1</span><span class="p">,</span> <span class="n">log10_c2</span> <span class="o">=</span> <span class="n">args</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># TODO maybe refactor to use this fn in viz.plot_odor_corrs fn too</span>
        <span class="k">def</span> <span class="nf">single_var_with_prefix</span><span class="p">(</span><span class="n">prefix</span><span class="p">):</span>
            <span class="n">single_var</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">row</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">single_var</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;multiple vars w/ prefix </span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">single_var</span> <span class="o">=</span> <span class="n">v</span>

            <span class="k">if</span> <span class="n">single_var</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;no vars w/ prefix </span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">single_var</span>
        <span class="c1">#</span>

        <span class="n">n1</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">single_var_with_prefix</span><span class="p">(</span><span class="s1">&#39;name1&#39;</span><span class="p">)]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">single_var_with_prefix</span><span class="p">(</span><span class="s1">&#39;name2&#39;</span><span class="p">)]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># TODO maybe also use prefix fn here?</span>
        <span class="k">if</span> <span class="s1">&#39;log10_conc_vv1&#39;</span> <span class="ow">in</span> <span class="n">row</span><span class="p">:</span>
            <span class="n">log10_c1</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;log10_conc_vv1&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">n2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">log10_c2</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;log10_conc_vv2&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;incorrect number of args&#39;</span><span class="p">)</span>

    <span class="c1"># TODO replace &#39;paraffin&#39; w/ olf solvent def?</span>
    <span class="k">if</span> <span class="n">n1</span> <span class="o">==</span> <span class="s1">&#39;paraffin&#39;</span><span class="p">:</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">format_odor_conc</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">log10_c2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">n2</span> <span class="o">==</span> <span class="s1">&#39;paraffin&#39;</span> <span class="ow">or</span> <span class="n">n2</span> <span class="o">==</span> <span class="n">NO_ODOR</span> <span class="ow">or</span> <span class="n">n2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">format_odor_conc</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">log10_c1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> + </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">format_odor_conc</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">log10_c1</span><span class="p">),</span>
            <span class="n">format_odor_conc</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">log10_c2</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">title</span></div>


<span class="c1"># TODO move to olf / delete</span>
<div class="viewcode-block" id="split_odor_w_conc"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.split_odor_w_conc">[docs]</a><span class="k">def</span> <span class="nf">split_odor_w_conc</span><span class="p">(</span><span class="n">row_or_str</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">odor_w_conc</span> <span class="o">=</span> <span class="n">row_or_str</span><span class="o">.</span><span class="n">odor_w_conc</span>
        <span class="n">include_other_row_data</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">row_or_str</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span>
        <span class="n">odor_w_conc</span> <span class="o">=</span> <span class="n">row_or_str</span>
        <span class="n">include_other_row_data</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">parts</span> <span class="o">=</span> <span class="n">odor_w_conc</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;@&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">log10_conc</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">log10_conc</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="s1">&#39;log10_conc_vv&#39;</span><span class="p">:</span> <span class="n">log10_conc</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">include_other_row_data</span><span class="p">:</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">row_or_str</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>

    <span class="c1"># TODO maybe only return series if include_other_row_data (rename if),</span>
    <span class="c1"># tuple/dict otherwise?</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>


<div class="viewcode-block" id="format_keys"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.format_keys">[docs]</a><span class="k">def</span> <span class="nf">format_keys</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">fly</span><span class="p">,</span> <span class="o">*</span><span class="n">other_keys</span><span class="p">):</span>
    <span class="n">date</span> <span class="o">=</span> <span class="n">format_date</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
    <span class="n">fly</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">fly</span><span class="p">))</span>
    <span class="n">others</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">other_keys</span><span class="p">]</span>
    <span class="k">return</span> <span class="s1">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">date</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">fly</span><span class="p">]</span> <span class="o">+</span> <span class="n">others</span><span class="p">)</span></div>


<span class="c1"># TODO also use in al_analysis modeling code that defines a param_str?</span>
<div class="viewcode-block" id="format_params"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.format_params">[docs]</a><span class="k">def</span> <span class="nf">format_params</span><span class="p">(</span><span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="o">*</span><span class="p">,</span> <span class="n">delim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="p">,</span> <span class="n">sort</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">exclude_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Collection</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">float_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;#.3g&#39;</span><span class="p">,</span>
    <span class="n">abbrevs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="c1"># TODO float_format option to print all decimal places, as if no format specifier</span>
    <span class="c1"># was provided? some float_format value equiv to that? otherwise, make optional and</span>
    <span class="c1"># use None for that? even care to support this behavior tho?</span>
    <span class="sd">&quot;&quot;&quot;Formats dict with params into one string.</span>

<span class="sd">    Args:</span>
<span class="sd">        sort: whether to sort keys</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">items</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
        <span class="n">items</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">exclude_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">exclude_params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">abbrevs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">abbrevs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">delim</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">abbrevs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span><span class="si">}</span><span class="s1">=&#39;</span> <span class="o">+</span>
        <span class="c1"># TODO need some other test to also handle the similar numpy type(s)?</span>
        <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">v</span><span class="si">:{</span><span class="n">float_format</span><span class="si">}}</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">items</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_params</span>
    <span class="p">])</span></div>


<span class="c1"># TODO rename to be inclusive of cases other than pairs</span>
<div class="viewcode-block" id="pair_ordering"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.pair_ordering">[docs]</a><span class="k">def</span> <span class="nf">pair_ordering</span><span class="p">(</span><span class="n">comparison_df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes a df w/ name1 &amp; name2 to a dict of their tuples to order int.</span>

<span class="sd">    Order integers start at 0 and do not skip any numbers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO maybe assert only 3 combinations of name1/name2</span>
    <span class="n">pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="o">.</span><span class="n">name1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">name2</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span>
        <span class="n">comparison_df</span><span class="p">[[</span><span class="s1">&#39;name1&#39;</span><span class="p">,</span><span class="s1">&#39;name2&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">itertuples</span><span class="p">()]</span>

    <span class="c1"># Will define the order in which odor pairs will appear, left-to-right,</span>
    <span class="c1"># in subplots.</span>
    <span class="n">ordering</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="c1"># TODO maybe check that it&#39;s the second element specifically, since right</span>
    <span class="c1"># now, it&#39;s only cause paraffin is abbreviated to pfo (for name1 col)</span>
    <span class="c1"># that complex-mixture experiments go into first branch...</span>
    <span class="n">has_paraffin</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pairs</span> <span class="k">if</span> <span class="s1">&#39;paraffin&#39;</span> <span class="ow">in</span> <span class="n">p</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">has_paraffin</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">chemutils</span> <span class="k">as</span> <span class="nn">cu</span>
        <span class="k">assert</span> <span class="p">{</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">}</span> <span class="o">==</span> <span class="p">{</span><span class="n">NO_ODOR</span><span class="p">}</span>
        <span class="n">odors</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">]</span>

        <span class="c1"># TODO change how odorset is identified so it can fail if none should be</span>
        <span class="c1"># detected / return None or something, then call back to just sorting</span>
        <span class="c1"># the odor names here, if no odor set name can be identified</span>
        <span class="c1"># (do we also want to support some case where original_name1 is defined</span>
        <span class="c1"># but the odorset name isn&#39;t necessarily?)</span>
        <span class="k">if</span> <span class="s1">&#39;original_name1&#39;</span> <span class="ow">in</span> <span class="n">comparison_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">original_name_order</span> <span class="o">=</span> <span class="n">df_to_odor_order</span><span class="p">(</span><span class="n">comparison_df</span><span class="p">)</span>
            <span class="n">o2n</span> <span class="o">=</span> <span class="n">comparison_df</span><span class="p">[[</span><span class="s1">&#39;original_name1&#39;</span><span class="p">,</span><span class="s1">&#39;name1&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span>
                <span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;original_name1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">name1</span>
            <span class="c1"># TODO maybe don&#39;t assume NO_ODOR like this (&amp; below)?</span>
            <span class="n">ordering</span> <span class="o">=</span> <span class="p">{(</span><span class="n">v</span><span class="p">,</span> <span class="n">NO_ODOR</span><span class="p">):</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
                <span class="nb">enumerate</span><span class="p">(</span><span class="n">o2n</span><span class="p">[</span><span class="n">original_name_order</span><span class="p">])}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO also support case where there isn&#39;t something we want to</span>
            <span class="c1"># stick at the end like this, for Matt&#39;s case</span>
            <span class="n">last</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">odors</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cu</span><span class="o">.</span><span class="n">odor_is_mix</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">last</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">last</span> <span class="o">=</span> <span class="n">o</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;multiple mixtures in odors to order&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">last</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;expected a mix&#39;</span>
            <span class="n">ordering</span><span class="p">[(</span><span class="n">last</span><span class="p">,</span> <span class="n">NO_ODOR</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">odors</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">odors</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">o</span> <span class="o">==</span> <span class="n">last</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">ordering</span><span class="p">[(</span><span class="n">o</span><span class="p">,</span> <span class="n">NO_ODOR</span><span class="p">)]</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">no_pfo</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pairs</span> <span class="k">if</span> <span class="s1">&#39;paraffin&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">p</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">no_pfo</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All pairs for this comparison had paraffin.&#39;</span> <span class="o">+</span>
                <span class="s1">&#39; Analysis error? Incomplete recording?&#39;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">no_pfo</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">no_pfo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ordering</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">has_paraffin</span><span class="p">,</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;paraffin&#39;</span> <span class="k">else</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>

            <span class="n">ordering</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

    <span class="c1"># Checks that we order integers start at zero and don&#39;t skip anything.</span>
    <span class="c1"># Important for some ways of using them (e.g. to index axes array).</span>
    <span class="k">assert</span> <span class="p">{</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ordering</span><span class="o">.</span><span class="n">values</span><span class="p">()}</span> <span class="o">==</span> <span class="p">{</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ordering</span><span class="p">))}</span>

    <span class="k">return</span> <span class="n">ordering</span></div>


<span class="c1"># TODO call this in gui / factor into viz.plot_odor_corrs (though it would</span>
<span class="c1"># require accesss to df...) and call that there</span>
<span class="c1"># TODO delete?</span>
<div class="viewcode-block" id="add_missing_odor_cols"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.add_missing_odor_cols">[docs]</a><span class="k">def</span> <span class="nf">add_missing_odor_cols</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">missing_df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO maybe check cols are indeed describing odors in missing_df?</span>

    <span class="c1"># TODO delete / change note to be relevant here. copied from original</span>
    <span class="c1"># implementation in gui</span>
    <span class="c1"># This + pivot_table w/ dropna=False won&#39;t work until this bug:</span>
    <span class="c1"># https://github.com/pandas-dev/pandas/issues/18030 is fixed.</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    window_trial_means = pd.concat([window_trial_means,</span>
<span class="sd">        missing_dff.set_index(window_trial_means.index.names</span>
<span class="sd">        ).df_over_f</span>
<span class="sd">    ])</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">missing_dff</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">df_over_f</span><span class="o">.</span><span class="n">isnull</span><span class="p">()][</span>
        <span class="n">missing_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">names</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="s1">&#39;df_over_f&#39;</span><span class="p">]</span>
    <span class="p">]</span>
    <span class="c1"># Hack to workaround pivot NaN behavior bug mentioned above.</span>
    <span class="k">assert</span> <span class="n">missing_dff</span><span class="o">.</span><span class="n">df_over_f</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="n">missing_dff</span><span class="o">.</span><span class="n">df_over_f</span> <span class="o">=</span> <span class="n">missing_dff</span><span class="o">.</span><span class="n">df_over_f</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">extra_cols</span> <span class="o">=</span> <span class="n">missing_dff</span><span class="o">.</span><span class="n">pivot_table</span><span class="p">(</span>
        <span class="n">index</span><span class="o">=</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="s1">&#39;df_over_f&#39;</span><span class="p">,</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name1&#39;</span><span class="p">,</span><span class="s1">&#39;name2&#39;</span><span class="p">,</span><span class="s1">&#39;repeat_num&#39;</span><span class="p">,</span><span class="s1">&#39;order&#39;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">extra_cols</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">missing_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">())</span> <span class="o">==</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">missing_df</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>

    <span class="n">missing_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">missing_df</span><span class="p">,</span> <span class="n">extra_cols</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">missing_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">())</span> <span class="o">==</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">missing_df</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>

    <span class="n">missing_df</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># end of the hack to workaround pivot NaN behavior</span>

    <span class="k">return</span> <span class="n">missing_df</span></div>


<span class="c1"># TODO worth having min/max as inputs, so that maybe can use vals from</span>
<span class="c1"># either scene or template for the other? i guess point of baselining</span>
<span class="c1"># is to avoid need for stuff like that...</span>
<div class="viewcode-block" id="baselined_normed_u8"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.baselined_normed_u8">[docs]</a><span class="k">def</span> <span class="nf">baselined_normed_u8</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
    <span class="n">u8_max</span> <span class="o">=</span> <span class="mi">255</span>
    <span class="c1"># TODO maybe convert to float64 or something first before some operations,</span>
    <span class="c1"># to minimize rounding errs?</span>
    <span class="n">baselined</span> <span class="o">=</span> <span class="n">img</span> <span class="o">-</span> <span class="n">img</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="n">normed</span> <span class="o">=</span> <span class="n">baselined</span> <span class="o">/</span> <span class="n">baselined</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">u8_max</span> <span class="o">*</span> <span class="n">normed</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span></div>


<span class="c1"># TODO refactor this behind a color=True kwarg baselined_normed_u8 above?</span>
<div class="viewcode-block" id="u8_color"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.u8_color">[docs]</a><span class="k">def</span> <span class="nf">u8_color</span><span class="p">(</span><span class="n">draw_on</span><span class="p">):</span>
    <span class="c1"># TODO figure out why background looks lighter here than in other</span>
    <span class="c1"># imshows of same input (w/o converting manually)</span>
    <span class="n">draw_on</span> <span class="o">=</span> <span class="n">draw_on</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">draw_on</span><span class="p">)</span>
    <span class="n">draw_on</span> <span class="o">=</span> <span class="n">draw_on</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">draw_on</span><span class="p">)</span>
    <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span> <span class="c1">#, lut=256)</span>
    <span class="c1"># (throwing away alpha coord w/ last slice)</span>
    <span class="n">draw_on</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="n">cmap</span><span class="p">(</span><span class="n">draw_on</span><span class="p">)[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="mi">255</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">draw_on</span></div>


<div class="viewcode-block" id="euclidean_dist"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.euclidean_dist">[docs]</a><span class="k">def</span> <span class="nf">euclidean_dist</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
    <span class="c1"># Without the conversions to float 64 (or at least something else signed),</span>
    <span class="c1"># uint inputs lead to wraparound -&gt; big distances occasionally.</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">-</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="assign_frames_to_trials"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.assign_frames_to_trials">[docs]</a><span class="k">def</span> <span class="nf">assign_frames_to_trials</span><span class="p">(</span><span class="n">movie</span><span class="p">,</span> <span class="n">presentations_per_block</span><span class="p">,</span> <span class="n">block_first_frames</span><span class="p">,</span>
    <span class="n">odor_onset_frames</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns arrays trial_start_frames, trial_stop_frames</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_frames</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># TODO maybe just add metadata[&#39;drop_first_n_frames&#39;] to this?</span>
    <span class="c1"># (otherwise, that variable screws things up, right?)</span>
    <span class="c1">#onset_frame_offset = \</span>
    <span class="c1">#    odor_onset_frames[0] - block_first_frames[0]</span>

    <span class="c1"># TODO delete this hack, after implementing more robust frame-to-trial</span>
    <span class="c1"># assignment described below</span>
    <span class="n">b2o_offsets</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">o</span> <span class="o">-</span> <span class="n">b</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">block_first_frames</span><span class="p">,</span>
        <span class="n">odor_onset_frames</span><span class="p">[::</span><span class="n">presentations_per_block</span><span class="p">])</span>
    <span class="p">])</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">b2o_offsets</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span>
    <span class="c1"># TODO TODO TODO re-enable after fixing frame_times based issues w/</span>
    <span class="c1"># volumetric data</span>
    <span class="c1"># TODO might need to allow for some error here...? frame or two?</span>
    <span class="c1"># (in resonant scanner case, w/ frame averaging maybe)</span>
    <span class="c1">#assert b2o_offsets[-1] == b2o_offsets[-2]</span>
    <span class="n">onset_frame_offset</span> <span class="o">=</span> <span class="n">b2o_offsets</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1">#</span>

    <span class="c1"># TODO TODO TODO instead of this frame # strategy for assigning frames</span>
    <span class="c1"># to trials, maybe do this:</span>
    <span class="c1"># 1) find ~max # frames from block start to onset, as above</span>
    <span class="c1"># TODO but maybe still warn if some offset deviates from max by more</span>
    <span class="c1"># than a frame or two...</span>
    <span class="c1"># 2) paint all frames before odor onsets up to this max # frames / time</span>
    <span class="c1">#    (if frames have a time discontinuity between them indicating</span>
    <span class="c1">#     acquisition did not proceed continuously between them, do not</span>
    <span class="c1">#     paint across that boundary)</span>
    <span class="c1"># 3) paint still-unassigned frames following odor onset in the same</span>
    <span class="c1">#    fashion (again stopping at boundaries of &gt; certain dt)</span>
    <span class="c1"># [4)] if not using max in #1 (but something like rounded mean)</span>
    <span class="c1">#      may still have unassigned frames at block starts. assign those to</span>
    <span class="c1">#      trials.</span>
    <span class="c1"># TODO could just assert everything within block regions i&#39;m painting</span>
    <span class="c1"># does not have time discontinuities, and then i could just deal w/</span>
    <span class="c1"># frames</span>

    <span class="n">trial_start_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">odor_onset_frames</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">onset_frame_offset</span>
    <span class="p">)</span>
    <span class="n">trial_stop_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="n">odor_onset_frames</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">onset_frame_offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_frames</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="p">)</span>

    <span class="c1"># TODO same checks are made for blocks, so factor out?</span>
    <span class="n">total_trial_frames</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">t_start</span><span class="p">,</span> <span class="n">t_end</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
        <span class="nb">zip</span><span class="p">(</span><span class="n">trial_start_frames</span><span class="p">,</span> <span class="n">trial_stop_frames</span><span class="p">)):</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">last_t_end</span> <span class="o">=</span> <span class="n">trial_stop_frames</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">last_t_end</span> <span class="o">==</span> <span class="p">(</span><span class="n">t_start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">total_trial_frames</span> <span class="o">+=</span> <span class="n">t_end</span> <span class="o">-</span> <span class="n">t_start</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">assert</span> <span class="n">total_trial_frames</span> <span class="o">==</span> <span class="n">n_frames</span><span class="p">,</span> \
        <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> != </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">total_trial_frames</span><span class="p">,</span> <span class="n">n_frames</span><span class="p">)</span>
    <span class="c1">#</span>

    <span class="c1"># TODO warn if all block/trial lens are not the same? (by more than some</span>
    <span class="c1"># threshold probably)</span>

    <span class="k">return</span> <span class="n">trial_start_frames</span><span class="p">,</span> <span class="n">trial_stop_frames</span></div>


<span class="c1"># TODO TODO TODO after refactoring much of the stuff that was under</span>
<span class="c1"># open_recording and some of its downstream fns from gui.py, also refactor this</span>
<span class="c1"># to use the new fns</span>
<span class="c1"># TODO and maybe move this to project/analysis specific specific repo /</span>
<span class="c1"># submodule as it uses matlab pipeline ouputs...</span>
<span class="c1"># TODO maybe move to project/analysis specific repo / submodule (same as other</span>
<span class="c1"># stuff that uses matlab_kc_plane outputs)</span>
<span class="c1"># TODO maybe move to matlab (this is only fn that uses either of fns imported</span>
<span class="c1"># from there)</span>
<div class="viewcode-block" id="movie_blocks"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.movie_blocks">[docs]</a><span class="k">def</span> <span class="nf">movie_blocks</span><span class="p">(</span><span class="n">tif</span><span class="p">,</span> <span class="n">movie</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">allow_gsheet_to_restrict_blocks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">stimfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">first_block</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">last_block</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns list of arrays, one per continuous acquisition.</span>

<span class="sd">    `tif` must be named and placed according to convention, and a .mat file</span>
<span class="sd">    created from `ejhonglab/matlab_kc_plane` (typically run via `populate_db.py`</span>
<span class="sd">    in what is now my `kc_natural_mixes` repo) must exist in the conventional</span>
<span class="sd">    path under the analysis root. This .mat file is used for the timing</span>
<span class="sd">    information (ultimately derived mainly from ThorSync data).</span>

<span class="sd">    Total length along time dimension should be preserved from input TIFF.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>

    <span class="k">if</span> <span class="n">movie</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">tifffile</span>
        <span class="n">movie</span> <span class="o">=</span> <span class="n">tifffile</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">tif</span><span class="p">)</span>

    <span class="n">keys</span> <span class="o">=</span> <span class="n">tiff_filename2keys</span><span class="p">(</span><span class="n">tif</span><span class="p">)</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">matlab</span><span class="o">.</span><span class="n">matfile</span><span class="p">(</span><span class="o">*</span><span class="n">keys</span><span class="p">)</span>
    <span class="c1">#mat = matfile(*keys)</span>

    <span class="c1"># TODO TODO TODO refactor all stuff that uses this to new output format</span>
    <span class="c1"># (and remove factored checks, etc)</span>
    <span class="n">ti</span> <span class="o">=</span> <span class="n">matlab</span><span class="o">.</span><span class="n">load_mat_timing_info</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="c1">#ti = load_mat_timing_info(mat)</span>

    <span class="k">if</span> <span class="n">stimfile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">mb_team_gsheet</span><span class="p">()</span>
        <span class="n">recordings</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">date</span> <span class="o">==</span> <span class="n">keys</span><span class="o">.</span><span class="n">date</span><span class="p">)</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">fly_num</span> <span class="o">==</span> <span class="n">keys</span><span class="o">.</span><span class="n">fly_num</span><span class="p">)</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">thorimage_dir</span> <span class="o">==</span> <span class="n">keys</span><span class="o">.</span><span class="n">thorimage_id</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">del</span> <span class="n">df</span>
        <span class="n">recording</span> <span class="o">=</span> <span class="n">recordings</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">recordings</span>
        <span class="k">if</span> <span class="n">recording</span><span class="o">.</span><span class="n">project</span> <span class="o">!=</span> <span class="s1">&#39;natural_odors&#39;</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;project type </span><span class="si">{}</span><span class="s1"> not supported. skipping.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">recording</span><span class="o">.</span><span class="n">project</span><span class="p">))</span>
            <span class="k">return</span>

        <span class="n">stimfile</span> <span class="o">=</span> <span class="n">recording</span><span class="p">[</span><span class="s1">&#39;stimulus_data_file&#39;</span><span class="p">]</span>
        <span class="n">first_block</span> <span class="o">=</span> <span class="n">recording</span><span class="p">[</span><span class="s1">&#39;first_block&#39;</span><span class="p">]</span>
        <span class="n">last_block</span> <span class="o">=</span> <span class="n">recording</span><span class="p">[</span><span class="s1">&#39;last_block&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">recording</span>

        <span class="n">stimfile_path</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">stimfile_root</span><span class="p">(),</span> <span class="n">stimfile</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;using hardcoded stimulus file, rather than using value &#39;</span>
            <span class="s1">&#39;from MB team gsheet&#39;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">stimfile</span><span class="p">):</span>
            <span class="n">stimfile_path</span> <span class="o">=</span> <span class="n">stimfile</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stimfile_path</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">stimfile_root</span><span class="p">(),</span> <span class="n">stimfile</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">exists</span><span class="p">(</span><span class="n">stimfile_path</span><span class="p">),</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;stimfile </span><span class="si">{</span><span class="n">stimfile</span><span class="si">}</span><span class="s1"> not found &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;alone or under </span><span class="si">{</span><span class="n">stimfile_root</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>

    <span class="c1"># TODO also err if not readable / valid</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">stimfile_path</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;copy missing stimfile </span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">stimfile</span><span class="p">,</span>
            <span class="n">stimfile_root</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">stimfile_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="c1"># TODO just infer from data if no stimfile and not specified in</span>
    <span class="c1"># metadata_file</span>
    <span class="n">n_repeats</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_repeats&#39;</span><span class="p">])</span>

    <span class="c1"># TODO delete this hack (which is currently just using new pickle</span>
    <span class="c1"># format as a proxy for the experiment being a supermixture experiment)</span>
    <span class="k">if</span> <span class="s1">&#39;odor_lists&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="c1"># The 3 is because 3 odors are compared in each repeat for the</span>
        <span class="c1"># natural_odors project.</span>
        <span class="n">presentations_per_repeat</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">odor_list</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;odor_pair_list&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_expected_real_blocks</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">odor_list</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;odor_lists&#39;</span><span class="p">]</span>
        <span class="c1"># because of &quot;block&quot; def in arduino / get_stiminfo code</span>
        <span class="c1"># not matching def in randomizer / stimfile code</span>
        <span class="c1"># (scopePin pulses vs. randomization units, depending on settings)</span>
        <span class="n">presentations_per_repeat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">odor_list</span><span class="p">)</span> <span class="o">//</span> <span class="n">n_expected_real_blocks</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">odor_list</span><span class="p">)</span> <span class="o">%</span> <span class="n">n_expected_real_blocks</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="c1"># Hardcode to break up into more blocks, to align defs of blocks.</span>
        <span class="c1"># TODO (maybe just for experiments on 2019-07-25 ?) or change block</span>
        <span class="c1"># handling in here? make more flexible?</span>
        <span class="n">n_repeats</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">presentations_per_block</span> <span class="o">=</span> <span class="n">n_repeats</span> <span class="o">*</span> <span class="n">presentations_per_repeat</span>

    <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">first_block</span><span class="p">):</span>
        <span class="n">first_block</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">first_block</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">first_block</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">last_block</span><span class="p">):</span>
        <span class="n">n_full_panel_blocks</span> <span class="o">=</span> \
            <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">odor_list</span><span class="p">)</span> <span class="o">/</span> <span class="n">presentations_per_block</span><span class="p">)</span>
        <span class="n">last_block</span> <span class="o">=</span> <span class="n">n_full_panel_blocks</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">last_block</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">last_block</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">first_presentation</span> <span class="o">=</span> <span class="n">first_block</span> <span class="o">*</span> <span class="n">presentations_per_block</span>
    <span class="n">last_presentation</span> <span class="o">=</span> <span class="p">(</span><span class="n">last_block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">presentations_per_block</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">odor_list</span> <span class="o">=</span> <span class="n">odor_list</span><span class="p">[</span><span class="n">first_presentation</span><span class="p">:(</span><span class="n">last_presentation</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">odor_list</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">presentations_per_repeat</span> <span class="o">*</span> <span class="n">n_repeats</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># TODO TODO delete odor frame stuff after using them to check blocks frames</span>
    <span class="c1"># are actually blocks and not trials</span>
    <span class="c1"># TODO or if keeping odor stuff, re-add asserts involving odor_list,</span>
    <span class="c1"># since how i have that here</span>

    <span class="n">odor_onset_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ti</span><span class="p">[</span><span class="s1">&#39;stim_on&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span>
        <span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">odor_offset_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ti</span><span class="p">[</span><span class="s1">&#39;stim_off&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">odor_onset_frames</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">odor_offset_frames</span><span class="p">)</span>

    <span class="c1"># Of length equal to number of blocks. Each element is the frame</span>
    <span class="c1"># index (from 1) in CNMF output that starts the block, where</span>
    <span class="c1"># block is defined as a period of continuous acquisition.</span>
    <span class="n">block_first_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ti</span><span class="p">[</span><span class="s1">&#39;block_start_frame&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span>
        <span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">block_last_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ti</span><span class="p">[</span><span class="s1">&#39;block_end_frame&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span>
        <span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">n_blocks_from_gsheet</span> <span class="o">=</span> <span class="n">last_block</span> <span class="o">-</span> <span class="n">first_block</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">n_blocks_from_thorsync</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">block_first_frames</span><span class="p">)</span>

    <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">odor_list</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">last_block</span> <span class="o">-</span> <span class="n">first_block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
        <span class="n">presentations_per_block</span><span class="p">)</span>

    <span class="n">n_presentations</span> <span class="o">=</span> <span class="n">n_blocks_from_gsheet</span> <span class="o">*</span> <span class="n">presentations_per_block</span>

    <span class="n">err_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> blocks (</span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1">, inclusive) in Google sheet {{}} </span><span class="si">{}</span><span class="s1"> &#39;</span> <span class="o">+</span>
        <span class="s1">&#39;blocks from ThorSync.&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_blocks_from_gsheet</span><span class="p">,</span>
        <span class="n">first_block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">last_block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_blocks_from_thorsync</span><span class="p">)</span>
    <span class="n">fail_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39; Fix in Google sheet, turn off &#39;</span> <span class="o">+</span>
        <span class="s1">&#39;cache if necessary, and rerun.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n_blocks_from_gsheet</span> <span class="o">&gt;</span> <span class="n">n_blocks_from_thorsync</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">fail_msg</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">n_blocks_from_gsheet</span> <span class="o">&lt;</span> <span class="n">n_blocks_from_thorsync</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">allow_gsheet_to_restrict_blocks</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">err_msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;&lt;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39; This is ONLY ok if you &#39;</span><span class="o">+</span>
                <span class="s1">&#39;intend to exclude the LAST </span><span class="si">{}</span><span class="s1"> blocks in the Thor output.&#39;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_blocks_from_thorsync</span> <span class="o">-</span> <span class="n">n_blocks_from_gsheet</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;&lt;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">fail_msg</span><span class="p">)</span>

    <span class="n">frame_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ti</span><span class="p">[</span><span class="s1">&#39;frame_times&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="c1"># TODO replace this w/ factored check fn</span>
    <span class="n">total_block_frames</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">b_start</span><span class="p">,</span> <span class="n">b_end</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
        <span class="nb">zip</span><span class="p">(</span><span class="n">block_first_frames</span><span class="p">,</span> <span class="n">block_last_frames</span><span class="p">)):</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">last_b_end</span> <span class="o">=</span> <span class="n">block_last_frames</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">last_b_end</span> <span class="o">==</span> <span class="p">(</span><span class="n">b_start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">assert</span> <span class="p">(</span><span class="n">b_start</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_times</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b_end</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_times</span><span class="p">))</span>
        <span class="n">block_frametimes</span> <span class="o">=</span> <span class="n">frame_times</span><span class="p">[</span><span class="n">b_start</span><span class="p">:</span><span class="n">b_end</span><span class="p">]</span>
        <span class="n">dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">block_frametimes</span><span class="p">)</span>
        <span class="c1"># np.max(np.abs(dts - np.mean(dts))) / np.mean(dts)</span>
        <span class="c1"># was 0.000148... in one case I tested w/ data from the older</span>
        <span class="c1"># system, so the check below w/ rtol=1e-4 would fail.</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">dts</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">dts</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">3e-4</span><span class="p">)</span>

        <span class="n">total_block_frames</span> <span class="o">+=</span> <span class="n">b_end</span> <span class="o">-</span> <span class="n">b_start</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">orig_n_frames</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># TODO may need to remove this assert to handle cases where there is a</span>
    <span class="c1"># partial block (stopped early). leave assert after slicing tho.</span>
    <span class="c1"># (warn instead, probably)</span>
    <span class="k">assert</span> <span class="n">total_block_frames</span> <span class="o">==</span> <span class="n">orig_n_frames</span><span class="p">,</span> \
        <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> != </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">total_block_frames</span><span class="p">,</span> <span class="n">orig_n_frames</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">allow_gsheet_to_restrict_blocks</span><span class="p">:</span>
        <span class="c1"># TODO unit test for case where first_block != 0 and == 0</span>
        <span class="c1"># w/ last_block == first_block and &gt; first_block</span>
        <span class="c1"># TODO TODO doesn&#39;t this only support dropping blocks at end?</span>
        <span class="c1"># do i assert that first_block is 0 then? probably should...</span>
        <span class="c1"># TODO TODO TODO shouldnt it be first_block:last_block+1?</span>
        <span class="n">block_first_frames</span> <span class="o">=</span> <span class="n">block_first_frames</span><span class="p">[</span>
            <span class="p">:(</span><span class="n">last_block</span> <span class="o">-</span> <span class="n">first_block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">block_last_frames</span> <span class="o">=</span> <span class="n">block_last_frames</span><span class="p">[</span>
            <span class="p">:(</span><span class="n">last_block</span> <span class="o">-</span> <span class="n">first_block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">block_first_frames</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_blocks_from_gsheet</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">block_last_frames</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_blocks_from_gsheet</span>

        <span class="c1"># TODO also delete this odor frame stuff when done</span>
        <span class="n">odor_onset_frames</span> <span class="o">=</span> <span class="n">odor_onset_frames</span><span class="p">[</span>
            <span class="p">:(</span><span class="n">last_presentation</span> <span class="o">-</span> <span class="n">first_presentation</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">odor_offset_frames</span> <span class="o">=</span> <span class="n">odor_offset_frames</span><span class="p">[</span>
            <span class="p">:(</span><span class="n">last_presentation</span> <span class="o">-</span> <span class="n">first_presentation</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">odor_onset_frames</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_presentations</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">odor_offset_frames</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_presentations</span>
        <span class="c1">#</span>

        <span class="n">frame_times</span> <span class="o">=</span> <span class="n">frame_times</span><span class="p">[:(</span><span class="n">block_last_frames</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="n">last_frame</span> <span class="o">=</span> <span class="n">block_last_frames</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">n_tossed_frames</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">last_frame</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n_tossed_frames</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;Tossing trailing </span><span class="si">{}</span><span class="s1"> of </span><span class="si">{}</span><span class="s1"> frames of movie, which did not &#39;</span> <span class="o">+</span>
            <span class="s1">&#39;belong to any used block.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">n_tossed_frames</span><span class="p">,</span> <span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="c1"># TODO factor this metadata handling out. fns for load / set?</span>
    <span class="c1"># combine w/ remy&#39;s .mat metadata (+ my stimfile?)</span>

    <span class="c1"># This will return defaults if the YAML file is not found.</span>
    <span class="n">meta</span> <span class="o">=</span> <span class="n">load_metadata</span><span class="p">(</span><span class="o">*</span><span class="n">keys</span><span class="p">)</span>

    <span class="c1"># TODO want / need to do more than just slice to free up memory from</span>
    <span class="c1"># other pixels? is that operation worth it?</span>
    <span class="n">drop_first_n_frames</span> <span class="o">=</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;drop_first_n_frames&#39;</span><span class="p">]</span>
    <span class="c1"># TODO TODO err if this is past first odor onset (or probably even too</span>
    <span class="c1"># close)</span>
    <span class="k">del</span> <span class="n">meta</span>

    <span class="n">odor_onset_frames</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">drop_first_n_frames</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">odor_onset_frames</span><span class="p">]</span>
    <span class="n">odor_offset_frames</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">drop_first_n_frames</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">odor_offset_frames</span><span class="p">]</span>

    <span class="n">block_first_frames</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">drop_first_n_frames</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">block_first_frames</span><span class="p">]</span>
    <span class="n">block_first_frames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">block_last_frames</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">drop_first_n_frames</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">block_last_frames</span><span class="p">]</span>

    <span class="k">assert</span> <span class="n">odor_onset_frames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="n">frame_times</span> <span class="o">=</span> <span class="n">frame_times</span><span class="p">[</span><span class="n">drop_first_n_frames</span><span class="p">:]</span>
    <span class="n">movie</span> <span class="o">=</span> <span class="n">movie</span><span class="p">[</span><span class="n">drop_first_n_frames</span><span class="p">:(</span><span class="n">last_frame</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="c1"># TODO TODO fix bug referenced in cthulhu:190520...</span>
    <span class="c1"># and re-enable assert</span>
    <span class="k">assert</span> <span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_times</span><span class="p">),</span> \
        <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> != </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_times</span><span class="p">))</span>
    <span class="c1">#</span>

    <span class="k">if</span> <span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_times</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> != </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_times</span><span class="p">)))</span>

    <span class="c1"># TODO maybe move this and the above checks on block start/end frames</span>
    <span class="c1"># + frametimes into assign_frames_to_trials</span>
    <span class="n">n_frames</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">total_block_frames</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">e</span> <span class="o">-</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span>
        <span class="nb">zip</span><span class="p">(</span><span class="n">block_first_frames</span><span class="p">,</span> <span class="n">block_last_frames</span><span class="p">)</span>
    <span class="p">])</span>

    <span class="k">assert</span> <span class="n">total_block_frames</span> <span class="o">==</span> <span class="n">n_frames</span><span class="p">,</span> \
        <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> != </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">total_block_frames</span><span class="p">,</span> <span class="n">n_frames</span><span class="p">)</span>


    <span class="c1"># TODO any time / space diff returning slices to slice array and only</span>
    <span class="c1"># slicing inside loop vs. returning list of (presumably views) by slicing</span>
    <span class="c1"># matrix?</span>
    <span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">movie</span><span class="p">[</span><span class="n">start</span><span class="p">:(</span><span class="n">stop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="ow">in</span>
        <span class="nb">zip</span><span class="p">(</span><span class="n">block_first_frames</span><span class="p">,</span> <span class="n">block_last_frames</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="k">assert</span> <span class="nb">sum</span><span class="p">([</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">])</span> <span class="o">==</span> <span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">blocks</span></div>


<div class="viewcode-block" id="downsample_movie"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.downsample_movie">[docs]</a><span class="k">def</span> <span class="nf">downsample_movie</span><span class="p">(</span><span class="n">movie</span><span class="p">,</span> <span class="n">target_fps</span><span class="p">,</span> <span class="n">current_fps</span><span class="p">,</span> <span class="n">allow_overshoot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">allow_uneven_division</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">relative_fps_err</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns downsampled movie by averaging consecutive groups of frames.</span>

<span class="sd">    Groups of frames averaged do not overlap.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">allow_uneven_division</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="c1"># TODO maybe kwarg for max acceptable (rel/abs?) factor error,</span>
    <span class="c1"># and err / return None if it can&#39;t be achieved</span>

    <span class="n">target_factor</span> <span class="o">=</span> <span class="n">current_fps</span> <span class="o">/</span> <span class="n">target_fps</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;allow_overshoot: </span><span class="si">{</span><span class="n">allow_overshoot</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;allow_uneven_division: </span><span class="si">{</span><span class="n">allow_uneven_division</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;relative_fps_err: </span><span class="si">{</span><span class="n">relative_fps_err</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;target_fps: </span><span class="si">{</span><span class="n">target_fps</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;target_factor: </span><span class="si">{</span><span class="n">target_factor</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">n_frames</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># TODO TODO also support uneven # of frames per bin (toss last probably)</span>
    <span class="c1"># (skip loop checking for even divisors in that case)</span>

    <span class="c1"># Find the largest/closest downsampling we can do, with equal numbers of</span>
    <span class="c1"># frames for each average.</span>
    <span class="n">best_divisor</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_frames</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n_frames</span> <span class="o">%</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">decimated_n_frames</span> <span class="o">=</span> <span class="n">n_frames</span> <span class="o">//</span> <span class="n">i</span>
        <span class="c1"># (will always be float(i) in even division case, so could get rid of</span>
        <span class="c1"># this if that&#39;s all i&#39;ll support)</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">n_frames</span> <span class="o">/</span> <span class="n">decimated_n_frames</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;factor: </span><span class="si">{</span><span class="n">factor</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">factor</span> <span class="o">&gt;</span> <span class="n">target_factor</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">allow_overshoot</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;breaking because of overshoot&#39;</span><span class="p">)</span>
            <span class="k">break</span>

        <span class="n">downsampled_fps</span> <span class="o">=</span> <span class="n">current_fps</span> <span class="o">/</span> <span class="n">factor</span>
        <span class="n">fps_error</span> <span class="o">=</span> <span class="n">downsampled_fps</span> <span class="o">-</span> <span class="n">target_fps</span>
        <span class="k">if</span> <span class="n">relative_fps_err</span><span class="p">:</span>
            <span class="n">fps_error</span> <span class="o">=</span> <span class="n">fps_error</span> <span class="o">/</span> <span class="n">target_fps</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;downsampled_fps: </span><span class="si">{</span><span class="n">downsampled_fps</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;fps_error: </span><span class="si">{</span><span class="n">fps_error</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">best_divisor</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">fps_error</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">best_fps_error</span><span class="p">):</span>
            <span class="n">best_divisor</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">best_downsampled_fps</span> <span class="o">=</span> <span class="n">downsampled_fps</span>
            <span class="n">best_fps_error</span> <span class="o">=</span> <span class="n">fps_error</span>
            <span class="n">best_factor</span> <span class="o">=</span> <span class="n">factor</span>

            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;best_downsampled_fps: </span><span class="si">{</span><span class="n">best_downsampled_fps</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;new best factor&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="p">(</span><span class="n">best_divisor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
            <span class="nb">abs</span><span class="p">(</span><span class="n">fps_error</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">best_fps_error</span><span class="p">)):</span>

            <span class="k">assert</span> <span class="n">allow_overshoot</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;breaking because past best factor&#39;</span><span class="p">)</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">best_divisor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="c1"># TODO unit test for this case</span>
    <span class="k">if</span> <span class="n">best_divisor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;best downsampling with this flags at factor of 1&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;best_divisor: </span><span class="si">{</span><span class="n">best_divisor</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;best_factor: </span><span class="si">{</span><span class="n">best_factor</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;best_fps_error: </span><span class="si">{</span><span class="n">best_fps_error</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;best_downsampled_fps: </span><span class="si">{</span><span class="n">best_downsampled_fps</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">frame_shape</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">new_n_frames</span> <span class="o">=</span> <span class="n">n_frames</span> <span class="o">//</span> <span class="n">best_divisor</span>

    <span class="c1"># see: stackoverflow.com/questions/15956309 for how to adapt this</span>
    <span class="c1"># to uneven division case</span>
    <span class="n">downsampled</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">new_n_frames</span><span class="p">,</span> <span class="n">best_divisor</span><span class="p">)</span> <span class="o">+</span> <span class="n">frame_shape</span>
        <span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># TODO maybe it&#39;s obvious, but is there any kind of guarantee dimensions in</span>
    <span class="c1"># frame_shape will not be screwed up in a way relevant to the average</span>
    <span class="c1"># when reshaping?</span>
    <span class="c1"># well, at least this looks reasonable:</span>
    <span class="c1"># viz.image_grid(downsampled[:64])</span>

    <span class="k">return</span> <span class="n">downsampled</span><span class="p">,</span> <span class="n">best_downsampled_fps</span></div>


<div class="viewcode-block" id="tiff_title"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.tiff_title">[docs]</a><span class="k">def</span> <span class="nf">tiff_title</span><span class="p">(</span><span class="n">tif</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns abbreviation of TIFF filename for use in titles.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tif</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="s1">&#39;tif_stacks&#39;</span><span class="p">]</span>
    <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;.tif&#39;</span>
    <span class="k">if</span> <span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">ext</span><span class="p">):</span>
        <span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">ext</span><span class="p">)]</span>
    <span class="k">return</span> <span class="s1">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span></div>


<span class="c1"># TODO didn&#39;t i have some other fn for this? delete one if so</span>
<span class="c1"># (or was it just in natural_odors?)</span>
<div class="viewcode-block" id="to_filename"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.to_filename">[docs]</a><span class="k">def</span> <span class="nf">to_filename</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">period</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">extra_remove_chars</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Take a str and normalizes it a bit to make it a better filename prefix.</span>

<span class="sd">    E.g. taking a plot title and using it to derive a filename for saving the</span>
<span class="sd">    plot.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># To handle things like consecutive whitespace (e.g. &#39;x\n y&#39;)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

    <span class="n">replace_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;/&#39;</span><span class="p">:</span> <span class="s1">&#39;_&#39;</span><span class="p">,</span>
        <span class="s1">&#39;@&#39;</span><span class="p">:</span> <span class="s1">&#39;_&#39;</span><span class="p">,</span>
        <span class="s1">&#39;,&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;.&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;(&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;)&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;[&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;]&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;?&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">extra_remove_chars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">extra_remove_chars</span><span class="p">:</span>
            <span class="n">replace_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">replace_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="c1"># Replace multiple consecutive &#39;_&#39; with a single &#39;_&#39;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;_+&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="c1"># TODO delete this and refactor code that expects this behavior to add the period</span>
    <span class="k">if</span> <span class="n">period</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="s1">&#39;.&#39;</span>

    <span class="k">return</span> <span class="n">x</span></div>


<span class="c1"># Adapted from Vishal&#39;s answer at https://stackoverflow.com/questions/287871</span>
<span class="n">_color_codes</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;red&#39;</span><span class="p">:</span> <span class="s1">&#39;31&#39;</span><span class="p">,</span>
    <span class="s1">&#39;green&#39;</span><span class="p">:</span> <span class="s1">&#39;32&#39;</span><span class="p">,</span>
    <span class="s1">&#39;yellow&#39;</span><span class="p">:</span> <span class="s1">&#39;33&#39;</span><span class="p">,</span>
    <span class="s1">&#39;blue&#39;</span><span class="p">:</span> <span class="s1">&#39;34&#39;</span><span class="p">,</span>
    <span class="s1">&#39;cyan&#39;</span><span class="p">:</span> <span class="s1">&#39;36&#39;</span>
<span class="p">}</span>
<div class="viewcode-block" id="start_color"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.start_color">[docs]</a><span class="k">def</span> <span class="nf">start_color</span><span class="p">(</span><span class="n">color_name</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">color_code</span> <span class="o">=</span> <span class="n">_color_codes</span><span class="p">[</span><span class="n">color_name</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Available colors are:&#39;</span><span class="p">)</span>
        <span class="n">pprint</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">_color_codes</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">raise</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[</span><span class="si">{}</span><span class="s1">m&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">color_code</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="stop_color"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.stop_color">[docs]</a><span class="k">def</span> <span class="nf">stop_color</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[0m&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="print_color"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.print_color">[docs]</a><span class="k">def</span> <span class="nf">print_color</span><span class="p">(</span><span class="n">color_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">start_color</span><span class="p">(</span><span class="n">color_name</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">stop_color</span><span class="p">()</span></div>


<span class="c1"># TODO delete</span>
<div class="viewcode-block" id="latest_trace_pickles"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.latest_trace_pickles">[docs]</a><span class="k">def</span> <span class="nf">latest_trace_pickles</span><span class="p">():</span>
    <span class="c1"># TODO say which data is searched/included in this fn</span>
    <span class="sd">&quot;&quot;&quot;Returns (date, fly, id) indexed DataFrame w/ filename and timestamp cols.</span>

<span class="sd">    Only returns rows for filenames that had the latest timestamp for the</span>
<span class="sd">    combination of index values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">vars_from_filename</span><span class="p">(</span><span class="n">tp_path</span><span class="p">):</span>
        <span class="n">final_part</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">tp_path</span><span class="p">)[</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># Note that we have lost any more precise time resolution, so an</span>
        <span class="c1"># exact search for this timestamp in database would fail.</span>
        <span class="n">n_time_chars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="s1">&#39;YYYYMMDD_HHMM&#39;</span><span class="p">)</span>
        <span class="n">run_at</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">final_part</span><span class="p">[:</span><span class="n">n_time_chars</span><span class="p">],</span>
            <span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">_%H%M&#39;</span>
        <span class="p">))</span>

        <span class="n">parts</span> <span class="o">=</span> <span class="n">final_part</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="n">date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">date_fmt_str</span><span class="p">))</span>
        <span class="n">fly_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">thorimage_id</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
        <span class="k">return</span> <span class="n">date</span><span class="p">,</span> <span class="n">fly_num</span><span class="p">,</span> <span class="n">thorimage_id</span><span class="p">,</span> <span class="n">run_at</span><span class="p">,</span> <span class="n">tp_path</span>

    <span class="c1"># TODO maybe replace w/ `recording_cols`, which is currently the same except</span>
    <span class="c1"># the first element is &#39;prep_date&#39; (maybe generalize representation to use</span>
    <span class="c1"># either? or migrate all data to using just date, change `recording_cols`,</span>
    <span class="c1"># then use here?)</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">,</span> <span class="s1">&#39;fly_num&#39;</span><span class="p">,</span> <span class="s1">&#39;thorimage_id&#39;</span><span class="p">]</span>
    <span class="n">tp_root</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">analysis_output_root</span><span class="p">(),</span> <span class="s1">&#39;trace_pickles&#39;</span><span class="p">)</span>
    <span class="n">tp_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">vars_from_filename</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">tp_root</span><span class="p">,</span> <span class="s1">&#39;*.p&#39;</span><span class="p">))]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tp_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;no trace pickles found under </span><span class="si">{</span><span class="n">tp_root</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">keys</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;run_at&#39;</span><span class="p">,</span> <span class="s1">&#39;trace_pickle_path&#39;</span><span class="p">],</span>
        <span class="n">data</span><span class="o">=</span><span class="n">tp_data</span>
    <span class="p">)</span>

    <span class="n">unique_len_before</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">keys</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">())</span>
    <span class="n">latest</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span><span class="o">.</span><span class="n">run_at</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()</span>
    <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">latest</span><span class="p">),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">keys</span><span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">())</span> <span class="o">==</span> <span class="n">unique_len_before</span>

    <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<span class="c1"># TODO kwarg to have this replace the multiindex levels / columns values it is derived</span>
<span class="c1"># from (and thread through add_fly_id/add_recording_id)</span>
<span class="c1"># TODO TODO axis kwarg?</span>
<span class="c1"># TODO add option to drop existing levels/columns used to make this?</span>
<div class="viewcode-block" id="add_group_id"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.add_group_id">[docs]</a><span class="k">def</span> <span class="nf">add_group_id</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">DataFrameOrDataArray</span><span class="p">,</span> <span class="n">group_keys</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">letter</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">start_at_one</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Adds integer column to identify unique combinations of group_keys.</span>

<span class="sd">    Args:</span>
<span class="sd">        data: DataFrame or DataArray to add metadata to</span>

<span class="sd">        letter: if True, use letters starting from &#39;A&#39; (rather than integers) for the</span>
<span class="sd">            new ID variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO TODO add axis kwarg? or just transpose (and back) always when using?</span>
    <span class="c1"># TODO TODO option to add directly to an index level?</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">group_keys</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_id&#39;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">data</span>
        <span class="c1"># Just to make sure we don&#39;t get SetWithCopyWarnings when assigning below.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="c1"># TODO maybe don&#39;t raise this if there are valid cases where the</span>
            <span class="c1"># assign_coords call wouldn&#39;t need the tuple RHS (with this dim value)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;must pass dim=&lt;dimension from data.dims to add group ID &#39;</span>
                <span class="s1">&#39;to&gt; for xarray input&#39;</span>
            <span class="p">)</span>

        <span class="c1"># TODO TODO TODO should i add handling for input where some coordinates in</span>
        <span class="c1"># group_keys are not associated with a dimension (as long as there are no</span>
        <span class="c1"># conflicts as to which dimension the coordinates in group_keys correspond</span>
        <span class="c1"># to...)? (if so, returned DataArray should probably move unassigned variables</span>
        <span class="c1"># to selected dimension)</span>
        <span class="c1"># or just require input has all group_keys assigned to (same) dimension?</span>

        <span class="k">assert</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">coords</span>
        <span class="c1"># Using data[n].values didn&#39;t make a difference in one test (same result).</span>
        <span class="c1"># (and didn&#39;t fix TypeError when some, but not all, group_keys are scalars, but</span>
        <span class="c1"># led to a diff TypeError. may or may not have been important those vars were</span>
        <span class="c1"># also not among coordinates)</span>
        <span class="c1">#df = pd.DataFrame({n: data[n].values for n in group_keys})</span>
        <span class="c1">#import ipdb; ipdb.set_trace()</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="n">n</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">group_keys</span><span class="p">})</span>

    <span class="c1"># TODO does sort work as expected if they are index levels?</span>
    <span class="n">group_ids</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">group_keys</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span><span class="o">.</span><span class="n">ngroup</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">letter</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">group_ids</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">26</span>
        <span class="n">group_ids</span> <span class="o">=</span> <span class="n">group_ids</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">chr</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)))</span>

    <span class="k">elif</span> <span class="n">start_at_one</span><span class="p">:</span>
        <span class="n">group_ids</span> <span class="o">=</span> <span class="n">group_ids</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">df</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_ids</span>
        <span class="k">return</span> <span class="n">df</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="c1"># Because assign_coords docs says it returns a new object</span>
            <span class="c1"># (maybe it doesn&#39;t actually copy sometimes, or there are equivalent calls</span>
            <span class="c1"># that wouldn&#39;t need to?)</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;inplace=True not supported for DataArray input&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">group_ids</span><span class="p">)})</span></div>


<span class="c1"># TODO replace hardcoded recording_cols[:2] w/ kwarg that defaults to None where None</span>
<span class="c1"># gets replaced by current hardcoded value</span>
<span class="c1"># TODO TODO make option for all these to use letters instead of numbers, and probably</span>
<span class="c1"># have that be the default (to avoid ambiguity w/ fly_num, which is numbered within each</span>
<span class="c1"># day)</span>
<div class="viewcode-block" id="add_fly_id"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.add_fly_id">[docs]</a><span class="k">def</span> <span class="nf">add_fly_id</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;fly_id&#39;</span>
    <span class="c1"># TODO TODO replace prep_date w/ date in recording cols.</span>
    <span class="k">return</span> <span class="n">add_group_id</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">recording_cols</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="add_recording_id"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.add_recording_id">[docs]</a><span class="k">def</span> <span class="nf">add_recording_id</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;recording_id&#39;</span>
    <span class="k">return</span> <span class="n">add_group_id</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">recording_cols</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="thor2tiff"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.thor2tiff">[docs]</a><span class="nd">@thorimage_dir_input</span>
<span class="k">def</span> <span class="nf">thor2tiff</span><span class="p">(</span><span class="n">image_dir</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">output_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_basename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">output_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">if_exists</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;err&#39;</span><span class="p">,</span> <span class="n">flip_lr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">discard_channel_b</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">check_round_trip</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">_debug</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Converts ThorImage .raw file to .tif file in same directory</span>

<span class="sd">    Args:</span>
<span class="sd">        if_exists: &#39;load&#39;, &#39;ignore&#39;, &#39;overwrite&#39;, or &#39;err&#39;</span>

<span class="sd">        flip_lr: If True, flip the raw movie along the left/right axis, to make</span>
<span class="sd">            experiments including both left/right side data more comparable.</span>
<span class="sd">            If True/False, default output basename will be &#39;flipped.tif&#39;. If None,</span>
<span class="sd">            default output basename will remain &#39;raw.tif&#39;.</span>

<span class="sd">        check_round_trip: If True, and a TIFF was written, read it and check it is equal</span>
<span class="sd">            to data loaded from ThorImage raw.</span>

<span class="sd">    Returns an np.ndarray movie if TIFF was created OR if if_exists=&#39;load&#39; and</span>
<span class="sd">    the corresponding TIFF already exists. Returns None if if_exists=&#39;ignore&#39; and the</span>
<span class="sd">    corresponding TIFF already exists.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">if_exists_options</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;load&#39;</span><span class="p">,</span> <span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="s1">&#39;err&#39;</span><span class="p">,</span> <span class="s1">&#39;overwrite&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">if_exists</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">if_exists_options</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;if_exists must be one of </span><span class="si">{</span><span class="n">if_exists_options</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">output_name</span><span class="p">,</span> <span class="n">output_basename</span><span class="p">)]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;only pass at most one of output_name or output_basename&#39;</span><span class="p">)</span>

    <span class="n">image_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">image_dir</span><span class="p">)</span>

    <span class="c1"># TODO .tif or .tiff?</span>
    <span class="n">tiff_ext</span> <span class="o">=</span> <span class="s1">&#39;.tif&#39;</span>

    <span class="k">if</span> <span class="n">flip_lr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">default_output_basename</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;raw</span><span class="si">{</span><span class="n">tiff_ext</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Naming it &#39;flipped&#39; in both the cases where we do/don&#39;t flip (as long as</span>
        <span class="c1"># flip_lr is specified True/False, so other analysis can know that we at least</span>
        <span class="c1"># made the decision as to whether to flip this data, whether or not we actually</span>
        <span class="c1"># flipped it)</span>
        <span class="n">default_output_basename</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;flipped</span><span class="si">{</span><span class="n">tiff_ext</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">if</span> <span class="n">output_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">output_basename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output_basename</span> <span class="o">=</span> <span class="n">default_output_basename</span>

    <span class="k">if</span> <span class="n">output_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">output_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_dir</span> <span class="o">=</span> <span class="n">image_dir</span>

        <span class="c1"># TODO maybe just make it?</span>
        <span class="k">assert</span> <span class="n">isdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;output_dir=</span><span class="si">{</span><span class="n">output_dir</span><span class="si">}</span><span class="s1"> was not a directory&#39;</span>
        <span class="n">output_name</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">output_basename</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">output_name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">if_exists</span> <span class="o">==</span> <span class="s1">&#39;ignore&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;TIFF </span><span class="si">{</span><span class="n">output_name</span><span class="si">}</span><span class="s1"> already exists. doing nothing.&#39;</span><span class="p">)</span>

            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">elif</span> <span class="n">if_exists</span> <span class="o">==</span> <span class="s1">&#39;load&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;TIFF </span><span class="si">{</span><span class="n">output_name</span><span class="si">}</span><span class="s1"> exists. reading it (instead of raw)...&#39;</span><span class="p">,</span>
                    <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
                <span class="p">)</span>

            <span class="n">movie</span> <span class="o">=</span> <span class="n">tifffile</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">output_name</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">_debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; done&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># NOTE that if this will not returned any flipped version that might exist</span>
            <span class="c1"># UNLESS 1) it already exists, AND 2) flip_lr=False/True (not None)</span>
            <span class="c1"># TODO return as xarray? w/ flag to disable?</span>
            <span class="k">return</span> <span class="n">movie</span>

        <span class="k">elif</span> <span class="n">if_exists</span> <span class="o">==</span> <span class="s1">&#39;err&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">output_name</span><span class="si">}</span><span class="s1"> exists (set if_exists to either &#39;</span>
                <span class="s2">&quot;&#39;overwrite&#39; or &#39;ignore&#39; for other behavior&quot;</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">if_exists</span> <span class="o">==</span> <span class="s1">&#39;overwrite&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;TIFF </span><span class="si">{</span><span class="n">output_name</span><span class="si">}</span><span class="s1"> existed. overwriting.&#39;</span><span class="p">)</span>

    <span class="c1"># TODO maybe also load metadata like fps (especially stuff, as w/ fps, that isn&#39;t</span>
    <span class="c1"># already baked into the TIFF, assuming the TIFF is saved correctly. so not</span>
    <span class="c1"># including stuff like z, c, xy), and print w/ -v flag?</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;reading raw movie...&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="n">movie</span> <span class="o">=</span> <span class="n">thor</span><span class="o">.</span><span class="n">read_movie</span><span class="p">(</span><span class="n">image_dir</span><span class="p">,</span> <span class="n">discard_channel_b</span><span class="o">=</span><span class="n">discard_channel_b</span><span class="p">,</span>
        <span class="n">_debug</span><span class="o">=</span><span class="n">_debug</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; done&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">flip_lr</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;flipping movie along left/right axis, as requested&#39;</span><span class="p">)</span>

        <span class="c1"># axis=-1 should be the X axis (in a ([z,], y, x) shape movie), and does</span>
        <span class="c1"># visually flip left/right when plotting frames.</span>
        <span class="n">movie</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">movie</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># TODO TODO try to figure out if anything can be done about tifffile using so much</span>
    <span class="c1"># memory on writing (says &quot;Killed&quot; and exits in the middle of writing when trying to</span>
    <span class="c1"># write what should be a ~5.5GB movie when i have close to 20GB of RAM free...).</span>
    <span class="c1"># maybe memory profile my own code to see if i&#39;m doing something stupid. related to</span>
    <span class="c1"># imagej=True kwarg?</span>
    <span class="c1"># TODO test read_movie on all thorimage .raw outputs i have to check which can</span>
    <span class="c1"># currently reproduce this issue</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;writing TIFF to </span><span class="si">{</span><span class="n">output_name</span><span class="si">}</span><span class="s1">...&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="c1"># TODO (prob not relevant after no longer saving imagej=True tiffs w/ tifffile) add</span>
    <span class="c1"># option to catch:</span>
    <span class="c1"># `Warning: &lt;tifffile.TiffWriter &#39;raw.tif&#39;&gt; truncating ImageJ file` and convert to</span>
    <span class="c1"># error? i think there may be a regime where the warning isn&#39;t an issue, but also</span>
    <span class="c1"># seems like i may have now found another regime where it is...</span>
    <span class="n">write_tiff</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span> <span class="n">movie</span><span class="p">,</span> <span class="n">_debug</span><span class="o">=</span><span class="n">_debug</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; done&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">check_round_trip</span><span class="p">:</span>
        <span class="c1"># Leaving this on verbose rather than _debug, because it could take some time</span>
        <span class="c1"># and we don&#39;t want it to become a core pare of a pipeline w/o being aware of</span>
        <span class="c1"># it.</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;reading written TIFF for round trip check...&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">TiffFile</span><span class="p">(</span><span class="n">output_name</span><span class="p">)</span> <span class="k">as</span> <span class="n">tif</span><span class="p">:</span>
            <span class="c1"># NOTE: currently assuming movie.shape of (t, z, y, x)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span>
            <span class="n">nt</span><span class="p">,</span> <span class="n">nz</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">assert</span> <span class="n">nt</span> <span class="o">&gt;</span> <span class="mi">1</span>
            <span class="k">assert</span> <span class="n">ny</span> <span class="o">&gt;</span> <span class="mi">1</span>
            <span class="k">assert</span> <span class="n">nx</span> <span class="o">&gt;</span> <span class="mi">1</span>

            <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">nz</span><span class="p">)))</span>

            <span class="c1"># NOTE: len(tif.pages) == 1 in (probably) truncated TIFF w/ that large</span>
            <span class="c1"># George+Sam input (despite len(indices) == 6500 * 12 == 78000)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">tif</span><span class="o">.</span><span class="n">pages</span><span class="p">),</span> <span class="s1">&#39;tif likely truncated&#39;</span>

            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">page</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">tif</span><span class="o">.</span><span class="n">pages</span><span class="p">),</span> <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span>
                <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;checking TIFF vs raw frames&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;XY frames&#39;</span><span class="p">,</span> <span class="n">leave</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

                <span class="n">frame</span> <span class="o">=</span> <span class="n">movie</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">frame2</span> <span class="o">=</span> <span class="n">page</span><span class="o">.</span><span class="n">asarray</span><span class="p">()</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">frame2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; passed&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># TODO return as xarray? w/ flag to disable? maybe build a decorator to</span>
    <span class="c1"># automatically handle that conversion + add kwarg to toggle (how to get metadata</span>
    <span class="c1"># though...)?</span>
    <span class="k">return</span> <span class="n">movie</span></div>


<span class="c1"># TODO test</span>
<span class="c1"># TODO use in al_analysis.py (and other places i&#39;m checking indices equal w/o checking</span>
<span class="c1"># data equal)</span>
<span class="c1"># TODO add kwarg for also checking index name[s]?</span>
<div class="viewcode-block" id="pd_indices_equal"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.pd_indices_equal">[docs]</a><span class="k">def</span> <span class="nf">pd_indices_equal</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">DataFrameOrSeries</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">DataFrameOrSeries</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
    <span class="n">if_index_mismatch</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        a|b: inputs to compare. must both be either DataFrames or Series.</span>

<span class="sd">        if_index_mismatch: whether to return False (None), warn (and return False), or</span>
<span class="sd">            raise ValueError if either row/column indices do not match</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_indices_equal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="c1"># TODO factor this axis checking into fn [decorator?]?</span>
        <span class="k">assert</span> <span class="n">axis</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="s1">&#39;columns&#39;</span><span class="p">)</span>

        <span class="n">index1</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">index2</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="c1"># TODO need/want to check [index|columns].name[s] ever? Series case?</span>
        <span class="k">if</span> <span class="n">index1</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">index2</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;index&#39;</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;row index mismatch&#39;</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;columns&#39;</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;columns mismatch&#39;</span>

        <span class="k">if</span> <span class="n">if_index_mismatch</span> <span class="o">==</span> <span class="s1">&#39;warn&#39;</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">if_index_mismatch</span> <span class="o">==</span> <span class="s1">&#39;err&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">_indices_equal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="s1">&#39;index&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="c1"># TODO don&#39;t assert (share if_index_mismatch / similar for this -&gt; raise</span>
        <span class="c1"># ValueError?)?</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_indices_equal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="s1">&#39;columns&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># TODO don&#39;t?</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span>

    <span class="k">return</span> <span class="kc">True</span></div>


<span class="c1"># TODO add support for dtype mismatch (but where one can be cast to the other)?  maybe</span>
<span class="c1"># also support for cols in diff orders? utility fns (maybe exposed behind verbose kwarg)</span>
<span class="c1"># for printing differences between dtypes / etc? (use new dtypes_equal fn below for</span>
<span class="c1"># this?)</span>
<span class="c1"># TODO test</span>
<span class="c1"># TODO option to ignore values that are NaN in one and defined in the other? (or</span>
<span class="c1"># similar fn for that?)? maybe still (optionally?) warning about how many NaN values are</span>
<span class="c1"># only in one or the other? (and also for pd_isclose below, if so)</span>
<span class="c1"># TODO TODO default to equal_nan=True (maybe warning if there are NaN unless explicitly</span>
<span class="c1"># set True?)?</span>
<div class="viewcode-block" id="pd_allclose"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.pd_allclose">[docs]</a><span class="k">def</span> <span class="nf">pd_allclose</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">DataFrameOrSeries</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">DataFrameOrSeries</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
    <span class="n">if_index_mismatch</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        a|b: inputs to compare. must both be either DataFrames or Series.</span>

<span class="sd">        if_index_mismatch: passed to `pd_indices_equal`</span>

<span class="sd">        **kwargs: passed thru to `np.allclose` (`equal_nan=True` may be the most useful)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pd_indices_equal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">if_index_mismatch</span><span class="o">=</span><span class="n">if_index_mismatch</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="pd_isclose"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.pd_isclose">[docs]</a><span class="k">def</span> <span class="nf">pd_isclose</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">DataFrameOrSeries</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">DataFrameOrSeries</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Like `np.isclose`, but preserves input indices.</span>

<span class="sd">    Args:</span>
<span class="sd">        a|b: inputs to compare. must both be either DataFrames or Series.</span>

<span class="sd">        **kwargs: passed thru to `np.allclose` (`equal_nan=True` may be the most useful)</span>

<span class="sd">    Raises ValueError if indices do not match.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># not sure what isclose behavior is if shapes mismatch, but only really imagine</span>
    <span class="c1"># using this fn for like-indexed stuff anyway</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">pd_indices_equal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">if_index_mismatch</span><span class="o">=</span><span class="s1">&#39;err&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">raise</span>

    <span class="n">isclose</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># can just use metadata from `a`, since we already know `b` has the same index data</span>
    <span class="c1"># from above</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">isclose</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">isclose</span><span class="p">)</span></div>


<div class="viewcode-block" id="dtypes_equal"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.dtypes_equal">[docs]</a><span class="k">def</span> <span class="nf">dtypes_equal</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">reorder_cols</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">cast</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>

    <span class="c1"># NOTE: Series do not seem to have dtypes available on a per-key basis anymore. just</span>
    <span class="c1"># has one dtype (and a .dtypes attribute, but still just a scalar, not per-column).</span>
    <span class="c1"># tested by doing .iloc to get a Series from a DataFrame with non-uniform values in</span>
    <span class="c1"># .dtypes.</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">reorder_cols</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">a</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">duplicated</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">b</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">duplicated</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
            <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">cast</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">dtypes</span><span class="p">):</span>
        <span class="c1"># TODO how will this fail if casting not possible? need to catch and return</span>
        <span class="c1"># False?</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtypes</span><span class="p">)</span>

    <span class="n">equal</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">dtypes</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">equal</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;mismatching dtypes:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dtypes</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">dtypes</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">equal</span></div>


<span class="c1"># TODO use (/delete)</span>
<div class="viewcode-block" id="subset_levels"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.subset_levels">[docs]</a><span class="k">def</span> <span class="nf">subset_levels</span><span class="p">(</span><span class="n">index</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">,</span> <span class="n">subset</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">:</span>
    <span class="c1"># does pandas really still not have a function like this? am i missing something?</span>
    <span class="c1"># TODO work w/ one level index? change type hint to `-&gt; pd.MultiIndex` if so?</span>
    <span class="c1"># if not, fix</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_frame</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="n">subset</span><span class="p">])</span></div>


<span class="c1"># TODO add unit tests w/ inputs that are both MultiIndex / not</span>
<div class="viewcode-block" id="index2dict_list"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.index2dict_list">[docs]</a><span class="k">def</span> <span class="nf">index2dict_list</span><span class="p">(</span><span class="n">index</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;Returns list of dicts, each with `index.names` keys and index values.</span>

<span class="sd">    Raises ValueError if `index.names` elements are not all of type `str`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">names</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">names</span>
    <span class="k">if</span> <span class="p">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">}</span> <span class="o">!=</span> <span class="p">{</span><span class="nb">str</span><span class="p">}:</span>
        <span class="c1"># TODO also say what types we currently have</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;index.names must all be of type `str`&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_index_entry_dict</span><span class="p">(</span><span class="n">index</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span> <span class="n">index_entry</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="c1"># If the index is a MultiIndex, iterating over it should yield tuples of the</span>
        <span class="c1"># level values, otherwise we&#39;ll convert to a tuple so zipping is the same.</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">index_entry</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="c1"># only non-MultiIndex index should have non-tuple index_entry (otherwise</span>
            <span class="c1"># wrong index may have been passed in)</span>
            <span class="c1"># https://stackoverflow.com/questions/21081042</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">)</span>
            <span class="n">index_entry</span> <span class="o">=</span> <span class="p">(</span><span class="n">index_entry</span><span class="p">,)</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_entry</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">names</span><span class="si">=}</span><span class="se">\n</span><span class="si">{</span><span class="n">index_entry</span><span class="si">=}</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">index_entry</span><span class="p">))</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">_index_entry_dict</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">index</span><span class="p">]</span></div>


<div class="viewcode-block" id="frame_pdist"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.frame_pdist">[docs]</a><span class="k">def</span> <span class="nf">frame_pdist</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns a DataFrame matrix of all pairwise distances between input rows.</span>

<span class="sd">    Returns output of same shape as DataFrame.corr() (calculating distances between</span>
<span class="sd">    all pairs of input *rows*), so output rows and columns will be same as input</span>
<span class="sd">    columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">squareform</span><span class="p">(</span><span class="n">pdist</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)),</span> <span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
        <span class="n">columns</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span>
    <span class="p">)</span></div>


<span class="c1"># TODO rename from melt (if that&#39;s not the closest-functionality pandas fn)?</span>
<span class="c1"># TODO still want all these kwargs?</span>
<span class="c1"># TODO get to work w/ xarray input too</span>
<span class="c1"># TODO TODO and also support case where input DataArray has one dimension along</span>
<span class="c1"># which a series of symmetric matrices have been concatenated, and handle that too</span>
<span class="c1"># (e.g. shape (5, 27, 27) series of 5 correlation matrices, one for each of 5 flies)</span>
<span class="c1"># TODO test that it also works w/o MultiIndex indices</span>
<div class="viewcode-block" id="melt_symmetric"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.melt_symmetric">[docs]</a><span class="k">def</span> <span class="nf">melt_symmetric</span><span class="p">(</span><span class="n">symmetric_df</span><span class="p">,</span> <span class="n">drop_constant_levels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;_a&#39;</span><span class="p">,</span> <span class="s1">&#39;_b&#39;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keep_duplicate_values</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes a symmetric DataFrame to a tidy Series with unique values.</span>

<span class="sd">    Symmetric means the row and columns indices are equal, and values should</span>
<span class="sd">    be a symmetric matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This is actually not dependent on the level names / .name (if we wanted to check</span>
    <span class="c1"># those + the types as well, we&#39;d use .identical(...)), so it&#39;s ok if the</span>
    <span class="c1"># columns/index are already e.g. called &#39;odor&#39; &amp; &#39;odor_b&#39;, respectively.</span>
    <span class="k">assert</span> <span class="n">symmetric_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">symmetric_df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="c1"># TODO put behind a flag at the minimum?</span>
    <span class="n">symmetric_df</span> <span class="o">=</span> <span class="n">symmetric_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">symmetric_df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">symmetric_df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">symmetric_df</span><span class="o">.</span><span class="n">notnull</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span> <span class="s1">&#39;not tested w/ non-all NaN&#39;</span>

    <span class="n">multiindices</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># Assuming index/columns are the same type (either MultiIndex or not)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">symmetric_df</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
        <span class="n">multiindices</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># If identical(...) fails, that should mean the .names/.name attributes differed</span>
    <span class="c1"># (formally the dtypes could have differed too), as the .equals(...) assertion above</span>
    <span class="c1"># passed.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">symmetric_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">identical</span><span class="p">(</span><span class="n">symmetric_df</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
        <span class="c1"># TODO factor out?</span>
        <span class="k">def</span> <span class="nf">get_index_names</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">index</span><span class="o">.</span><span class="n">names</span> <span class="k">if</span> <span class="n">multiindices</span> <span class="k">else</span> <span class="p">[</span><span class="n">index</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

        <span class="n">col_names</span> <span class="o">=</span>  <span class="n">get_index_names</span><span class="p">(</span><span class="n">symmetric_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">index_names</span> <span class="o">=</span> <span class="n">get_index_names</span><span class="p">(</span><span class="n">symmetric_df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># TODO use ValueError rather than assertions</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">x</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">suffixes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">col_names</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">x</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">suffixes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">index_names</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># TODO make all of this index name/level names renaming conditional on kwarg?</span>
        <span class="k">if</span> <span class="n">multiindices</span><span class="p">:</span>
            <span class="c1"># TODO adapt to work in non-multiindex case too! (rename there?)</span>
            <span class="n">symmetric_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">rename</span><span class="p">([</span><span class="n">n</span> <span class="o">+</span> <span class="n">suffixes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span>
                <span class="n">symmetric_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">symmetric_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">rename</span><span class="p">([</span><span class="n">n</span> <span class="o">+</span> <span class="n">suffixes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span>
                <span class="n">symmetric_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">names</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO TODO maybe i still want to do this in the multiindex case tho?</span>
            <span class="c1"># would it break my old code that used this in kc_natural_mixes?</span>
            <span class="n">old_name</span> <span class="o">=</span> <span class="n">symmetric_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span>
            <span class="k">assert</span> <span class="n">old_name</span> <span class="o">==</span> <span class="n">symmetric_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span>
            <span class="n">symmetric_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">old_name</span><span class="si">}{</span><span class="n">suffixes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">symmetric_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">old_name</span><span class="si">}{</span><span class="n">suffixes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="c1"># TODO maybe always test that triu equals tril tho (or w/ a _checks=True set)</span>

    <span class="c1"># To de-clutter what would otherwise become a highly-nested index.</span>
    <span class="k">if</span> <span class="n">multiindices</span> <span class="ow">and</span> <span class="n">drop_constant_levels</span><span class="p">:</span>
        <span class="c1"># TODO may need to call index.remove_unused_levels() first, if using</span>
        <span class="c1"># levels here... (see docs of that remove fn)</span>
        <span class="n">constant_levels</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">levels</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">symmetric_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="p">]</span>
        <span class="n">symmetric_df</span> <span class="o">=</span> <span class="n">symmetric_df</span><span class="o">.</span><span class="n">droplevel</span><span class="p">(</span><span class="n">constant_levels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
        <span class="n">symmetric_df</span> <span class="o">=</span> <span class="n">symmetric_df</span><span class="o">.</span><span class="n">droplevel</span><span class="p">(</span><span class="n">constant_levels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>

    <span class="c1"># TODO maybe an option to interleave the new index names</span>
    <span class="c1"># (so it&#39;s like name1_a, name1_b, ... rather than *_a, *_b)</span>
    <span class="c1"># or would that not ever really be useful?</span>

    <span class="k">if</span> <span class="n">keep_duplicate_values</span><span class="p">:</span>
        <span class="n">tidy</span> <span class="o">=</span> <span class="n">symmetric_df</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">symmetric_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">tidy</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">symmetric_df</span><span class="o">.</span><span class="n">shape</span><span class="p">),)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># From: https://stackoverflow.com/questions/34417685</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">symmetric_df</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
        <span class="n">masked</span> <span class="o">=</span> <span class="n">symmetric_df</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">keep</span><span class="p">)</span>
        <span class="n">n_nonnull</span> <span class="o">=</span> <span class="n">masked</span><span class="o">.</span><span class="n">notnull</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c1"># We already know both elements of shape are the same from equality</span>
        <span class="c1"># check on indices above.</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">symmetric_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># The right expression is the number of elements expected for the</span>
        <span class="c1"># triangular of a square matrix w/ side length n, if the diagonal</span>
        <span class="c1"># is INCLUDED.</span>
        <span class="k">assert</span> <span class="n">n_nonnull</span> <span class="o">==</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># TODO make sure this also still works in non-multiindex case!</span>
        <span class="n">tidy</span> <span class="o">=</span> <span class="n">masked</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">masked</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">tidy</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">n_nonnull</span><span class="p">,)</span>

    <span class="n">tidy</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="k">return</span> <span class="n">tidy</span></div>


<span class="c1"># TODO rename if it could make it more accurate</span>
<div class="viewcode-block" id="invert_melt_symmetric"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.invert_melt_symmetric">[docs]</a><span class="k">def</span> <span class="nf">invert_melt_symmetric</span><span class="p">(</span><span class="n">ser</span><span class="p">,</span> <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;_a&#39;</span><span class="p">,</span> <span class="s1">&#39;_b&#39;</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ser</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;not a series&#39;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ser</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ser</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">)),</span> \
        <span class="s1">&#39;index names should be unique&#39;</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">suffixes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">suffixes</span><span class="p">))</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">suffixes</span>

    <span class="n">levels_to_drop</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ser</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
    <span class="n">col_prefixes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ser</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">s0</span><span class="p">):</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="n">c</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">s0</span><span class="p">)]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="n">s1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ser</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="n">col_prefixes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
                <span class="n">levels_to_drop</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="n">s0</span><span class="p">)</span>
                <span class="n">levels_to_drop</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="n">s1</span><span class="p">)</span>

    <span class="n">levels_to_drop</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">levels_to_drop</span><span class="p">)</span>
    <span class="c1"># This does also work in the case where `levels_to_drop` is empty.</span>
    <span class="n">ser</span> <span class="o">=</span> <span class="n">ser</span><span class="o">.</span><span class="n">droplevel</span><span class="p">(</span><span class="n">levels_to_drop</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ser</span><span class="o">.</span><span class="n">unstack</span><span class="p">([</span><span class="n">p</span> <span class="o">+</span> <span class="n">s0</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">col_prefixes</span><span class="p">])</span></div>


<span class="c1"># TODO move this (+ other appropriate stuff), to a pandas.py module like my xarray.py</span>
<div class="viewcode-block" id="check_index_vals_unique"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.check_index_vals_unique">[docs]</a><span class="k">def</span> <span class="nf">check_index_vals_unique</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Raises AssertionError if any duplicates in column/index indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">duplicated</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">duplicated</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">())</span></div>


<span class="c1"># TODO also factor to a pandas module</span>
<span class="c1"># TODO already have something like this?</span>
<span class="c1"># TODO typehint subclass of Index? already good on that?</span>
<div class="viewcode-block" id="get_axis_index"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.get_axis_index">[docs]</a><span class="k">def</span> <span class="nf">get_axis_index</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;index&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span>
    <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;columns&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;invalid axis: </span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>


<span class="c1"># TODO also factor to a pandas module</span>
<div class="viewcode-block" id="suffix_index_names"><a class="viewcode-back" href="../../apidoc/hong2p.util.html#hong2p.util.suffix_index_names">[docs]</a><span class="k">def</span> <span class="nf">suffix_index_names</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;_b&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># TODO TODO also support non-multiindex w/ .name</span>
    <span class="c1"># TODO factor out helper to get df</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">get_axis_index</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="n">index</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">}{</span><span class="n">suffix</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">]</span></div>
    <span class="c1"># TODO make not inplace?</span>

</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2022, Tom O&#39;Connell.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>hong2p.olf &mdash; hong2p 0.0.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> hong2p
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../apidoc/modules.html">hong2p</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">hong2p</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>hong2p.olf</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for hong2p.olf</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Functions for loading YAML metadata created by my tom-f-oconnell/olfactometer repo, and</span>
<span class="sd">dealing with the resulting representations of odors delivered during an experiment.</span>

<span class="sd">Keeping these functions here rather than in the olfactometer repo because it has other</span>
<span class="sd">somewhat heavy dependencies that the analysis side of things will generally not need.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">Counter</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Hashable</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>


<span class="n">solvent_str</span> <span class="o">=</span> <span class="s1">&#39;solvent&#39;</span>
<span class="n">conc_delimiter</span> <span class="o">=</span> <span class="s1">&#39;@&#39;</span>

<div class="viewcode-block" id="parse_log10_conc"><a class="viewcode-back" href="../../apidoc/hong2p.olf.html#hong2p.olf.parse_log10_conc">[docs]</a><span class="k">def</span> <span class="nf">parse_log10_conc</span><span class="p">(</span><span class="n">odor_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Takes formatted odor string to float log10 vol/vol concentration.</span>

<span class="sd">    &gt;&gt;&gt; parse_log10_conc(&#39;ethyl acetate @ -2&#39;)</span>
<span class="sd">    -2.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If conc_delimiter is in the string, we are assuming that it should be followed by</span>
    <span class="c1"># parseable float concentration. Letting it err below if that is not the case.</span>
    <span class="k">if</span> <span class="n">conc_delimiter</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">odor_str</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">parts</span> <span class="o">=</span> <span class="n">odor_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">conc_delimiter</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span></div>


<div class="viewcode-block" id="parse_odor_name"><a class="viewcode-back" href="../../apidoc/hong2p.olf.html#hong2p.olf.parse_odor_name">[docs]</a><span class="k">def</span> <span class="nf">parse_odor_name</span><span class="p">(</span><span class="n">odor_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="c1"># TODO some way to get the generated docs to refer to the value for the constant</span>
    <span class="c1"># rather than having to hardcode it for reference? a plugin maybe?</span>
    <span class="sd">&quot;&quot;&quot;Takes formatted odor string to just the name of the odor.</span>

<span class="sd">    Input must contain `olf.conc_delimiter` (&#39;@&#39;).</span>

<span class="sd">    &gt;&gt;&gt; parse_odor_name(&#39;ethyl acetate @ -2&#39;)</span>
<span class="sd">    &#39;ethyl acetate&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">conc_delimiter</span> <span class="ow">in</span> <span class="n">odor_str</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">odor_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">conc_delimiter</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="c1"># TODO want to handle &#39;pfo&#39;/&#39;solvent&#39; special?</span>
    <span class="k">return</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span></div>


<span class="c1"># TODO maybe take a name_order kwarg here and return index of name in list instead, if</span>
<span class="c1"># passed? then maybe unify w/ other place that currently does something similar?</span>
<span class="c1"># TODO TODO may want to sort by concentration THEN name, to be consistent w/</span>
<span class="c1"># odor_index_sortkey (or maybe change that one?)</span>
<div class="viewcode-block" id="odordict_sort_key"><a class="viewcode-back" href="../../apidoc/hong2p.olf.html#hong2p.olf.odordict_sort_key">[docs]</a><span class="k">def</span> <span class="nf">odordict_sort_key</span><span class="p">(</span><span class="n">odor_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Returns a hashable key for sorting odors by name, then concentration.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">odor_dict</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>

    <span class="c1"># If present, we expect this value to be a non-positive number.</span>
    <span class="c1"># Using 0 as default for lack of &#39;log10_conc&#39; key because that case should indicate</span>
    <span class="c1"># some type of pure odor (or something where the concentration is specified in the</span>
    <span class="c1"># name / unknown). &#39;5% cleaning ammonia in water&#39; for example, where original</span>
    <span class="c1"># concentration of cleaning ammonia is unknown.</span>
    <span class="n">log10_conc</span> <span class="o">=</span> <span class="n">odor_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;log10_conc&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># &#39;log10_conc: null&#39; in one of the YAMLs should map to None here.</span>
    <span class="k">if</span> <span class="n">log10_conc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">log10_conc</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">log10_conc</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="n">f</span><span class="s1">&#39;type(</span><span class="si">{log10_conc}</span><span class="s1">) == {type(log10_conc)}&#39;</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">log10_conc</span><span class="p">)</span></div>


<div class="viewcode-block" id="sort_odor_list"><a class="viewcode-back" href="../../apidoc/hong2p.olf.html#hong2p.olf.sort_odor_list">[docs]</a><span class="k">def</span> <span class="nf">sort_odor_list</span><span class="p">(</span><span class="n">odor_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a sorted list of dicts representing odors for one trial</span>

<span class="sd">    Name takes priority over concentration, so with the same set of odor names in each</span>
<span class="sd">    trial&#39;s odor_list, this should produce a consistent ordering (and same indexes can</span>
<span class="sd">    be used assuming equal length of all)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">odor_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">odordict_sort_key</span><span class="p">)</span></div>


<div class="viewcode-block" id="odor_index_sort_key"><a class="viewcode-back" href="../../apidoc/hong2p.olf.html#hong2p.olf.odor_index_sort_key">[docs]</a><span class="k">def</span> <span class="nf">odor_index_sort_key</span><span class="p">(</span><span class="n">level</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span> <span class="n">sort_names</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">names_first</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">name_order</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        level: a pd.Index containing one level of a MultiIndex with odor metadata.</span>
<span class="sd">            elements should be odor strings.</span>

<span class="sd">        sort_names: whether to use odor names as part of sort key. If False, only sorts</span>
<span class="sd">            on concentrations.</span>

<span class="sd">        names_first: if True, sorts on names primarily, otherwise sorts on</span>
<span class="sd">            concentrations primarily. Ignored if sort_names is False.</span>

<span class="sd">        name_order: list of odor names to use as a fixed order for the names.</span>
<span class="sd">            Concentrations will be sorted within each name.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">name_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">sort_names</span> <span class="o">==</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;sort_names should be True if name_order passed&#39;</span>

    <span class="c1"># The assignment below failed for some int dtype levels, even though the boolean</span>
    <span class="c1"># mask dictating where assignment should happen must have been all False...</span>
    <span class="k">if</span> <span class="n">level</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;O&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">level</span>

    <span class="c1"># prob don&#39;t need the .values most/all places anymore, but would need to test</span>
    <span class="n">odor_strs</span> <span class="o">=</span> <span class="n">level</span><span class="o">.</span><span class="n">values</span>

    <span class="c1"># Will be overwritten with floats (either log10 concentration, or another float to</span>
    <span class="c1"># appropriately order solvent elements).</span>
    <span class="n">conc_keys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">odor_strs</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">solvent_elements</span> <span class="o">=</span> <span class="n">odor_strs</span> <span class="o">==</span> <span class="n">solvent_str</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="n">conc_delimiter</span> <span class="ow">in</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">odor_strs</span><span class="p">[</span><span class="o">~</span> <span class="n">solvent_elements</span><span class="p">]])</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">solvent_elements</span><span class="p">):</span>
        <span class="n">nonsolvent_conc_keys</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">parse_log10_conc</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">odor_strs</span><span class="p">[</span><span class="o">~</span> <span class="n">solvent_elements</span><span class="p">]</span>
        <span class="p">]</span>
        <span class="n">conc_keys</span><span class="p">[</span><span class="o">~</span> <span class="n">solvent_elements</span><span class="p">]</span> <span class="o">=</span> <span class="n">nonsolvent_conc_keys</span>
        <span class="n">conc_keys</span><span class="p">[</span><span class="n">solvent_elements</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">conc_keys</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">sort_names</span><span class="p">:</span>
            <span class="n">min_name_key</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">)</span>
            <span class="n">name_keys</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">parse_odor_name</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">solvent_str</span> <span class="k">else</span> <span class="n">min_name_key</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">level</span>
            <span class="p">]</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">name_keys</span> <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">min_name_key</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">name_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Making alphabetical. Need to still use the .index call to key name</span>
                <span class="c1"># keys because the -inf is not comparable to str.</span>
                <span class="c1"># NOTE: i didn&#39;t catch this error until a test w/ only &#39;odor&#39; index, not</span>
                <span class="c1"># the earlier tests w/ usual multiindex. not sure why... bug?</span>
                <span class="n">name_order</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">n</span> <span class="ow">in</span> <span class="n">name_order</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">):</span>
                    <span class="c1"># TODO only print the ones missing</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="n">f</span><span class="s1">&#39;some of names=</span><span class="si">{names}</span><span class="s1"> were not in name_order=</span><span class="si">{name_order}</span><span class="s1">&#39;</span>
                    <span class="p">)</span>

            <span class="n">name_keys</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">name_order</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">min_name_key</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">name_keys</span>
            <span class="p">]</span>

            <span class="k">if</span> <span class="n">names_first</span><span class="p">:</span>
                <span class="n">sort_keys</span> <span class="o">=</span> <span class="p">(</span><span class="n">name_keys</span><span class="p">,</span> <span class="n">conc_keys</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sort_keys</span> <span class="o">=</span> <span class="p">(</span><span class="n">conc_keys</span><span class="p">,</span> <span class="n">name_keys</span><span class="p">)</span>

            <span class="n">sort_key</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">sort_keys</span><span class="p">))</span>

            <span class="c1"># tupleize_cols=False prevents a MultiIndex from being created</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">sort_key</span><span class="p">,</span> <span class="n">tupleize_cols</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">level</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">index</span>

    <span class="c1"># Converting back to an index so that `level=&lt;previous level name&gt;` arg to</span>
    <span class="c1"># `DataFrame.sort_index` doesn&#39;t get broken. This key function is used to generate</span>
    <span class="c1"># an intermediate Index pandas uses to sort, and that intermediate needs to have the</span>
    <span class="c1"># same level names to be able to refer to them as if it was the input object.</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">conc_keys</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">level</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="is_odor_var"><a class="viewcode-back" href="../../apidoc/hong2p.olf.html#hong2p.olf.is_odor_var">[docs]</a><span class="k">def</span> <span class="nf">is_odor_var</span><span class="p">(</span><span class="n">var_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns True if column/level name or Series-key is named to store odor metadata</span>

<span class="sd">    Variables behind matching names should store strings representing *one*, of</span>
<span class="sd">    potentially multiple, component odors presented on a given trial. My convention for</span>
<span class="sd">    representing multiple components presented together one one trial is to make</span>
<span class="sd">    multiple variables (e.g. columns), named such as [&#39;odor1&#39;, &#39;odor2&#39;, ...], with a</span>
<span class="sd">    different sufffix number for each component.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># For index [level] names that are not defined.</span>
    <span class="k">if</span> <span class="n">var_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">var_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;odor&#39;</span><span class="p">)</span></div>


<span class="c1"># TODO add some kind of lookup for odor panels (might just need to get the set of all</span>
<span class="c1"># (odor name, odor concentrations) used in experiment and compare that.  -&gt; force</span>
<span class="c1"># consistent order for things like kiwi.yaml/control1.yaml experiments (anything not</span>
<span class="c1"># pair that we actually wanna see plots for actually. probably just don&#39;t wanna sort</span>
<span class="c1"># glomeruli diagnostics) (only really relevant if i actually start randomizing order in</span>
<span class="c1"># those experiments... for now, could just not sort)</span>
<span class="c1"># TODO TODO some way to make it easy to support is_pair (or other things we wanna sort</span>
<span class="c1"># on before the odors?) (add kwarg for columns (+ key fns, via a dict mapping</span>
<span class="c1"># cols-&gt;key fns) to sort before / after odors (as well as orders via another dict?)?)</span>
<span class="c1"># (or just add columns to sort odors w/in groups of? but prob wouldn&#39;t wanna use</span>
<span class="c1"># groupby, rather find existing consecutive groups and sort within...)</span>
<div class="viewcode-block" id="sort_odors"><a class="viewcode-back" href="../../apidoc/hong2p.olf.html#hong2p.olf.sort_odors">[docs]</a><span class="k">def</span> <span class="nf">sort_odors</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="c1"># TODO add doctest examples clarifying how the two columns interact + what happens</span>
    <span class="c1"># to &#39;solvent&#39; (+ clarify in docstring)</span>
    <span class="c1"># TODO doctest examples w/ and w/o name_order</span>
    <span class="sd">&quot;&quot;&quot;Sorts DataFrame by odor index/columns.</span>

<span class="sd">    Args:</span>
<span class="sd">        df: DataFrame with columns/index-level names matching `is_odor_var`</span>
<span class="sd">        **kwargs: passed through to odor_index_sort_key</span>

<span class="sd">    Notes:</span>
<span class="sd">    Index will be checked first, and if it contains odor information, will sort on that.</span>
<span class="sd">    Otherwise, will check and sort on matching columns.</span>

<span class="sd">    Sorts by concentration, then name. &#39;solvent&#39; is treated as less than all odors.</span>

<span class="sd">    &gt;&gt;&gt; df = pd.DataFrame({</span>
<span class="sd">    ...     &#39;odor1&#39;: [&#39;B @ -2&#39;, &#39;A @ -2&#39;, &#39;A @ -3&#39;],</span>
<span class="sd">    ...     &#39;odor2&#39;: [&#39;solvent&#39;] * 3,</span>
<span class="sd">    ...     &#39;delta_f&#39;: [1.1, 1.2, 0.9]</span>
<span class="sd">    ... }).set_index([&#39;odor1&#39;, &#39;odor2&#39;])</span>

<span class="sd">    Names are sorted alphabetically by default, then within each name they are sorted by</span>
<span class="sd">    concentration. Pass `names_only=False` to only sort on concentration, or</span>
<span class="sd">    `names_first=False` to sort on concentrations first.</span>
<span class="sd">    &gt;&gt;&gt; sort_odors(df)</span>
<span class="sd">                    delta_f</span>
<span class="sd">    odor1  odor2</span>
<span class="sd">    A @ -3 solvent      0.9</span>
<span class="sd">    A @ -2 solvent      1.2</span>
<span class="sd">    B @ -2 solvent      1.1</span>

<span class="sd">    &gt;&gt;&gt; sort_odors(df, name_order=[&#39;B&#39;,&#39;A&#39;])</span>
<span class="sd">                    delta_f</span>
<span class="sd">    odor1  odor2</span>
<span class="sd">    B @ -2 solvent      1.1</span>
<span class="sd">    A @ -3 solvent      0.9</span>
<span class="sd">    A @ -2 solvent      1.2</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">levels_to_sort</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">index</span><span class="o">.</span><span class="n">names</span> <span class="k">if</span> <span class="n">is_odor_var</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>

    <span class="n">found_odor_multiindex</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">axis_name</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="s1">&#39;columns&#39;</span><span class="p">):</span>

        <span class="c1"># Sorting so that if something were to accidentally re-order e.g. &#39;odor1&#39;,</span>
        <span class="c1"># &#39;odor2&#39; levels, the sort order would be invariant to that, with &#39;odor1&#39; always</span>
        <span class="c1"># taking precedence in the sort.</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">levels_to_sort</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">)))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># TODO check my level sort key fn works in both case of 1 level passed in as</span>
            <span class="c1"># well as 2</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span>
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">odor_index_sort_key</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">axis_name</span><span class="p">,</span>
                <span class="n">level</span><span class="o">=</span><span class="n">levels</span><span class="p">,</span>
                <span class="n">sort_remaining</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="c1"># So that the sort is &quot;stable&quot;, meaning if stuff compares equal, it</span>
                <span class="c1"># preserves input order.</span>
                <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">found_odor_multiindex</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">found_odor_multiindex</span><span class="p">:</span>
        <span class="n">odor_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">is_odor_var</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">odor_cols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;df had no index levels or columns with hong2p.olf.&#39;</span>
                <span class="s1">&#39;is_odor_var(name) == True&#39;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;sorting odor columns not supported when &#39;</span>
                <span class="s1">&#39;there is an existing MultiIndex. call df.set_index(...) to include the&#39;</span>
                <span class="s1">&#39; odor columns, then pass that as input.&#39;</span>
            <span class="p">)</span>

        <span class="c1"># TODO also try to keep order of columns same</span>
        <span class="c1"># (current approach moves odor columns to the start)</span>
        <span class="n">temp_index_col</span> <span class="o">=</span> <span class="s1">&#39;_old_index&#39;</span>
        <span class="k">assert</span> <span class="n">temp_index_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span>
        <span class="c1"># Would have used reset_index(), but didn&#39;t see an argument to change the name</span>
        <span class="c1"># of the column it creates.</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">df</span><span class="p">[</span><span class="n">temp_index_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span>
        <span class="n">old_index_name</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">sort_odors</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">odor_cols</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">temp_index_col</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">old_index_name</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="k">return</span> <span class="n">df</span></div>


<span class="c1"># TODO maybe move to viz.py, since this is mainly intended as as helper for</span>
<span class="c1"># viz.with_panel_orders plotting function wrapper?</span>
<div class="viewcode-block" id="panel_odor_orders"><a class="viewcode-back" href="../../apidoc/hong2p.olf.html#hong2p.olf.panel_odor_orders">[docs]</a><span class="k">def</span> <span class="nf">panel_odor_orders</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">panel2name_order</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># TODO doctest example</span>
    <span class="sd">&quot;&quot;&quot;Returns dict of panel names to ordered unique odor strs.</span>

<span class="sd">    Args:</span>
<span class="sd">        df: DataFrame with columns &#39;panel&#39; and &gt;=1 matching `is_odor_var`</span>

<span class="sd">        panel2name_order: dict mapping panels to lists of odor names, each in the</span>
<span class="sd">            desired order</span>

<span class="sd">        **kwargs: passed through to sort_odors</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO test w/ input that has odor info in multiindex (does groupby fuck it up?)</span>
    <span class="k">assert</span> <span class="s1">&#39;name_order&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span>
    <span class="n">name_order</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">odor_cols</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">is_odor_var</span><span class="p">(</span><span class="n">c</span><span class="p">)])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">odor_cols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;must have &gt;=1 columns matching hong2p.olf.is_odor_var(name)&#39;</span><span class="p">)</span>

    <span class="n">panel2order</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">panel</span><span class="p">,</span> <span class="n">panel_df</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;panel&#39;</span><span class="p">):</span>
        <span class="n">panel_df</span> <span class="o">=</span> <span class="n">panel_df</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="n">odor_cols</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">panel2name_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name_order</span> <span class="o">=</span> <span class="n">panel2name_order</span><span class="p">[</span><span class="n">panel</span><span class="p">]</span>

        <span class="n">panel_df</span> <span class="o">=</span> <span class="n">sort_odors</span><span class="p">(</span><span class="n">panel_df</span><span class="p">,</span> <span class="n">name_order</span><span class="o">=</span><span class="n">name_order</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># TODO maybe factor out this (and preceding finding + sorting odor_cols)?</span>
        <span class="n">mix_strs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">format_mix_from_strs</span><span class="p">(</span><span class="n">ser</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">ser</span> <span class="ow">in</span> <span class="n">panel_df</span><span class="p">[</span><span class="n">odor_cols</span><span class="p">]</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()</span>
        <span class="p">]</span>
        <span class="n">panel2order</span><span class="p">[</span><span class="n">panel</span><span class="p">]</span> <span class="o">=</span> <span class="n">mix_strs</span>

    <span class="k">return</span> <span class="n">panel2order</span></div>


<div class="viewcode-block" id="yaml_data2pin_lists"><a class="viewcode-back" href="../../apidoc/hong2p.olf.html#hong2p.olf.yaml_data2pin_lists">[docs]</a><span class="k">def</span> <span class="nf">yaml_data2pin_lists</span><span class="p">(</span><span class="n">yaml_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pins used as balances can be part of these lists despite not having a corresponding</span>
<span class="sd">    odor in &#39;pins2odors&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;pins&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">yaml_data</span><span class="p">[</span><span class="s1">&#39;pin_sequence&#39;</span><span class="p">][</span><span class="s1">&#39;pin_groups&#39;</span><span class="p">]]</span></div>


<div class="viewcode-block" id="yaml_data2odor_lists"><a class="viewcode-back" href="../../apidoc/hong2p.olf.html#hong2p.olf.yaml_data2odor_lists">[docs]</a><span class="k">def</span> <span class="nf">yaml_data2odor_lists</span><span class="p">(</span><span class="n">yaml_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="c1"># TODO doctest example showing within-trial sorting</span>
    <span class="sd">&quot;&quot;&quot;Returns a list-of-lists of dictionary representation of odors.</span>

<span class="sd">    Each dictionary will have at least the key &#39;name&#39; and generally also &#39;log10_conc&#39;.</span>

<span class="sd">    The i-th list contains all of the odors presented simultaneously on the i-th odor</span>
<span class="sd">    presentation.</span>

<span class="sd">    Args:</span>
<span class="sd">        yaml_data (dict): parsed contents of stimulus YAML file</span>

<span class="sd">        sort (bool): (default=True) whether to, within each trial, sort odors.</span>
<span class="sd">            Irrelevant if there are is only ever a single odor presented on each trial.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pin_lists</span> <span class="o">=</span> <span class="n">yaml_data2pin_lists</span><span class="p">(</span><span class="n">yaml_data</span><span class="p">)</span>
    <span class="c1"># int pin -&gt; dict representing odor (keys &#39;name&#39;, &#39;log10_conc&#39;, etc)</span>
    <span class="n">pins2odors</span> <span class="o">=</span> <span class="n">yaml_data</span><span class="p">[</span><span class="s1">&#39;pins2odors&#39;</span><span class="p">]</span>

    <span class="n">odor_lists</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">pin_list</span> <span class="ow">in</span> <span class="n">pin_lists</span><span class="p">:</span>

        <span class="n">odor_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pin_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pins2odors</span><span class="p">:</span>
                <span class="n">odor_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pins2odors</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
            <span class="n">odor_list</span> <span class="o">=</span> <span class="n">sort_odor_list</span><span class="p">(</span><span class="n">odor_list</span><span class="p">)</span>

        <span class="n">odor_lists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">odor_list</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">odor_lists</span></div>


<span class="c1"># TODO may want to move to util</span>
<span class="c1"># TODO make a union type that also accepts pd.Series and np.ndarray in addition to</span>
<span class="c1"># Sequence? just trying to require that it can be sliced w/ arbitrary stride.</span>
<span class="c1"># TODO how to indicate that the Hashable in the argument and return type should be of</span>
<span class="c1"># the same type? does Hashable take any type of arguments? make my own ~mixin of</span>
<span class="c1"># Hashable + Generic(?)</span>
<div class="viewcode-block" id="remove_consecutive_repeats"><a class="viewcode-back" href="../../apidoc/hong2p.olf.html#hong2p.olf.remove_consecutive_repeats">[docs]</a><span class="k">def</span> <span class="nf">remove_consecutive_repeats</span><span class="p">(</span><span class="n">odor_lists</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Returns a list without any consecutive repeats and int # of consecutive repeats.</span>

<span class="sd">    Raises ValueError if there is a variable number of consecutive repeats.</span>

<span class="sd">    Wanted to also take a list-of-lists-of-dicts, where each dict represents one odor</span>
<span class="sd">    and each internal list represents all of the odors on one trial, but the internal</span>
<span class="sd">    lists (nor the dicts they contain) would not be hashable, and thus cannot work with</span>
<span class="sd">    Counter as-is.</span>

<span class="sd">    Assumed that all elements of `odor_lists` are repeated the same number of times,</span>
<span class="sd">    for each consecutive group of repeats. As long as any repeats are to full</span>
<span class="sd">    `n_repeats` and consecutive, it is ok for a particular odor (e.g. solvent control)</span>
<span class="sd">    to be repeated `n_repeats` times in each of several different positions.</span>

<span class="sd">    &gt;&gt;&gt; without_repeats, n = remove_consecutive_repeats([&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;b&#39;,&#39;b&#39;])</span>
<span class="sd">    &gt;&gt;&gt; without_repeats</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;]</span>
<span class="sd">    &gt;&gt;&gt; n</span>
<span class="sd">    3</span>

<span class="sd">    &gt;&gt;&gt; without_repeats, n = remove_consecutive_repeats([&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;b&#39;,&#39;a&#39;,&#39;a&#39;])</span>
<span class="sd">    &gt;&gt;&gt; without_repeats</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;]</span>
<span class="sd">    &gt;&gt;&gt; n</span>
<span class="sd">    2</span>

<span class="sd">    &gt;&gt;&gt; without_repeats, n = remove_consecutive_repeats([&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;b&#39;])</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ValueError: variable number of consecutive repeats</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># In Python 3.7+, order should be guaranteed to be equal to order first encountered</span>
    <span class="c1"># in odor_lists.</span>
    <span class="c1"># TODO modify to also allow counting non-hashable stuff (i.e.  dictionaries), so i</span>
    <span class="c1"># can pass my (list of) lists-of-dicts representation directly</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">odor_lists</span><span class="p">)</span>

    <span class="n">count_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">n_repeats</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">count_values</span><span class="p">)</span>
    <span class="n">without_consecutive_repeats</span> <span class="o">=</span> <span class="n">odor_lists</span><span class="p">[::</span><span class="n">n_repeats</span><span class="p">]</span>

    <span class="c1"># TODO possible to combine these two lines to one?</span>
    <span class="c1"># https://stackoverflow.com/questions/25674169</span>
    <span class="n">nested</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_repeats</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">without_consecutive_repeats</span><span class="p">]</span>
    <span class="n">flat</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">xs</span> <span class="ow">in</span> <span class="n">nested</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">flat</span> <span class="o">!=</span> <span class="n">odor_lists</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;variable number of consecutive repeats&#39;</span><span class="p">)</span>

    <span class="c1"># TODO add something like (&lt;n&gt;) to subsequent n_repeats occurence of the same odor</span>
    <span class="c1"># (e.g. solvent control) (OK without as long as we are prefixing filenames with</span>
    <span class="c1"># presentation index, but not-OK if we ever wanted to stop that)</span>

    <span class="k">return</span> <span class="n">without_consecutive_repeats</span><span class="p">,</span> <span class="n">n_repeats</span></div>


<div class="viewcode-block" id="format_odor"><a class="viewcode-back" href="../../apidoc/hong2p.olf.html#hong2p.olf.format_odor">[docs]</a><span class="k">def</span> <span class="nf">format_odor</span><span class="p">(</span><span class="n">odor_dict</span><span class="p">,</span> <span class="n">conc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name_conc_delim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conc_key</span><span class="o">=</span><span class="s1">&#39;log10_conc&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes a dict representation of an odor to a pretty str.</span>

<span class="sd">    Expected to have at least &#39;name&#39; key, but will also use &#39;log10_conc&#39; (or `conc_key`)</span>
<span class="sd">    if available, unless `conc=False`.</span>

<span class="sd">    &gt;&gt;&gt; odor = {&#39;name&#39;: &#39;ethyl acetate&#39;, &#39;log10_conc&#39;: -2}</span>
<span class="sd">    &gt;&gt;&gt; format_odor(odor)</span>
<span class="sd">    &#39;ethyl acetate @ -2&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">name_conc_delim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">name_conc_delim</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39; </span><span class="si">{conc_delimiter}</span><span class="s1"> &#39;</span>

    <span class="n">ostr</span> <span class="o">=</span> <span class="n">odor_dict</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">conc_key</span> <span class="ow">in</span> <span class="n">odor_dict</span><span class="p">:</span>
        <span class="c1"># TODO opt to choose between &#39;solvent&#39; and no string (w/ no delim below used?)?</span>
        <span class="c1"># what do i do in hong2p.util fn now?</span>
        <span class="k">if</span> <span class="n">odor_dict</span><span class="p">[</span><span class="n">conc_key</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">solvent_str</span>

        <span class="k">if</span> <span class="n">conc</span><span class="p">:</span>
            <span class="n">ostr</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{name_conc_delim}{odor_dict[conc_key]}</span><span class="s1">&#39;</span>

    <span class="k">return</span> <span class="n">ostr</span></div>


<span class="c1"># TODO TODO decorator or some other place to store minimum set of keys (and types?) for</span>
<span class="c1"># these formatting functions (at least those that take a Series as one option)?</span>
<span class="c1"># (so that hong2p.viz.callable_ticklabels can automatically convert / make good error</span>
<span class="c1"># messages if they are missing)</span>
<span class="c1"># TODO factor out this union type (+ probably add np.ndarray), and use in</span>
<span class="c1"># remove_consecutive_repeats as well (or maybe in this particular fn, i actually want</span>
<span class="c1"># Iterable[str] in the Union? not striding here..</span>
<div class="viewcode-block" id="format_mix_from_strs"><a class="viewcode-back" href="../../apidoc/hong2p.olf.html#hong2p.olf.format_mix_from_strs">[docs]</a><span class="k">def</span> <span class="nf">format_mix_from_strs</span><span class="p">(</span><span class="n">odor_strs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">],</span>
    <span class="n">delim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">odor_strs</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
        <span class="n">odor_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">odor_strs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">is_odor_var</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">odor_keys</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">odor_strs</span><span class="p">):</span>
            <span class="n">nonodor_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">odor_strs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">odor_keys</span><span class="p">]</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;format_mix_from_strs: ignoring levels not starting with &#39;</span>
                <span class="n">f</span><span class="s2">&quot;&#39;odor&#39; (</span><span class="si">{nonodor_keys}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>

        <span class="n">odor_strs</span> <span class="o">=</span> <span class="p">[</span><span class="n">odor_strs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">odor_keys</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">delim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">delim</span> <span class="o">=</span> <span class="s1">&#39; + &#39;</span>

    <span class="n">odor_strs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">odor_strs</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">solvent_str</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">odor_strs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">delim</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">odor_strs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">solvent_str</span></div>


<div class="viewcode-block" id="format_odor_list"><a class="viewcode-back" href="../../apidoc/hong2p.olf.html#hong2p.olf.format_odor_list">[docs]</a><span class="k">def</span> <span class="nf">format_odor_list</span><span class="p">(</span><span class="n">odor_list</span><span class="p">,</span> <span class="n">delim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes list of dicts representing odors for one trial to pretty str.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">odor_strs</span> <span class="o">=</span> <span class="p">[</span><span class="n">format_odor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">odor_list</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">format_mix_from_strs</span><span class="p">(</span><span class="n">odor_strs</span><span class="p">,</span> <span class="n">delim</span><span class="o">=</span><span class="n">delim</span><span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Tom O&#39;Connell.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
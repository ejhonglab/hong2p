

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>hong2p.roi &mdash; hong2p 0.0.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> hong2p
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../apidoc/modules.html">hong2p</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">hong2p</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>hong2p.roi</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for hong2p.roi</h1><div class="highlight"><pre>
<span></span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">join</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">exists</span><span class="p">,</span> <span class="n">getmtime</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span>
<span class="c1"># TODO replace w/ logging.warning</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">zipfile</span> <span class="kn">import</span> <span class="n">BadZipFile</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">make_axes_locatable</span>

<span class="c1"># This must be my fork at https://github.com/tom-f-oconnell/ijroi</span>
<span class="kn">import</span> <span class="nn">ijroi</span>
<span class="kn">from</span> <span class="nn">hong2p</span> <span class="kn">import</span> <span class="n">thor</span><span class="p">,</span> <span class="n">util</span><span class="p">,</span> <span class="n">viz</span>
<span class="c1"># TODO make (/find) an Arraylike (to include NumpyOrXArray as well as Series/DataFrame)?</span>
<span class="c1"># TODO want one that excludes Series (but how to also exclude 1D numpy arrays? so prob</span>
<span class="c1"># not)</span>
<span class="kn">from</span> <span class="nn">hong2p.types</span> <span class="kn">import</span> <span class="n">Pathlike</span><span class="p">,</span> <span class="n">NumpyOrXArray</span>


<span class="c1"># TODO TODO switch order of args, and allow passing just coords. if just coords are</span>
<span class="c1"># passed, shift all towards 0 (+ margin). use for e.g. xpix/ypix stats elements in</span>
<span class="c1"># suite2p stat output. corresponding pixel weights in lam output would not need to be</span>
<span class="c1"># modified.</span>
<div class="viewcode-block" id="crop_to_coord_bbox"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.crop_to_coord_bbox">[docs]</a><span class="k">def</span> <span class="nf">crop_to_coord_bbox</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns matrix cropped to bbox of coords and bounds.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">x_min</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">y_min</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> \
        <span class="sa">f</span><span class="s1">&#39;mins must be &gt;= 0 (x_min=</span><span class="si">{</span><span class="n">x_min</span><span class="si">}</span><span class="s1">, y_min=</span><span class="si">{</span><span class="n">y_min</span><span class="si">}</span><span class="s1">)&#39;</span>

    <span class="c1"># NOTE: apparently i had to use &lt;= or else some cases in old use of this function</span>
    <span class="c1"># (e.g. using certain CNMF outputs) would violate this. best to just fix that code</span>
    <span class="c1"># if it ever comes up again though.</span>
    <span class="k">assert</span> <span class="n">x_max</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">y_max</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s1">&#39;maxes must be &lt; matrix shape = </span><span class="si">{</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1"> (x_max=</span><span class="si">{</span><span class="n">x_max</span><span class="si">}</span><span class="s1">&#39;</span> <span class="o">+</span>
        <span class="sa">f</span><span class="s1">&#39;, y_max=</span><span class="si">{</span><span class="n">y_max</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="p">)</span>

    <span class="c1"># Keeping min at 0 to prevent slicing error in that case</span>
    <span class="c1"># (I think it will be empty, w/ -1:2, for instance)</span>
    <span class="c1"># Capping max not necessary to prevent err, but to make behavior of bounds</span>
    <span class="c1"># consistent on both edges.</span>
    <span class="c1"># TODO flag to err if margin would take it past edge? / warn?</span>
    <span class="n">x_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_min</span> <span class="o">-</span> <span class="n">margin</span><span class="p">)</span>
    <span class="n">y_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y_min</span> <span class="o">-</span> <span class="n">margin</span><span class="p">)</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x_max</span> <span class="o">+</span> <span class="n">margin</span><span class="p">,</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">y_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">y_max</span> <span class="o">+</span> <span class="n">margin</span><span class="p">,</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">cropped</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">x_min</span><span class="p">:</span><span class="n">x_max</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y_min</span><span class="p">:</span><span class="n">y_max</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">cropped</span><span class="p">,</span> <span class="p">((</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">),</span> <span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">))</span></div>


<div class="viewcode-block" id="crop_to_nonzero"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.crop_to_nonzero">[docs]</a><span class="k">def</span> <span class="nf">crop_to_nonzero</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a matrix just large enough to contain the non-zero elements of the</span>
<span class="sd">    input, and the bounding box coordinates to embed this matrix in a matrix</span>
<span class="sd">    with indices from (0,0) to the max coordinates in the input matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># nan_to_num will replace nan w/ 0 by default. infinities also converted but not</span>
    <span class="c1"># expected to be in input.</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">crop_to_coord_bbox</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="n">margin</span><span class="p">)</span></div>


<span class="c1"># TODO delete (and other stuff no longer used)</span>
<span class="c1"># TODO if these &#39;db_row2*&#39; fns are really just db related, move to db.py, but</span>
<span class="c1"># probably just rename...</span>
<span class="c1"># TODO better name?</span>
<div class="viewcode-block" id="db_row2footprint"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.db_row2footprint">[docs]</a><span class="k">def</span> <span class="nf">db_row2footprint</span><span class="p">(</span><span class="n">db_row</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns dense array w/ footprint from row in cells table.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">coo_matrix</span>
    <span class="n">weights</span><span class="p">,</span> <span class="n">x_coords</span><span class="p">,</span> <span class="n">y_coords</span> <span class="o">=</span> <span class="n">db_row</span><span class="p">[[</span><span class="s1">&#39;weights&#39;</span><span class="p">,</span><span class="s1">&#39;x_coords&#39;</span><span class="p">,</span><span class="s1">&#39;y_coords&#39;</span><span class="p">]]</span>
    <span class="c1"># TODO maybe read shape from db / metadata on disk? / merging w/ other</span>
    <span class="c1"># tables (possible?)?</span>
    <span class="n">footprint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">weights</span><span class="p">,</span> <span class="p">(</span><span class="n">x_coords</span><span class="p">,</span> <span class="n">y_coords</span><span class="p">)),</span>
        <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">todense</span><span class="p">())</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">footprint</span></div>


<span class="c1"># TODO delete (and other stuff no longer used)</span>
<div class="viewcode-block" id="db_footprints2array"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.db_footprints2array">[docs]</a><span class="k">def</span> <span class="nf">db_footprints2array</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns footprints in an array of dims (shape + (n_footprints,)).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">db_row2footprint</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()],</span>
        <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span></div>


<span class="c1"># TODO maybe refactor so there is a function does this for single arrays, then concat</span>
<span class="c1"># using xarray functions in here? or if i still want both functions, how to dedupe code?</span>
<span class="c1"># allow this to accept single rois too (without that component of shape)?</span>
<span class="c1"># TODO type hint for roi_indices</span>
<div class="viewcode-block" id="numpy2xarray_rois"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.numpy2xarray_rois">[docs]</a><span class="k">def</span> <span class="nf">numpy2xarray_rois</span><span class="p">(</span><span class="n">rois</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">roi_indices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
    <span class="c1"># TODO doc what keys of roi_indices should be (/ delete).</span>
    <span class="c1"># currently only used by hong2p.suite2p.suite2p_stat2rois</span>
    <span class="sd">&quot;&quot;&quot;Takes numpy array of shape ([z,]y,x,roi) to labelled xarray.</span>

<span class="sd">    Args:</span>
<span class="sd">        roi_indices (None | dict): values must be iterables of length equal to number of</span>
<span class="sd">            ROIs. &#39;roi_num&#39; will be included as an additional ROI index regardless.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">rois</span><span class="o">.</span><span class="n">shape</span>
    <span class="c1"># TODO check that the fact that i swapped y and x now didn&#39;t break how i was using</span>
    <span class="c1"># this w/ actual ijrois / anything else. wanted to be more consistent w/ how</span>
    <span class="c1"># suite2p, ImageJ, etc seemed to do things.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;roi&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;roi&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;shape must have length 3 or 4&#39;</span><span class="p">)</span>

    <span class="c1"># NOTE: &#39;roi_num&#39; can&#39;t be replaced w/ &#39;roi&#39; b/c conflict w/ name of &#39;roi&#39; dim</span>
    <span class="n">roi_num_name</span> <span class="o">=</span> <span class="s1">&#39;roi_num&#39;</span>
    <span class="n">roi_index_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">roi_num_name</span><span class="p">]</span>
    <span class="n">roi_index_levels</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">rois</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>

    <span class="k">if</span> <span class="n">roi_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

        <span class="c1"># TODO delete. not useful as is (ijroi_masks subsets output of this fn, before</span>
        <span class="c1"># calling code uses it for integer based indexing)</span>
        <span class="c1">#</span>
        <span class="c1"># Want to be able to rely on roi_num always being [0, len - 1] (in order)</span>
        <span class="c1"># (so we can use numpy/iloc/isel indexing in some places)</span>
        <span class="k">assert</span> <span class="n">roi_num_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">roi_indices</span>

        <span class="n">n_rois</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">ns</span><span class="p">,</span> <span class="n">xs</span> <span class="ow">in</span> <span class="n">roi_indices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_rois</span>
            <span class="n">roi_index_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span>
            <span class="n">roi_index_levels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>

    <span class="n">roi_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">roi_index_levels</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">roi_index_names</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">rois</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;roi&#39;</span><span class="p">:</span> <span class="n">roi_index</span><span class="p">})</span></div>


<span class="c1"># TODO doc + test</span>
<span class="c1"># TODO complete? check against imagej internal code?</span>
<div class="viewcode-block" id="is_ijroi_name_default"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.is_ijroi_name_default">[docs]</a><span class="k">def</span> <span class="nf">is_ijroi_name_default</span><span class="p">(</span><span class="n">roi</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>

    <span class="n">parts</span> <span class="o">=</span> <span class="n">roi</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="kc">True</span></div>


<span class="c1"># TODO doc + test</span>
<div class="viewcode-block" id="is_ijroi_named"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.is_ijroi_named">[docs]</a><span class="k">def</span> <span class="nf">is_ijroi_named</span><span class="p">(</span><span class="n">roi</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">int</span><span class="p">(</span><span class="n">roi</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">is_ijroi_name_default</span><span class="p">(</span><span class="n">roi</span><span class="p">)</span></div>


<div class="viewcode-block" id="is_ijroi_plane_outline"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.is_ijroi_plane_outline">[docs]</a><span class="k">def</span> <span class="nf">is_ijroi_plane_outline</span><span class="p">(</span><span class="n">roi</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns ROI name indicates it&#39;s an outline of a whole structure (e.g. the AL)</span>

<span class="sd">    There will typically be exactly one of these per plane, when used. Sub-ROIs (e.g.</span>
<span class="sd">    glomeruli) should be contained within this larger region.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO also support sam&#39;s &#39;plane&lt;x&gt;&#39; syntax?</span>
    <span class="k">return</span> <span class="n">roi</span> <span class="o">==</span> <span class="s1">&#39;AL&#39;</span></div>


<span class="c1"># TODO drop support for &#39;/&#39; (and maybe also &#39;|&#39;?)</span>
<span class="n">ijroi_uncertainty_chars</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="s1">&#39;|&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">)</span>
<span class="c1"># TODO doc + test</span>
<div class="viewcode-block" id="is_ijroi_certain"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.is_ijroi_certain">[docs]</a><span class="k">def</span> <span class="nf">is_ijroi_certain</span><span class="p">(</span><span class="n">roi</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns whether an ROI is named indicating it&#39;s ID is certain.</span>

<span class="sd">    False for names that are default, integers, or include one of</span>
<span class="sd">    `ijroi_uncertainty_chars` (e.g. &#39;?&#39;), and True otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Won&#39;t contain any of the characters indicating uncertainty if it&#39;s just a number.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_ijroi_named</span><span class="p">(</span><span class="n">roi</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">roi</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ijroi_uncertainty_chars</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="ijroi_name_as_if_certain"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.ijroi_name_as_if_certain">[docs]</a><span class="k">def</span> <span class="nf">ijroi_name_as_if_certain</span><span class="p">(</span><span class="n">roi_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="c1"># TODO or raise ValueError instead of returning None?</span>
    <span class="sd">&quot;&quot;&quot;Removes characters indicating uncertainty, to group ROIs by best guess at ID</span>

<span class="sd">    &#39;VM3&#39; -&gt; &#39;VM3&#39;</span>
<span class="sd">    &#39;VM3?&#39; -&gt; &#39;VM3&#39;</span>
<span class="sd">    &#39;VM3+?&#39; -&gt; &#39;VM3&#39;</span>
<span class="sd">    &#39;VM2|VM3?&#39; -&gt; None</span>
<span class="sd">    &#39;VM2+VM3?&#39; -&gt; None</span>

<span class="sd">    Any time ijroi_uncertainty_chars split remainder of name into more than one part,</span>
<span class="sd">    None is returned (ambiguous which name it should refer to).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># the regex below would work without stripping these first (as long as we remove the</span>
    <span class="c1"># final &#39;&#39; string if there was a suffix), but by handling these first we shouldn&#39;t</span>
    <span class="c1"># need to handle empty strings in split output (don&#39;t want to support names that</span>
    <span class="c1"># would have them anywhere besides end either)</span>
    <span class="n">allowed_suffix_chars</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">)</span>
    <span class="n">without_uncertainty_suffix</span> <span class="o">=</span> <span class="n">roi_name</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">allowed_suffix_chars</span><span class="p">))</span>

    <span class="n">pattern</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ijroi_uncertainty_chars</span><span class="p">])</span><span class="si">}</span><span class="s2">]+&quot;</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">without_uncertainty_suffix</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">roi_name</span><span class="si">=}</span><span class="s1"> had nothing besides </span><span class="si">{</span><span class="n">ijroi_uncertainty_chars</span><span class="si">=}</span><span class="s1">&#39;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="ijroi_comparable_via_name"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.ijroi_comparable_via_name">[docs]</a><span class="k">def</span> <span class="nf">ijroi_comparable_via_name</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns whether input refers to only a single ROI name</span>
<span class="sd">    (&#39;VM3?&#39; and &#39;VM3&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">is_ijroi_certain</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_ijroi_named</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># TODO is this where i want this? just drop anything with &#39;+&#39; in it</span>
    <span class="c1"># (in other stuff in here that currently does &#39;+&#39; suffix dropping)?</span>
    <span class="c1">#</span>
    <span class="c1"># will currently deal with stuff like: &#39;VM2+&#39;, &#39;VM2+?&#39;, &#39;VM2+VM3&#39;</span>
    <span class="k">if</span> <span class="s1">&#39;+&#39;</span> <span class="ow">in</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="c1">#</span>

    <span class="c1"># &#39;VM2|VM3&#39;, &#39;VM2+VM3&#39;, etc will have None for this, as there are</span>
    <span class="c1"># multiple names it could be (not sure which to compare to, or whether</span>
    <span class="c1"># signal is just one)</span>
    <span class="n">as_if_certain</span> <span class="o">=</span> <span class="n">ijroi_name_as_if_certain</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">as_if_certain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="kc">True</span></div>


<span class="c1"># TODO also test on w/ non-MultiIndex &#39;roi&#39; columns?</span>
<span class="c1"># TODO adapt to also work w/ DataArray input (at least w/ &#39;roi_name&#39; level, but maybe</span>
<span class="c1"># also &#39;roi&#39; (or &#39;name&#39;, on &#39;roi&#39; dimension?))</span>
<div class="viewcode-block" id="certain_roi_indices"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.certain_roi_indices">[docs]</a><span class="k">def</span> <span class="nf">certain_roi_indices</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns boolean mask of certain ROIs, for DataFrame with &#39;roi&#39; column level</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO some reason i&#39;m not using Index.map? do i specifically want the numpy array</span>
    <span class="c1"># type for some reason?</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">is_ijroi_certain</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s1">&#39;roi&#39;</span><span class="p">)])</span></div>


<span class="c1"># TODO TODO adapt to also work w/ DataArray input</span>
<div class="viewcode-block" id="select_certain_rois"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.select_certain_rois">[docs]</a><span class="k">def</span> <span class="nf">select_certain_rois</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns input subset with certain ROI labels, for input with &#39;roi&#39; column level</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">certain_roi_indices</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="c1"># no need to copy, because indexing with a bool mask always does</span>
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">mask</span><span class="p">]</span></div>


<span class="c1"># TODO TODO rename / delete one-or-the-other of this and contour2mask etc</span>
<span class="c1"># (+ accept ijroi[set] filename or something if actually gonna call it this)</span>
<span class="c1"># (ALSO include ijrois2masks in consideration for refactoring. this fn might not be</span>
<span class="c1"># necessary)</span>
<div class="viewcode-block" id="ijroi2mask"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.ijroi2mask">[docs]</a><span class="k">def</span> <span class="nf">ijroi2mask</span><span class="p">(</span><span class="n">roi</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        z: z-index ROI was drawn on</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This mask creation was taken from Yusuke N.&#39;s answer here:</span>
    <span class="c1"># https://stackoverflow.com/questions/3654289</span>
    <span class="kn">from</span> <span class="nn">matplotlib.path</span> <span class="kn">import</span> <span class="n">Path</span>

    <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;len(shape) == </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="s1">. must be 2 if z keyword &#39;</span>
                <span class="s1">&#39;argument not passed&#39;</span>
            <span class="p">)</span>

        <span class="c1"># TODO check transpose isn&#39;t necessary...</span>
        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">shape</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;shape must be (z, x, y) if z is passed. shape == </span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="s1">&#39;, which has the wrong length&#39;</span>
            <span class="p">)</span>

        <span class="c1"># TODO check transpose (of x and y) isn&#39;t necessary...</span>
        <span class="n">nz</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="k">if</span> <span class="n">z</span> <span class="o">&gt;=</span> <span class="n">nz</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z (</span><span class="si">{</span><span class="n">z</span><span class="si">}</span><span class="s1">) out of bounds with z size (</span><span class="si">{</span><span class="n">nz</span><span class="si">}</span><span class="s1">) from shape[0]&#39;</span><span class="p">)</span>

    <span class="c1"># TODO test + delete</span>
    <span class="c1">#assert nx == ny, &#39;need to check code shoulnt be tranposing these&#39;</span>
    <span class="c1">#</span>

    <span class="c1"># Create vertex coordinates for each grid cell...</span>
    <span class="c1"># (&lt;0,0&gt; is at the top left of the grid in this system)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ny</span><span class="p">))</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

    <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">roi</span><span class="p">)</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">contains_points</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="c1"># Transpose makes this correct in testing on some of YZ&#39;s data</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mask</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vol_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
        <span class="n">vol_mask</span><span class="p">[</span><span class="n">z</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="k">return</span> <span class="n">vol_mask</span></div>


<span class="c1"># TODO TODO add option to translate ijroi labels to pandas index values?</span>
<span class="c1"># (and check trace extraction downstream preserves those!)</span>
<span class="c1"># TODO TODO TODO document type / structure expecations of inputs/outputs</span>
<span class="c1"># TODO TODO accept either the input or output of ijroi.read_roi[_zip] for ijrois?</span>
<span class="c1"># read_roi takes file object and read_roi_zip takes filename</span>
<span class="c1"># TODO can ijroi lib be modified to read path to tif things were drawn over (is that</span>
<span class="c1"># data there?), and can that be used to get shape? or can i also accept a path to tiff</span>
<span class="c1"># / thorimage dir / etc for that?</span>
<span class="c1"># TODO TODO option to use one of those scipy sparse arrays for the masks instead?</span>
<span class="c1"># TODO TODO maybe update all of my roi stuff that currently has the roi index as the</span>
<span class="c1"># last index so that it is the first index instead? feels more intuitive...</span>
<span class="c1"># TODO TODO make as_xarray default behavior and remove if other places that use this</span>
<span class="c1"># output don&#39;t break / change them</span>
<span class="c1"># TODO TODO TODO fn to convert suite2p representation of masks to the same [xarray]</span>
<span class="c1"># representation of masks this spits out</span>
<span class="c1">#</span>
<span class="c1"># TODO do try to make it faster. think it&#39;s probably a big part of why al_analysis.py is</span>
<span class="c1"># slow to recompute ijroi stuff. less of an issue from plot_roi.py now though, since</span>
<span class="c1"># only calculating for particular roi index now.</span>
<span class="c1"># ~25% of time in ijroi2mask calls, and ~75% of time in np.stack(masks, ...) call</span>
<span class="c1"># (would require `from line_profiler import profile` (pip install line-profiler)</span>
<span class="c1">#@profile</span>
<div class="viewcode-block" id="ijrois2masks"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.ijrois2masks">[docs]</a><span class="k">def</span> <span class="nf">ijrois2masks</span><span class="p">(</span><span class="n">ijrois</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">as_xarray</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># TODO type hint alias for ndarray|DataArray?</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]:</span>
    <span class="c1"># TODO be clear on where shape is coming from (just shape of the data in the TIFF</span>
    <span class="c1"># the ROIs were draw in, right?)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transforms ROIs loaded from my ijroi fork to an array full of boolean masks,</span>
<span class="sd">    of dimensions (shape + (n_rois,)).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">ijroi</span>

    <span class="c1"># TODO delete depending on how refactoring the below into xarray fn goes / whether</span>
    <span class="c1"># the non-xarray parts of this fn have the same requirements (which they probably</span>
    <span class="c1"># do...)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;shape must have length 2 or 3&#39;</span><span class="p">)</span>

    <span class="n">masks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">roi_z_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">prefixes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">suffixes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">roi</span> <span class="ow">in</span> <span class="n">ijrois</span><span class="p">:</span>
        <span class="n">z_index</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># Otherwise, it should simply be a numpy array with points.</span>
            <span class="c1"># `points_only=False` to either `read_roi_zip` or `read_roi` should produce</span>
            <span class="c1"># input suitable for this branch.</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">roi</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">z_index</span> <span class="o">=</span> <span class="n">roi</span><span class="o">.</span><span class="n">z</span>

            <span class="c1"># ROI was drawn on an image w/ only 3 dimensions (assuming the non-XY one</span>
            <span class="c1"># was Z)</span>
            <span class="k">elif</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">roi</span><span class="p">,</span> <span class="s1">&#39;position&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">z_index</span> <span class="o">=</span> <span class="n">roi</span><span class="o">.</span><span class="n">position</span>

            <span class="k">if</span> <span class="n">z_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># This should be the same as the `name` this shadows, just without the</span>
                <span class="c1"># &#39;.roi&#39; suffix.</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">roi</span><span class="o">.</span><span class="n">name</span>

                <span class="c1"># TODO eventually delete everything that uses parse_z_from_name.</span>
                <span class="c1"># is there any old code that depends on it?</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">_</span><span class="p">,</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">suffix</span><span class="p">)</span> <span class="o">=</span> <span class="n">ijroi</span><span class="o">.</span><span class="n">parse_z_from_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span>
                        <span class="n">return_unmatched</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">prefix</span> <span class="o">=</span> <span class="n">name</span>
                    <span class="n">suffix</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;trying to parse Z from ROI name. pass points_only=False&#39;</span>
                    <span class="s1">&#39; to ijroi loading function to read Z directly.&#39;</span>
                <span class="p">)</span>
                <span class="n">z_index</span><span class="p">,</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">suffix</span><span class="p">)</span> <span class="o">=</span> <span class="n">ijroi</span><span class="o">.</span><span class="n">parse_z_from_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">return_unmatched</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>

            <span class="c1"># TODO assert z_index in range of corresponding element of shape?</span>

        <span class="n">points</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">roi</span><span class="p">,</span> <span class="s1">&#39;points&#39;</span><span class="p">,</span> <span class="n">roi</span><span class="p">)</span>

        <span class="c1"># TODO may also need to reverse part of shape here, if really was</span>
        <span class="c1"># necessary above (test would probably need to be in asymmetric</span>
        <span class="c1"># case...)</span>
        <span class="n">masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ijroi2mask</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z_index</span><span class="p">))</span>
        <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">roi_z_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z_index</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">suffix</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">suffix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="n">prefixes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
            <span class="n">suffixes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">suffix</span><span class="p">)</span>

    <span class="c1"># This concatenates along the last element of the new shape</span>
    <span class="n">masks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">as_xarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">masks</span>

    <span class="n">roi_index_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;roi_name&#39;</span><span class="p">]</span>
    <span class="n">roi_index_levels</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">roi_index_names</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;roi_z&#39;</span><span class="p">,</span> <span class="s1">&#39;ijroi_prefix&#39;</span><span class="p">,</span> <span class="s1">&#39;ijroi_suffix&#39;</span><span class="p">]</span>
        <span class="n">roi_index_levels</span> <span class="o">+=</span> <span class="p">[</span><span class="n">roi_z_indices</span><span class="p">,</span> <span class="n">prefixes</span><span class="p">,</span> <span class="n">suffixes</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">numpy2xarray_rois</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span>
        <span class="n">roi_indices</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">roi_index_names</span><span class="p">,</span> <span class="n">roi_index_levels</span><span class="p">))</span>
    <span class="p">)</span></div>


<span class="c1"># TODO maybe add a fn to plot single xarray masks for debugging?</span>
<span class="c1"># TODO TODO change `on` default to something like `roi`</span>
<div class="viewcode-block" id="merge_rois"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.merge_rois">[docs]</a><span class="k">def</span> <span class="nf">merge_rois</span><span class="p">(</span><span class="n">rois</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;ijroi_prefix&#39;</span><span class="p">,</span> <span class="n">merge_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">check_no_overlap</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        rois (xarray.DataArray): must have at least dims &#39;x&#39;, &#39;y&#39;, and &#39;roi&#39;.</span>
<span class="sd">            &#39;roi&#39; should be indexed by a MultiIndex and one of the levels should have</span>
<span class="sd">            the name of the `on` argument. Currently expect the dtype to be &#39;bool&#39;.</span>

<span class="sd">        on (str): name of other ROI metadata dimension to merge on</span>

<span class="sd">        label_fn (callable): function mapping the values of the `on` column to labels</span>
<span class="sd">            for the ROIs. Only ROIs created via merging will be given these labels,</span>
<span class="sd">            while unmerged ROIs will recieve unique number labels. Defaults to the</span>
<span class="sd">            identity function.</span>

<span class="sd">        check_no_overlap (bool): (optional, default=False) If True, checks that no</span>
<span class="sd">            merged rois shared any pixels before being merged. If merged ROIs are all</span>
<span class="sd">            on different planes, this should be True because ImageJ ROIs are defined on</span>
<span class="sd">            single planes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO assert bool before this / rename to something like &#39;total_weight&#39; that would</span>
    <span class="c1"># apply in non-boolean-mask case too</span>
    <span class="n">total_weight_before</span> <span class="o">=</span> <span class="n">rois</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="n">n_rois_before</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rois</span><span class="o">.</span><span class="n">roi</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_nonroi_shape</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">n</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s1">&#39;roi&#39;</span><span class="p">}</span>

    <span class="n">nonroi_shape_before</span> <span class="o">=</span> <span class="n">get_nonroi_shape</span><span class="p">(</span><span class="n">rois</span><span class="p">)</span>

    <span class="c1"># TODO maybe i should use sum instead, if i&#39;m not going to make the aggregation</span>
    <span class="c1"># function configurable?</span>
    <span class="c1"># If `on` contains NaN values, the groupby will not include groups for the NaN</span>
    <span class="c1"># values, and there is no argument to configure this (as in pandas). Therefore,</span>
    <span class="c1"># we need to drop things that were merged and then add these to what remains.</span>
    <span class="c1"># TODO do i need to check that nothing else conflicts w/ what i plan on renaming</span>
    <span class="c1"># `on` to (&#39;roi&#39;)?</span>
    <span class="k">if</span> <span class="n">merge_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="n">rois</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">on</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#raise NotImplementedError</span>
        <span class="c1"># TODO maybe try reduce? might need other inputs tho...</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="n">rois</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">on</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">merge_fn</span><span class="p">)</span>

    <span class="c1"># TODO some kind of inplace version of this? or does xarray not really do that?</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="n">on</span><span class="p">:</span> <span class="s1">&#39;roi&#39;</span><span class="p">})</span>

    <span class="k">if</span> <span class="n">label_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">label_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>

    <span class="n">merged_roi_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">label_fn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">merged</span><span class="o">.</span><span class="n">roi</span><span class="o">.</span><span class="n">values</span><span class="p">]</span>
    <span class="c1"># Trying to pass label_fn here instead of calling before didn&#39;t work b/c it seems to</span>
    <span class="c1"># expect a fn that takes a DataArray (and it&#39;s not passing scalar DataArrays either)</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">roi</span><span class="o">=</span><span class="n">merged_roi_labels</span><span class="p">)</span>

    <span class="n">not_merged</span> <span class="o">=</span> <span class="n">rois</span><span class="p">[</span><span class="n">on</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span>
    <span class="n">unmerged</span> <span class="o">=</span> <span class="n">rois</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">not_merged</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="s1">&#39;roi&#39;</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">n_orig_rois_merged</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span> <span class="n">not_merged</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">n_rois_after</span> <span class="o">=</span> <span class="n">n_rois_before</span> <span class="o">-</span> <span class="n">n_orig_rois_merged</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">merged</span><span class="o">.</span><span class="n">roi</span><span class="p">)</span>

    <span class="n">available_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_rois_after</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">merged_roi_labels</span><span class="p">]</span>
    <span class="n">unmerged_roi_labels</span> <span class="o">=</span> <span class="n">available_labels</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">unmerged</span><span class="o">.</span><span class="n">roi</span><span class="p">)]</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">unmerged_roi_labels</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">unmerged</span><span class="o">.</span><span class="n">roi</span><span class="p">)</span>
    <span class="n">unmerged</span> <span class="o">=</span> <span class="n">unmerged</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">roi</span><span class="o">=</span><span class="n">unmerged_roi_labels</span><span class="p">)</span>

    <span class="c1"># The .groupby (seemingly with any function application, as .first() also does it)</span>
    <span class="c1"># and .where both change the dtype to float64 from bool</span>
    <span class="n">was_bool</span> <span class="o">=</span> <span class="n">rois</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;bool&#39;</span>

    <span class="n">rois</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">merged</span><span class="p">,</span> <span class="n">unmerged</span><span class="p">],</span> <span class="s1">&#39;roi&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">was_bool</span><span class="p">:</span>
        <span class="n">rois</span> <span class="o">=</span> <span class="n">rois</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">n_rois_after</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">rois</span><span class="o">.</span><span class="n">roi</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">rois</span><span class="o">.</span><span class="n">roi</span><span class="o">.</span><span class="n">values</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">rois</span><span class="o">.</span><span class="n">roi</span><span class="p">)</span>

    <span class="n">total_weight_after</span> <span class="o">=</span> <span class="n">rois</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">check_no_overlap</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">total_weight_before</span> <span class="o">==</span> <span class="n">total_weight_after</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">total_weight_before</span> <span class="o">&gt;=</span> <span class="n">total_weight_after</span>

    <span class="n">nonroi_shape_after</span> <span class="o">=</span> <span class="n">get_nonroi_shape</span><span class="p">(</span><span class="n">rois</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">nonroi_shape_before</span> <span class="o">==</span> <span class="n">nonroi_shape_after</span>

    <span class="k">return</span> <span class="n">rois</span></div>


<div class="viewcode-block" id="merge_ijroi_masks"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.merge_ijroi_masks">[docs]</a><span class="k">def</span> <span class="nf">merge_ijroi_masks</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        masks (xarray.DataArray): must have at least dims &#39;x&#39;, &#39;y&#39;, and &#39;roi&#39;.</span>
<span class="sd">            &#39;roi&#39; should be indexed by a MultiIndex and one of the levels should have</span>
<span class="sd">            the name of the `on` argument. Currently expect the dtype to be &#39;bool&#39;.</span>

<span class="sd">        label_fn (callable): function mapping the values of the `on` column to labels</span>
<span class="sd">            for the ROIs. Only ROIs created via merging will be given these labels,</span>
<span class="sd">            while unmerged ROIs will recieve unique number labels. Defaults to a</span>
<span class="sd">            function that takes strings, removes trailing/leading underscores, and</span>
<span class="sd">            parses an int from what remains.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO probably assert bool</span>
    <span class="c1"># TODO assert ijroi_prefix in here / accept kwarg on (defaulting to same), and</span>
    <span class="c1"># assert that&#39;s here</span>

    <span class="k">return</span> <span class="n">merge_rois</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;ijroi_prefix&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="c1"># TODO TODO TODO make another function that groups rois based on spatial overlap</span>
<span class="c1"># (params to include [variable-number-of?] dilation steps, fraction of pixels[/weight?]</span>
<span class="c1"># that need to overlap, and correlation of responses required) -&gt; generate appropriate</span>
<span class="c1"># input to [refactored + renamed] merge_ijroi_masks fn below, particularly the `masks`</span>
<span class="c1"># and `on` arguments, and have label_fn be identity</span>

<span class="c1"># TODO TODO how to handle a correlation threshold? pass correlations of some kind in</span>
<span class="c1"># or something to compute them from (probably the former, or make the correlation</span>
<span class="c1"># thresholding a separate step)?</span>
<div class="viewcode-block" id="merge_single_plane_rois"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.merge_single_plane_rois">[docs]</a><span class="k">def</span> <span class="nf">merge_single_plane_rois</span><span class="p">(</span><span class="n">rois</span><span class="p">,</span> <span class="n">min_overlap_frac</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">n_dilations</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For handling single plane ROIs that are on adjacent Z planes, and correspond to the</span>
<span class="sd">    same biological feature. This is to merge the single plane ROIs that suite2p</span>
<span class="sd">    outputs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="kn">import</span> <span class="nn">ipdb</span><span class="p">;</span> <span class="n">ipdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span></div>


<span class="c1"># TODO TODO refactor this + hong2p.suite2p.remerge_suite2p_merged to share core code</span>
<span class="c1"># here! (this initially copied from other fn and then adapted)</span>
<span class="c1"># TODO unit test! (include 2023-04-26/3 ROIs, where some also have &#39;+&#39; in name, that</span>
<span class="c1"># ijroi_masks is currently dropping)</span>
<span class="c1"># TODO change verbose default to False</span>
<div class="viewcode-block" id="rois2best_planes_only"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.rois2best_planes_only">[docs]</a><span class="k">def</span> <span class="nf">rois2best_planes_only</span><span class="p">(</span><span class="n">rois</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">roi_quality</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Currently assumes input only has non-zero values in a single plane for a given</span>
<span class="sd">    unique combination of ROI identifier variables.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO modify calling code to pass roi_quality in w/ compatible metadata to rois,</span>
    <span class="c1"># and try to replace these w/ assertions that metadata is compatible</span>
    <span class="k">assert</span> <span class="n">rois</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s1">&#39;roi&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">roi_quality</span><span class="p">)</span>
    <span class="c1"># (as calling code is currently only gauranteeing that shapes are the same, so</span>
    <span class="c1"># diff index might cause problems...)</span>
    <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">roi_quality</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">roi_quality</span><span class="p">)))</span>

    <span class="c1"># TODO delete all this if i can replace roi_index w/ isel / similar</span>
    <span class="n">roi_quality</span> <span class="o">=</span> <span class="n">roi_quality</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">roi_quality</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;roi_index&#39;</span>
    <span class="c1"># TODO remove this from index if i&#39;m going to return other metadata?</span>
    <span class="c1"># (and if i don&#39;t manage to replace this code w/ isel/similar)</span>
    <span class="n">rois</span> <span class="o">=</span> <span class="n">rois</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="s1">&#39;roi_index&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;roi&#39;</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">rois</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s1">&#39;roi&#39;</span><span class="p">]))})</span>

    <span class="n">input_roi_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">rois</span><span class="o">.</span><span class="n">roi_name</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="n">roi_quality</span> <span class="o">=</span> <span class="n">roi_quality</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;roi_quality&#39;</span><span class="p">)</span>

    <span class="c1"># TODO better name</span>
    <span class="n">mo_key</span> <span class="o">=</span> <span class="s1">&#39;name&#39;</span>
    <span class="n">roi_quality</span><span class="p">[</span><span class="n">mo_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">rois</span><span class="o">.</span><span class="n">roi_name</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

    <span class="c1"># TODO dropna=False? or at least assert no null in it then...</span>
    <span class="n">gb</span> <span class="o">=</span> <span class="n">roi_quality</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">mo_key</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># TODO implement another strategy where as long as the roi_quality are within some</span>
    <span class="c1"># tolerance of the best, they are averaged? or weighted according to response stat?</span>
    <span class="c1"># weight according to variance of response stat (see examples of weighted averages</span>
    <span class="c1"># using something derived from variance for weights online)</span>
    <span class="c1"># TODO maybe also use 2/3rd highest lowest frame / percentile rather than actual min</span>
    <span class="c1"># / max (for picking &#39;best&#39; plane), to gaurd against spiking noise</span>

    <span class="c1"># TODO rename?</span>
    <span class="n">best_inputs</span> <span class="o">=</span> <span class="n">gb</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()</span>

    <span class="c1"># Selecting the only column this DataFrame has (i.e. shape (n, 1))</span>
    <span class="c1"># TODO assertion on shape before this (and maybe values / dtype?)</span>
    <span class="c1"># TODO rename this and/or `best` below</span>
    <span class="n">best_inputs</span> <span class="o">=</span> <span class="n">best_inputs</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="n">best</span> <span class="o">=</span> <span class="n">roi_quality</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">best_inputs</span><span class="p">]</span>

    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">best</span><span class="o">.</span><span class="n">roi_quality</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">gb</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">roi_quality</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">by_response</span> <span class="o">=</span> <span class="n">roi_quality</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">swaplevel</span><span class="p">()</span>

    <span class="n">notbest_to_drop</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">best</span><span class="o">.</span><span class="n">itertuples</span><span class="p">():</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">name</span>
        <span class="n">curr_best</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">Index</span>

        <span class="n">curr_notbest</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rois</span><span class="o">.</span><span class="n">roi</span><span class="p">[</span>
            <span class="p">(</span><span class="n">rois</span><span class="o">.</span><span class="n">roi_name</span> <span class="o">==</span> <span class="n">name</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">rois</span><span class="o">.</span><span class="n">roi_index</span> <span class="o">!=</span> <span class="n">curr_best</span><span class="p">)</span>
        <span class="p">]</span><span class="o">.</span><span class="n">roi_index</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="n">notbest_to_drop</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">curr_notbest</span><span class="p">)</span>

        <span class="c1"># only print if multiple inputs (i.e. actually &#39;merging&#39; in some sense)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_notbest</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;merging ROI </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;selecting input ROI </span><span class="si">{</span><span class="n">curr_best</span><span class="si">}</span><span class="s1"> as best plane&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;dropping other input ROIs </span><span class="si">{</span><span class="n">curr_notbest</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">by_response</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">()</span>

    <span class="n">rois</span> <span class="o">=</span> <span class="n">rois</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">roi</span><span class="o">=</span> <span class="o">~</span> <span class="n">rois</span><span class="o">.</span><span class="n">roi_index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">notbest_to_drop</span><span class="p">))</span>

    <span class="c1"># TODO delete eventually (just getting metadata of subset of `rois` returned, and</span>
    <span class="c1"># indexing using that in the future)</span>
    <span class="n">roi_indices</span> <span class="o">=</span> <span class="n">rois</span><span class="o">.</span><span class="n">roi_index</span><span class="o">.</span><span class="n">values</span>

    <span class="n">output_roi_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">rois</span><span class="o">.</span><span class="n">roi_name</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">input_roi_names</span> <span class="o">==</span> <span class="n">output_roi_names</span>
    <span class="c1"># If input and ouput name sets are equal, this should imply no duplicated ROI names</span>
    <span class="c1"># in output.</span>
    <span class="k">assert</span> <span class="n">rois</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s1">&#39;roi&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_roi_names</span><span class="p">)</span>

    <span class="c1"># TODO TODO TODO remove need for this (so we can keep metadata in output, at least</span>
    <span class="c1"># by default)</span>
    <span class="c1"># TODO should i also include roi_z? would want to also do / use in s2p case for</span>
    <span class="c1"># consistency... also, how to modify this call to accomplish that?</span>
    <span class="n">rois</span> <span class="o">=</span> <span class="n">rois</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">roi</span><span class="o">=</span><span class="n">rois</span><span class="o">.</span><span class="n">roi_name</span><span class="p">)</span>

    <span class="c1"># TODO TODO if i can figure out how to keep multiple levels for the roi dimension,</span>
    <span class="c1"># do that rather than return multiple things</span>
    <span class="k">return</span> <span class="n">roi_indices</span><span class="p">,</span> <span class="n">rois</span></div>


<span class="n">ijroiset_default_basename</span> <span class="o">=</span> <span class="s1">&#39;RoiSet.zip&#39;</span>

<div class="viewcode-block" id="ijroi_filename"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.ijroi_filename">[docs]</a><span class="k">def</span> <span class="nf">ijroi_filename</span><span class="p">(</span><span class="n">ijroiset_dir_or_fname</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">,</span> <span class="n">must_exist</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>

    <span class="n">ijroiset_dir_or_fname</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">ijroiset_dir_or_fname</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ijroiset_dir_or_fname</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>
        <span class="c1"># TODO if i standardize path to analysis intermediates, update this to look for</span>
        <span class="c1"># RoiSet.zip there?</span>
        <span class="n">ijroiset_fname</span> <span class="o">=</span> <span class="n">ijroiset_dir_or_fname</span> <span class="o">/</span> <span class="n">ijroiset_default_basename</span>

        <span class="k">if</span> <span class="n">must_exist</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ijroiset_fname</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;directory passed for ijroiset_dir_or_fname, but &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">ijroiset_fname</span><span class="si">}</span><span class="s1"> did not exist&#39;</span>
            <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># TODO check it&#39;s actually loadable?</span>
        <span class="n">ijroiset_fname</span> <span class="o">=</span> <span class="n">ijroiset_dir_or_fname</span>

    <span class="k">return</span> <span class="n">ijroiset_fname</span></div>


<div class="viewcode-block" id="has_ijrois"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.has_ijrois">[docs]</a><span class="k">def</span> <span class="nf">has_ijrois</span><span class="p">(</span><span class="n">ijroiset_dir_or_fname</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="c1"># NOTE: not actually checking it contains any</span>
    <span class="n">ijroiset_fname</span> <span class="o">=</span> <span class="n">ijroi_filename</span><span class="p">(</span><span class="n">ijroiset_dir_or_fname</span><span class="p">,</span> <span class="n">must_exist</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ijroiset_fname</span><span class="o">.</span><span class="n">is_file</span><span class="p">()</span></div>


<div class="viewcode-block" id="ijroi_mtime"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.ijroi_mtime">[docs]</a><span class="k">def</span> <span class="nf">ijroi_mtime</span><span class="p">(</span><span class="n">ijroiset_dir_or_fname</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;RoiSet.zip (/directory with one) path to Unix timestamp modification time</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ijroiset_fname</span> <span class="o">=</span> <span class="n">ijroi_filename</span><span class="p">(</span><span class="n">ijroiset_dir_or_fname</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">getmtime</span><span class="p">(</span><span class="n">ijroiset_fname</span><span class="p">)</span></div>


<span class="c1"># TODO maybe delete drop_maximal_extent_rois and move code that drops them to a separate</span>
<span class="c1"># call (or set default to False?)? initially broke some stuff in al_analysis.py and</span>
<span class="c1"># later seemingly plot_roi.py, which expected to be able to index ROI list consistently</span>
<span class="c1"># TODO rename *_maximal_extent_rois -&gt; *_nonseparated_rois? something else?</span>
<span class="c1"># want to indicate the signal may be a mixture from multiple glomeruli (/ biological</span>
<span class="c1"># regions)</span>
<span class="c1">#</span>
<span class="c1"># 95% of the time this fn took was from ijrois2masks</span>
<div class="viewcode-block" id="ijroi_masks"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.ijroi_masks">[docs]</a><span class="k">def</span> <span class="nf">ijroi_masks</span><span class="p">(</span><span class="n">ijroiset_dir_or_fname</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">,</span> <span class="n">thorimage_dir</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">,</span>
    <span class="n">as_xarray</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">drop_maximal_extent_rois</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NumpyOrXArray</span><span class="p">:</span>

    <span class="n">ijroiset_fname</span> <span class="o">=</span> <span class="n">ijroi_filename</span><span class="p">(</span><span class="n">ijroiset_dir_or_fname</span><span class="p">)</span>

    <span class="c1"># TODO format better + put behind verbose flag (/delete)</span>
    <span class="c1">#print(f&#39;{ijroiset_fname=}&#39;)</span>
    <span class="c1">#print(f&#39;{ijroiset_fname.resolve()=}&#39;)</span>

    <span class="c1"># TODO maybe just fix ijroi.read_roi_zip to work in case input is a single lone .roi</span>
    <span class="c1"># file?</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">name_and_roi_list</span> <span class="o">=</span> <span class="n">ijroi</span><span class="o">.</span><span class="n">read_roi_zip</span><span class="p">(</span><span class="n">ijroiset_fname</span><span class="p">,</span> <span class="n">points_only</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">except</span> <span class="n">BadZipFile</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;does </span><span class="si">{</span><span class="n">ijroiset_fname</span><span class="si">}</span><span class="s1"> only have a single ROI? try adding &gt;1, &#39;</span>
            <span class="s1">&#39;so that ImageJ saves ROIs as a zipfile (or deselect ROIs before any manual&#39;</span>
            <span class="s1">&#39; saving)&#39;</span>
        <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="n">_</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">z</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span>  <span class="n">thor</span><span class="o">.</span><span class="n">load_thorimage_metadata</span><span class="p">(</span><span class="n">thorimage_dir</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;not tested in case x != y&#39;</span>

    <span class="c1"># From what `thor.read_movie` says the output dimensions are (except the first</span>
    <span class="c1"># dimension, which is time).</span>
    <span class="k">if</span> <span class="n">z</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">movie_shape_without_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">movie_shape_without_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="c1"># since current mask calculation is seems to have some slow steps, and we don&#39;t need</span>
    <span class="c1"># to compute all of them when calling from plot_roi[_util].py</span>
    <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">name_and_roi_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">name_and_roi_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>

    <span class="n">masks</span> <span class="o">=</span> <span class="n">ijrois2masks</span><span class="p">(</span><span class="n">name_and_roi_list</span><span class="p">,</span> <span class="n">movie_shape_without_time</span><span class="p">,</span>
        <span class="n">as_xarray</span><span class="o">=</span><span class="n">as_xarray</span>
    <span class="p">)</span>

    <span class="c1"># 2023-04-26/3 currently is one of just a few flies w/ ROIs using the optional &#39;+&#39;</span>
    <span class="c1"># suffix syntax (to indicate the same ROI name w/o the suffix is contained by the</span>
    <span class="c1"># suffixed ROI, which might also have more contamination from external signals)</span>
    <span class="c1">#</span>
    <span class="c1"># TODO TODO assert that for each of these, we have ROIs w/ name matching the</span>
    <span class="c1"># non-&#39;+&#39;-suffixed name (we might not tho... could be impossible to get a clean ROI</span>
    <span class="c1"># for some glomeruli)?</span>
    <span class="c1"># TODO put dropping of these behind flag?</span>
    <span class="k">if</span> <span class="n">drop_maximal_extent_rois</span><span class="p">:</span>
        <span class="c1"># TODO TODO just check if &#39;+&#39; is in roi name? or want to still handle diff if</span>
        <span class="c1"># there is a &#39;?&#39; suffix? kinda want to support e.g. &#39;DM2+DM5&#39; tho</span>
        <span class="c1"># TODO TODO TODO also handle &#39;+?&#39; suffix? warn / assert it isn&#39;t there?</span>
        <span class="n">maximal_extent_rois</span> <span class="o">=</span> <span class="n">masks</span><span class="o">.</span><span class="n">roi_name</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>
        <span class="n">n_maximal_to_drop</span> <span class="o">=</span> <span class="n">maximal_extent_rois</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_maximal_to_drop</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># TODO convert to logging.warnings?</span>
            <span class="c1"># TODO better message (indicating what they are)?</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dropping </span><span class="si">{</span><span class="n">n_maximal_to_drop</span><span class="si">}</span><span class="s2"> ROIs with &#39;+&#39; suffix&quot;</span><span class="p">)</span>

            <span class="n">n_rois_before</span> <span class="o">=</span> <span class="n">masks</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s1">&#39;roi&#39;</span><span class="p">]</span>

            <span class="n">masks</span> <span class="o">=</span> <span class="n">masks</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">roi</span><span class="o">=~</span><span class="n">maximal_extent_rois</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">assert</span> <span class="n">masks</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s1">&#39;roi&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">n_rois_before</span> <span class="o">-</span> <span class="n">n_maximal_to_drop</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">masks</span></div>

    <span class="c1">## TODO modify check_no_overlap to make sure it&#39;s also erring if two things that</span>
    <span class="c1">## would be merged (by having same name / whatever) are not in the same z-plane</span>
    <span class="c1">## (assuming the intention was to have one per plane, to make a single volumetric</span>
    <span class="c1">## ROI)</span>
    <span class="c1">#merged = merge_ijroi_masks(masks, check_no_overlap=True)</span>
    <span class="c1">#</span>
    <span class="c1">#import ipdb; ipdb.set_trace()</span>
    <span class="c1">#</span>
    <span class="c1">#return merged</span>


<span class="c1"># TODO test / document requirements for type / properties of contour. it&#39;s just a</span>
<span class="c1"># numpy array of points, right? doesn&#39;t need start = end or anything, does it?</span>
<div class="viewcode-block" id="contour2mask"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.contour2mask">[docs]</a><span class="k">def</span> <span class="nf">contour2mask</span><span class="p">(</span><span class="n">contour</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a boolean mask True inside contour and False outside.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO TODO TODO appropriate checking of contour input. i.e. any requirements on</span>
    <span class="c1"># first/last point / order (do some orders imply overlapping edge segments, and if</span>
    <span class="c1"># so, check there are none of those)</span>
    <span class="kn">import</span> <span class="nn">cv2</span>
    <span class="c1"># TODO any checking of contour necessary for it to be well behaved in</span>
    <span class="c1"># opencv?</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

    <span class="c1"># NOTE: at some point i think i needed convexHull in ijroi2mask to get that + this</span>
    <span class="c1"># to work as I expected. AS I THINK CONVEXHULL MIGHT RESULT IN SOME UNEXPECTED</span>
    <span class="c1"># MODIFICATIONS TO CONTOURS, i need to change that code, and that might break some</span>
    <span class="c1"># of this code too</span>
    <span class="c1"># TODO TODO TODO if drawContours truly does need convex hull inputs, need to change</span>
    <span class="c1"># this function to no longer use drawContours</span>
    <span class="c1"># TODO TODO TODO see strategy i recommended to yang recently and consider using it</span>
    <span class="c1"># here instead</span>
    <span class="c1"># TODO draw into a sparse array maybe? or convert after?</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">drawContours</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="p">[</span><span class="n">contour</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># TODO TODO TODO investigate need for this transpose</span>
    <span class="c1"># (imagej contour repr specific? maybe load to contours w/ dims swapped them</span>
    <span class="c1"># call this fn w/o transpose?)</span>
    <span class="c1"># (was it somehow still a product of x_coords / y_coords being swapped in</span>
    <span class="c1"># db?)</span>
    <span class="c1"># not just b/c reshaping to something expecting F order CNMF stuff?</span>
    <span class="c1"># didn&#39;t correct time averaging w/in roi also require this?</span>
    <span class="k">return</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span></div>


<span class="c1"># TODO delete (/ rename &quot;py&quot; to &quot;cnmf&quot; or something)</span>
<div class="viewcode-block" id="py2imagej_coords"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.py2imagej_coords">[docs]</a><span class="k">def</span> <span class="nf">py2imagej_coords</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Since ijroi source seems to have Y as first coord and X as second.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO TODO TODO probably just delete any code that actually relied on this?</span>
    <span class="c1"># assuming it doesn&#39;t still make sense...</span>
    <span class="c1">#return array.T</span>
    <span class="k">return</span> <span class="n">array</span></div>


<span class="c1"># TODO maybe move to a submodule for interfacing w/ cnmf?</span>
<span class="c1"># TODO TODO probably make a corresponding fn to do the inverse</span>
<span class="c1"># (or is one of these not necessary? in one dir, is order=&#39;C&#39; and order</span>
<div class="viewcode-block" id="footprints_to_flat_cnmf_dims"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.footprints_to_flat_cnmf_dims">[docs]</a><span class="k">def</span> <span class="nf">footprints_to_flat_cnmf_dims</span><span class="p">(</span><span class="n">footprints</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes array of (x, y[, z], n_footprints) to (n_pixels, n_footprints).</span>

<span class="sd">    There is more than one way this reshaping can be done, and this produces</span>
<span class="sd">    output as CNMF expects it.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">frame_pixels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">footprints</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">n_footprints</span> <span class="o">=</span> <span class="n">footprints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># TODO TODO is this supposed to be order=&#39;F&#39; or order=&#39;C&#39; matter?</span>
    <span class="c1"># wrong setting equivalent to transpose?</span>
    <span class="c1"># what&#39;s the appropriate test (make unit?)?</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">footprints</span><span class="p">,</span> <span class="p">(</span><span class="n">frame_pixels</span><span class="p">,</span> <span class="n">n_footprints</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span></div>


<span class="c1"># TODO type hint arraylike</span>
<span class="c1">#</span>
<span class="c1"># 90% of time was from the np.mean line</span>
<div class="viewcode-block" id="extract_traces_bool_masks"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.extract_traces_bool_masks">[docs]</a><span class="k">def</span> <span class="nf">extract_traces_bool_masks</span><span class="p">(</span><span class="n">movie</span><span class="p">,</span> <span class="n">footprints</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Averages the movie within each boolean mask in footprints</span>
<span class="sd">    to make a matrix of traces (n_frames x n_footprints).</span>

<span class="sd">    Args:</span>
<span class="sd">        movie: should be of shape (T, [Z,] Y, X).</span>
<span class="sd">        footprints: should be of shape ([Z,] Y, X, #-ROIs)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># need to support either of these? probably not</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">movie</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">footprints</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>

    <span class="c1"># TODO TODO what would i need to change below to support float masks tho?</span>
    <span class="c1"># (like the suite2p ones, where they seem to be non-negative, but each not</span>
    <span class="c1"># necessarily summing to the same value [typically ~1-15 or so, from a quick look])</span>
    <span class="k">assert</span> <span class="n">footprints</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;float footprints are not boolean&#39;</span>
    <span class="k">assert</span> <span class="n">footprints</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;footprints not boolean&#39;</span>
    <span class="k">assert</span> <span class="n">footprints</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;footprints not boolean&#39;</span>
    <span class="c1">#</span>
    <span class="n">n_spatial_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">footprints</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">spatial_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_spatial_dims</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">footprints</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">spatial_dims</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s1">&#39;some zero footprints&#39;</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="n">n_spatial_dims</span>
    <span class="n">n_frames</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n_footprints</span> <span class="o">=</span> <span class="n">footprints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">traces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_frames</span><span class="p">,</span> <span class="n">n_footprints</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;extracting traces from boolean masks...&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># TODO vectorized way to do this?</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_footprints</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">footprints</span><span class="p">[</span><span class="n">slices</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="p">,)]</span>
        <span class="c1"># TODO compare time of this to sparse matrix dot product?</span>
        <span class="c1"># + time of MaskedArray-&gt;mean w/ mask expanded by n_frames?</span>

        <span class="c1"># axis=1 because movie[:, mask] only has two dims (frames x pixels)</span>
        <span class="n">trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">movie</span><span class="p">[:,</span> <span class="n">mask</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_frames</span>
        <span class="n">traces</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">trace</span>

    <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">traces</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; done&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">traces</span></div>


<span class="c1"># TODO try to make extract_traces_bool_masks (only fn that had been used for a long</span>
<span class="c1"># time) a reference to this fn (want to keep former name active so yang doesn&#39;t need to</span>
<span class="c1"># change any code). need to test behavior same.</span>
<span class="c1">#</span>
<span class="c1"># TODO TODO delete _sum= kwarg after using to test suite2p stuff? or actually want that</span>
<span class="c1"># behavior?</span>
<span class="c1"># TODO TODO TODO actually, no. it is required to match s2p output, w/ normalized</span>
<span class="c1"># footprints. it should be the new default behavior, at least after input is normalized</span>
<span class="c1"># or checked to be normalized.</span>
<div class="viewcode-block" id="extract_traces"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.extract_traces">[docs]</a><span class="k">def</span> <span class="nf">extract_traces</span><span class="p">(</span><span class="n">movie</span><span class="p">,</span> <span class="n">footprints</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">_sum</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Averages the movie within each mask in footprints</span>
<span class="sd">    to make a matrix of traces (n_frames x n_footprints).</span>

<span class="sd">    Args:</span>
<span class="sd">        movie: should be of shape (T, [Z,] Y, X).</span>
<span class="sd">        footprints: should be of shape ([Z,] Y, X, #-ROIs)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># need to support either of these? probably not</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">movie</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">footprints</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>

    <span class="k">assert</span> <span class="n">footprints</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="n">n_spatial_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">footprints</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">mask_spatial_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_spatial_dims</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">footprints</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">mask_spatial_dims</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s1">&#39;some zero footprints&#39;</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="n">n_spatial_dims</span>
    <span class="n">n_frames</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n_footprints</span> <span class="o">=</span> <span class="n">footprints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">traces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_frames</span><span class="p">,</span> <span class="n">n_footprints</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># first movie dim is time, everything else should be a spatial dim</span>
    <span class="n">movie_spatial_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">movie</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">before_s</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;extracting traces from masks...&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># TODO vectorized way to do this?</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_footprints</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">footprints</span><span class="p">[</span><span class="n">slices</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="p">,)]</span>

        <span class="c1"># TODO delete / move to test</span>
        <span class="c1"># bmask = mask &gt; 0</span>
        <span class="c1"># ipdb&gt; np.array_equal(movie[:, bmask] * mask[bmask], (movie*mask)[:,bmask])</span>
        <span class="c1"># True</span>
        <span class="c1">#</span>
        <span class="c1"># ipdb&gt; (movie*mask)[:,bmask].shape</span>
        <span class="c1"># (9076, 27)</span>
        <span class="c1">#</span>
        <span class="c1"># ipdb&gt; (movie*mask).shape</span>
        <span class="c1"># (9076, 256, 256)</span>

        <span class="c1"># TODO TODO use sum instead of mean? suite2p docs seemed to suggest that, but</span>
        <span class="c1"># not sure it makes sense. may not matter, apart from preserving old behavior of</span>
        <span class="c1"># bool fn?</span>
        <span class="c1"># TODO delete _sum=True branch if doesn&#39;t actually make more sense on suite2p</span>
        <span class="c1"># outputs?</span>
        <span class="k">if</span> <span class="n">_sum</span><span class="p">:</span>
            <span class="n">trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">movie</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">movie_spatial_dims</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO TODO test this against my bool one, at least for input to this fn</span>
            <span class="c1"># that is boolean</span>
            <span class="n">trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">movie</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">movie_spatial_dims</span><span class="p">)</span>

        <span class="c1"># TODO TODO try np.average w/ weights= either normalized or not mask?</span>
        <span class="c1"># any advantage? output the same (as either of above branches, for suite2p</span>
        <span class="c1"># mask inputs)?</span>
        <span class="c1">#</span>
        <span class="c1"># np.average&#39;s calculation is: avg = sum(a * weights) / sum(weights)</span>
        <span class="c1">#import ipdb; ipdb.set_trace()</span>
        <span class="c1"># TODO TODO or .dot, like s2p seems to do? see notes in</span>
        <span class="c1"># al_analysis/scripts/recompute_traces...</span>

        <span class="c1"># TODO actually yea can this be made any faster (e.g. by using list of sparse</span>
        <span class="c1"># array inputs? scipy sparse arrays are only 2d, hence it couldn&#39;t just be 1)</span>
        <span class="c1"># TODO try something like the `@njit(parallel=True) suite2p seems to use for</span>
        <span class="c1"># this?</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_frames</span>
        <span class="n">traces</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">trace</span>

    <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">traces</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">extract_time_s</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">before_s</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; done (</span><span class="si">{</span><span class="n">extract_time_s</span><span class="si">:</span><span class="s1">.1f</span><span class="si">}</span><span class="s1">s)&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">traces</span></div>


<span class="c1"># TODO what were these files for again? still want to use? delete?</span>
<div class="viewcode-block" id="autoroi_metadata_filename"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.autoroi_metadata_filename">[docs]</a><span class="k">def</span> <span class="nf">autoroi_metadata_filename</span><span class="p">(</span><span class="n">ijroi_file</span><span class="p">):</span>
    <span class="n">path</span><span class="p">,</span> <span class="n">fname</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">ijroi_file</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;.</span><span class="si">{}</span><span class="s1">.meta.p&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span></div>


<div class="viewcode-block" id="template_match"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.template_match">[docs]</a><span class="k">def</span> <span class="nf">template_match</span><span class="p">(</span><span class="n">scene</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">method_str</span><span class="o">=</span><span class="s1">&#39;cv2.TM_CCOEFF&#39;</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="kn">import</span> <span class="nn">cv2</span>

    <span class="n">vscaled_scene</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">baselined_normed_u8</span><span class="p">(</span><span class="n">scene</span><span class="p">)</span>
    <span class="c1"># TODO TODO maybe template should only be scaled to it&#39;s usual fraction of</span>
    <span class="c1"># max of the scene? like scaled both wrt orig_scene.max() / max across all</span>
    <span class="c1"># images?</span>
    <span class="n">vscaled_template</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">baselined_normed_u8</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="c1"># To check how much conversion to u8 (necessary for cv2 template</span>
        <span class="c1"># matching) has reduced the number of pixel levels.</span>
        <span class="n">scene_levels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">scene</span><span class="o">.</span><span class="n">flat</span><span class="p">))</span>
        <span class="n">vs_scene_levels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">vscaled_scene</span><span class="o">.</span><span class="n">flat</span><span class="p">))</span>
        <span class="n">template_levels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">flat</span><span class="p">))</span>
        <span class="n">vs_template_levels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">vscaled_template</span><span class="o">.</span><span class="n">flat</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of scene levels BEFORE scaling: </span><span class="si">{</span><span class="n">scene_levels</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of scene levels AFTER scaling: </span><span class="si">{</span><span class="n">vs_scene_levels</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of template levels BEFORE scaling: </span><span class="si">{</span><span class="n">template_levels</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of template levels AFTER scaling: </span><span class="si">{</span><span class="n">vs_template_levels</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># So you can see that the relative dimensions and scales of each of</span>
        <span class="c1"># these seems reasonable.</span>
        <span class="k">def</span> <span class="nf">compare_template_and_scene</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">scene</span><span class="p">,</span> <span class="n">suptitle</span><span class="p">,</span>
            <span class="n">same_scale</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

            <span class="n">smin</span> <span class="o">=</span> <span class="n">scene</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">smax</span> <span class="o">=</span> <span class="n">scene</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">tmin</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">tmax</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="si">{</span><span class="n">suptitle</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;scene shape:&#39;</span><span class="p">,</span> <span class="n">scene</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;template shape:&#39;</span><span class="p">,</span> <span class="n">template</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;scene min:&#39;</span><span class="p">,</span> <span class="n">smin</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;scene max:&#39;</span><span class="p">,</span> <span class="n">smax</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;template min:&#39;</span><span class="p">,</span> <span class="n">tmin</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;template max:&#39;</span><span class="p">,</span> <span class="n">tmax</span><span class="p">)</span>

            <span class="c1"># Default, for this fig at least seemed to be (6.4, 4.8)</span>
            <span class="c1"># This has the same aspect ratio.</span>
            <span class="n">fh</span> <span class="o">=</span> <span class="mi">10</span>
            <span class="n">fw</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">fh</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">ncols</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">fw</span><span class="p">,</span> <span class="n">fh</span><span class="p">))</span>

            <span class="n">xlim</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">scene</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">template</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ylim</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">scene</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">template</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">same_scale</span><span class="p">:</span>
                <span class="n">vmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">smin</span><span class="p">,</span> <span class="n">tmin</span><span class="p">)</span>
                <span class="n">vmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">smax</span><span class="p">,</span> <span class="n">tmax</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vmin</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">vmax</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sim</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">scene</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;scene&#39;</span><span class="p">)</span>

            <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">tim</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;template (real scale)&#39;</span><span class="p">)</span>

            <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">btim</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;template (blown up)&#39;</span><span class="p">)</span>

            <span class="c1"># https://stackoverflow.com/questions/31006971</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">axs</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="n">xlim</span><span class="p">,</span> <span class="n">ylim</span><span class="o">=</span><span class="n">ylim</span><span class="p">)</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">template</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">template</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

            <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">suptitle</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">same_scale</span><span class="p">:</span>
                <span class="c1"># l, b, w, h</span>
                <span class="n">cax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.85</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">])</span>
                <span class="n">cb</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
                <span class="n">cb</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">&#39;shared&#39;</span><span class="p">)</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">right</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># l, b, w, h</span>
                <span class="n">cax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.025</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">])</span>
                <span class="n">cb1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax1</span><span class="p">)</span>
                <span class="n">cb1</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">&#39;scene&#39;</span><span class="p">)</span>

                <span class="n">cax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.85</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.025</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">])</span>
                <span class="n">cb2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">tim</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax2</span><span class="p">)</span>
                <span class="n">cb2</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">&#39;template&#39;</span><span class="p">)</span>

                <span class="n">fig</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">right</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

            <span class="n">bins</span> <span class="o">=</span> <span class="mi">50</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">same_scale</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">shistvs</span><span class="p">,</span> <span class="n">sbins</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">scene</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;scene&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency (a.u.)&#39;</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">thitvs</span><span class="p">,</span> <span class="n">tbins</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;template&#39;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">suptitle</span><span class="si">}</span><span class="se">\n</span><span class="s1">pixel value distributions (</span><span class="si">{</span><span class="n">bins</span><span class="si">}</span><span class="s1"> bins)&#39;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">top</span><span class="o">=</span><span class="mf">0.85</span><span class="p">)</span>

        <span class="n">compare_template_and_scene</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">scene</span><span class="p">,</span> <span class="s1">&#39;original&#39;</span><span class="p">,</span>
            <span class="n">same_scale</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">compare_template_and_scene</span><span class="p">(</span><span class="n">vscaled_template</span><span class="p">,</span> <span class="n">vscaled_scene</span><span class="p">,</span>
            <span class="s1">&#39;baselined + scaled&#39;</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">method</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">method_str</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">matchTemplate</span><span class="p">(</span><span class="n">vscaled_scene</span><span class="p">,</span> <span class="n">vscaled_template</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

    <span class="c1"># b/c for sqdiff[_normed], find minima. for others, maxima.</span>
    <span class="k">if</span> <span class="s1">&#39;SQDIFF&#39;</span> <span class="ow">in</span> <span class="n">method_str</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">if</span> <span class="n">hist</span><span class="p">:</span>
        <span class="n">fh</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Matching output values (</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method_str</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">res</span></div>


<span class="c1"># TODO TODO TODO try updating to take max of two diff match images,</span>
<span class="c1"># created w/ different template scales (try a smaller one + existing),</span>
<span class="c1"># and pack appropriate size at each maxima.</span>
<span class="c1"># TODO make sure match criteria is comparable across scales (one threshold</span>
<span class="c1"># ideally) (possible? using one of normalized metrics sufficient? test this</span>
<span class="c1"># on fake test data?)</span>
<div class="viewcode-block" id="greedy_roi_packing"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.greedy_roi_packing">[docs]</a><span class="k">def</span> <span class="nf">greedy_roi_packing</span><span class="p">(</span><span class="n">match_images</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">radii_px</span><span class="p">,</span> <span class="n">thresholds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">exclusion_radius_frac</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">min_dist2neighbor_px</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">min_neighbors</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">exclusion_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">draw_on</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">draw_bboxes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">draw_circles</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">draw_nums</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">multiscale_strategy</span><span class="o">=</span><span class="s1">&#39;one_order&#39;</span><span class="p">,</span> <span class="n">match_value_weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">radii_px_ps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">subpixel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">_src_img_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">_show_match_images</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">_show_packing_constraints</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">_show_fit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">_initial_single_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">    match_images (np.ndarray / iterable of same): 2-dimensional array of match</span>
<span class="sd">    value higher means better match of that point to template.</span>

<span class="sd">        Shape is determined by the number of possible offsets of the template in</span>
<span class="sd">        the original image, so it is smaller than the original image in each</span>
<span class="sd">        dimension. As an example, for a 3x3 image and a 2x2 template, the</span>
<span class="sd">        template can occupy 4 possible positions in the 3x3 image, and the match</span>
<span class="sd">        image will be 2x2.</span>

<span class="sd">    ds (int / iterable of same): integer width (and height) of square template.</span>
<span class="sd">        related to radius, but differ by margin set outside.</span>

<span class="sd">    radii_px (int / iterable of same): radius of cell in pixels.</span>

<span class="sd">    exclusion_radius_frac (float): approximately 1 - the fraction of two ROI</span>
<span class="sd">        radii that are allowed to overlap.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO move drawing fns for debug to mpl and remove this if not gonna</span>
    <span class="c1"># use for constraints here</span>
    <span class="kn">import</span> <span class="nn">cv2</span>
    <span class="c1">#</span>
    <span class="c1"># Use of either this or KDTree seem to cause pytest ufunc size changed</span>
    <span class="c1"># warning (w/ pytest at least), though it should be harmless.</span>
    <span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">cKDTree</span>

    <span class="k">if</span> <span class="n">subpixel</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">if</span> <span class="n">thresholds</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;specify either thresholds or ns&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">ns</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">thresholds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span>
            <span class="p">(</span><span class="n">ns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">thresholds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;only specify either thresholds or ns&#39;</span><span class="p">)</span>

    <span class="c1"># For multiscale matching, we require (at lesat) multiple radii, so we test</span>
    <span class="c1"># whether it is iterable to determine if we should be using multiscale</span>
    <span class="c1"># matching.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">iter</span><span class="p">(</span><span class="n">radii_px</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">radii_px</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">multiscale</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ds</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">radii_px</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">radii_px</span><span class="p">)</span>
            <span class="n">multiscale</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">multiscale</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># also check most other things are NOT iterable in this case?</span>

        <span class="n">match_images</span> <span class="o">=</span> <span class="p">[</span><span class="n">match_images</span><span class="p">]</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="p">[</span><span class="n">ds</span><span class="p">]</span>
        <span class="n">radii_px</span> <span class="o">=</span> <span class="p">[</span><span class="n">radii_px</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">ns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">total_n</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># TODO maybe delete this test and force thresholds (if-specified)</span>
        <span class="c1"># to have same length. useless if one threshold is never gonna work.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">thresholds</span><span class="p">)</span>
            <span class="c1"># If we have multiple thresholds, we must have as many</span>
            <span class="c1"># as the things above.</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">thresholds</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">radii_px</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">thresholds</span> <span class="o">=</span> <span class="p">[</span><span class="n">thresholds</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">radii_px</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">thresholds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span>
            <span class="c1"># TODO want this behavior ever? maybe delete try/except...</span>
            <span class="c1"># Here, we are specify how many of each size we are looking for.</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">radii_px</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">total_n</span> <span class="o">=</span> <span class="n">ns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ns</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">total_n</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># Here, we specify a target number of cells of any size to find.</span>
            <span class="n">total_n</span> <span class="o">=</span> <span class="n">ns</span>
            <span class="n">ns</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">multiscale</span><span class="p">:</span>
        <span class="n">n_scales</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">radii_px</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_images</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_scales</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_scales</span>

        <span class="k">if</span> <span class="n">multiscale_strategy</span> <span class="o">!=</span> <span class="s1">&#39;one_order&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">match_value_weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;match_value_weights are only &#39;</span>
                <span class="s2">&quot;meaningful in multiscale_strategy=&#39;one_order&#39; case, because &quot;</span>
                <span class="s1">&#39;they do not change match ordering within a single match scale.&#39;</span>
                <span class="s1">&#39; They only help make one ordering across matching scales.&#39;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">multiscale_strategy</span> <span class="o">!=</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">radii_px_ps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;radii_px_ps is only meaningful in &#39;</span>
                <span class="s2">&quot;multiscale_strategy=&#39;random&#39; case&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">multiscale_strategy</span> <span class="o">!=</span> <span class="s1">&#39;fixed_scale_order&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">scale_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;scale_order is only meaningful in &#39;</span>
                <span class="s2">&quot;multiscale_strategy=&#39;fixed_scale_order&#39; case&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">multiscale_strategy</span> <span class="o">==</span> <span class="s1">&#39;one_order&#39;</span><span class="p">:</span>
            <span class="c1"># Can still be None here, that just implies that match values</span>
            <span class="c1"># at different scales will be sorted into one order with no</span>
            <span class="c1"># weighting.</span>
            <span class="k">if</span> <span class="n">match_value_weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_value_weights</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_scales</span>

            <span class="c1"># could also accept callable for each element, if a fn (rather than</span>
            <span class="c1"># linear scalar) would be more useful to make match values</span>
            <span class="c1"># comparable across scales (test for it later, at time-to-use)</span>

        <span class="k">elif</span> <span class="n">multiscale_strategy</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">radii_px_ps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">radii_px_ps</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="n">r</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">radii_px_ps</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">r</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">radii_px_ps</span><span class="p">]):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Some elements of radii_px_ps were 0 or 1. &#39;</span>
                    <span class="s2">&quot;This means using multiscale_strategy=&#39;random&#39; may not make&quot;</span>
                    <span class="s1">&#39; sense.&#39;</span>
                <span class="p">)</span>

        <span class="k">elif</span> <span class="n">multiscale_strategy</span> <span class="o">==</span> <span class="s1">&#39;fixed_scale_order&#39;</span><span class="p">:</span>
            <span class="c1"># could just take elements from other iterables in order passed</span>
            <span class="c1"># in... just erring on side of being explicit</span>
            <span class="k">assert</span> <span class="n">scale_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">scale_order</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">scale_order</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">scale_order</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">radii_px</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;scale_order had elements not usable to &#39;</span>
                        <span class="s1">&#39;index scales&#39;</span>
                    <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;multiscale_strategy </span><span class="si">{</span><span class="n">multiscale_strategy</span><span class="si">}</span><span class="s1"> not &#39;</span>
                <span class="s1">&#39;recognized&#39;</span>
            <span class="p">)</span>

        <span class="c1"># Can not assert all match_images have the same shape, because d</span>
        <span class="c1"># affects shape of match image (as you can see from line inverting</span>
        <span class="c1"># this dependence to calculate orig_shape, below)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_scales</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">match_value_weights</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="n">radii_px_ps</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="n">scale_order</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="c1"># somewhat tautological. could delete.</span>
        <span class="k">if</span> <span class="n">thresholds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">total_n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="c1"># TODO optimal non-greedy alg for this problem? (maximize weight of</span>
    <span class="c1"># match_image summed across all assigned ROIs)</span>

    <span class="c1"># TODO do away with this copying if not necessary</span>
    <span class="c1"># (just don&#39;t want to mutate inputs without being clear about it)</span>
    <span class="c1"># (multiplication by match_value_weights below)</span>
    <span class="n">match_images</span> <span class="o">=</span> <span class="p">[</span><span class="n">mi</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">mi</span> <span class="ow">in</span> <span class="n">match_images</span><span class="p">]</span>
    <span class="n">orig_shapes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">match_image</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">match_images</span><span class="p">,</span> <span class="n">ds</span><span class="p">):</span>
        <span class="c1"># Working through example w/ 3x3 src img and 2x2 template -&gt; 2x2 match</span>
        <span class="c1"># image in docstring indicates necessity for - 1 here.</span>
        <span class="n">orig_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">match_image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">orig_shapes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">orig_shape</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">orig_shapes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">orig_shape</span> <span class="o">=</span> <span class="n">orig_shapes</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">_src_img_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">orig_shape</span> <span class="o">==</span> <span class="n">_src_img_shape</span>
        <span class="k">del</span> <span class="n">_src_img_shape</span>

    <span class="k">if</span> <span class="n">draw_on</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># if this fails, just fix shape comparison in next assertion and</span>
        <span class="c1"># then delete this assert</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">draw_on</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">assert</span> <span class="n">draw_on</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">orig_shape</span>

        <span class="n">draw_on</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">u8_color</span><span class="p">(</span><span class="n">draw_on</span><span class="p">)</span>
        <span class="c1"># upsampling just so cv2 drawing functions look better</span>
        <span class="n">ups</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="n">draw_on</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">draw_on</span><span class="p">,</span>
            <span class="nb">tuple</span><span class="p">([</span><span class="n">ups</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">draw_on</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]])</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">match_value_weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">match_value_weights</span><span class="p">):</span>
            <span class="n">match_images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">match_images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span>

    <span class="k">if</span> <span class="n">debug</span> <span class="ow">and</span> <span class="n">_show_match_images</span><span class="p">:</span>
        <span class="c1"># wanted these as subplots w/ colorbar besides each, but colorbars</span>
        <span class="c1"># seemed to want to go to the side w/ the simplest attempt</span>
        <span class="n">ncols</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">nrows</span> <span class="o">=</span> <span class="n">n_scales</span> <span class="o">%</span> <span class="n">ncols</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">ncols</span><span class="o">=</span><span class="n">ncols</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">nrows</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">multiscale</span> <span class="ow">or</span> <span class="n">multiscale_strategy</span> <span class="o">==</span> <span class="s1">&#39;one_order&#39;</span><span class="p">:</span>
            <span class="n">vmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">mi</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="k">for</span> <span class="n">mi</span> <span class="ow">in</span> <span class="n">match_images</span><span class="p">])</span>
            <span class="n">vmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">mi</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">for</span> <span class="n">mi</span> <span class="ow">in</span> <span class="n">match_images</span><span class="p">])</span>
            <span class="n">same_scale</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vmin</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">vmax</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">same_scale</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">match_image</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span>
            <span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">match_images</span><span class="p">)):</span>

            <span class="n">to_show</span> <span class="o">=</span> <span class="n">match_image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">thresholds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">to_show</span><span class="p">[</span><span class="n">to_show</span> <span class="o">&lt;</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="n">im</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">to_show</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">same_scale</span><span class="p">:</span>
                <span class="c1"># https://stackoverflow.com/questions/23876588</span>
                <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
                <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s1">&#39;5%&#39;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>

            <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">td</span><span class="si">}</span><span class="s1">x</span><span class="si">{</span><span class="n">td</span><span class="si">}</span><span class="s1"> template)&#39;</span>
            <span class="k">if</span> <span class="n">match_value_weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">match_value_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">title</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39; (weight=</span><span class="si">{</span><span class="n">w</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">)&#39;</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">same_scale</span><span class="p">:</span>
            <span class="c1"># l, b, w, h</span>
            <span class="n">cax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.85</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">])</span>
            <span class="n">cb</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
            <span class="n">cb</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">&#39;match value&#39;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">right</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;template matching metric at each template offset&#39;</span>
        <span class="k">if</span> <span class="n">thresholds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">(white space is pixels below corresponding threshold)&#39;</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="c1"># TODO may want to decrease wspace if same_scale</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">wspace</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

    <span class="n">all_flat_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">mi</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">for</span> <span class="n">mi</span> <span class="ow">in</span> <span class="n">match_images</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;thresholds for each scale:&#39;</span><span class="p">,</span> <span class="n">thresholds</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;min (possibly scaled) match val at each scale:&#39;</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">vs</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="k">for</span> <span class="n">vs</span> <span class="ow">in</span> <span class="n">all_flat_vals</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;max (possibly scaled) match val at each scale:&#39;</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">vs</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">for</span> <span class="n">vs</span> <span class="ow">in</span> <span class="n">all_flat_vals</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;match_value_weights:&#39;</span><span class="p">,</span> <span class="n">match_value_weights</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">multiscale</span> <span class="ow">or</span> <span class="n">multiscale_strategy</span> <span class="o">==</span> <span class="s1">&#39;one_order&#39;</span><span class="p">:</span>
        <span class="c1"># TODO TODO TODO need to sort flat_vals into one order, while</span>
        <span class="c1"># maintaining info about which match_image (index) a particular</span>
        <span class="c1"># value came from</span>
        <span class="c1"># how to do this while also thresholding each one?</span>

        <span class="n">all_vals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">all_scale_and_flat_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">fv</span><span class="p">,</span> <span class="n">thresh</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">all_flat_vals</span><span class="p">,</span> <span class="n">thresholds</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">thresholds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">flat_idx_at_least_thresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">fv</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">vals_at_least_thresh</span> <span class="o">=</span> <span class="n">fv</span><span class="p">[</span><span class="n">flat_idx_at_least_thresh</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">flat_idx_at_least_thresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fv</span><span class="p">))</span>
                <span class="n">vals_at_least_thresh</span> <span class="o">=</span> <span class="n">fv</span>

            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">thr_frac</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">flat_idx_at_least_thresh</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">fv</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;scale </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> fraction of (scaled) match values above&#39;</span>
                    <span class="s1">&#39; threshold:&#39;</span><span class="p">,</span> <span class="n">thr_frac</span>
                <span class="p">)</span>

                <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">                # TODO delete after figuring out discrepancy</span>
<span class="sd">                thr_fracs = [0.001252, 0.0008177839, 0.00087937249]</span>
<span class="sd">                assert np.isclose(thr_frac, thr_fracs[i])</span>

<span class="sd">                #print(len(flat_idx_at_least_thresh))</span>
<span class="sd">                #import ipdb; ipdb.set_trace()</span>
<span class="sd">                #</span>
<span class="sd">                &#39;&#39;&#39;</span>
                <span class="c1"># TODO TODO maybe find range of weights that produce same</span>
                <span class="c1"># fraction above thresholds, and see if somewhere in that range</span>
                <span class="c1"># is a set of weights that also leads to a global ordering that</span>
                <span class="c1"># behaves as I want?</span>

                <span class="c1"># TODO delete if not gonna finish</span>
                <span class="k">if</span> <span class="n">_initial_single_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">t0</span> <span class="o">=</span> <span class="n">_initial_single_threshold</span>

                    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">                    if match_value_weights is not None:</span>
<span class="sd">                        # Undoing previous multiplication by weight.</span>
<span class="sd">                        w = match_value_weights[i]</span>
<span class="sd">                        orig_match_image = match_images[i] / w</span>
<span class="sd">                    orig </span>

<span class="sd">                    # TODO TODO TODO fit(?) to find match value weight that</span>
<span class="sd">                    # produces same fraction of pixels above threshold</span>
<span class="sd">                    import ipdb; ipdb.set_trace()</span>
<span class="sd">                    &#39;&#39;&#39;</span>
                <span class="c1">#</span>

            <span class="c1"># TODO maybe just store ranges of indices in concatenated</span>
            <span class="c1"># flat_idx... that correspond to each source img?</span>
            <span class="n">src_img_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">flat_idx_at_least_thresh</span><span class="p">))</span>

            <span class="n">scale_and_flat_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                <span class="p">[</span><span class="n">src_img_idx</span><span class="p">,</span> <span class="n">flat_idx_at_least_thresh</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">all_scale_and_flat_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scale_and_flat_indices</span><span class="p">)</span>
            <span class="n">all_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vals_at_least_thresh</span><span class="p">)</span>

        <span class="n">all_scale_and_flat_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">all_scale_and_flat_indices</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="n">all_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">all_vals</span><span class="p">)</span>
        <span class="c1"># Reversing order so indices corresponding to biggest element is first,</span>
        <span class="c1"># and so on, decreasing.</span>
        <span class="n">one_order_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">all_vals</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        # TODO delete</span>
<span class="sd">        #np.set_printoptions(threshold=sys.maxsize)</span>
<span class="sd">        out = all_scale_and_flat_indices.T[one_order_indices]</span>
<span class="sd">        print(&#39;all_scale_and_flat_indices.shape:&#39;,</span>
<span class="sd">            all_scale_and_flat_indices.shape</span>
<span class="sd">        )</span>
<span class="sd">        print(&#39;one_order_indices.shape:&#39;, one_order_indices.shape)</span>

<span class="sd">        print(&#39;sorted match values:&#39;)</span>
<span class="sd">        print(all_vals[one_order_indices])</span>

<span class="sd">        nlines = 20</span>
<span class="sd">        head = out[:nlines]</span>
<span class="sd">        tail = out[-nlines:]</span>
<span class="sd">        print(&#39;head:&#39;)</span>
<span class="sd">        print(head)</span>
<span class="sd">        print(&#39;tail:&#39;)</span>
<span class="sd">        print(tail)</span>

<span class="sd">        chead = np.array([[     2, 120520],</span>
<span class="sd">               [     1, 108599],</span>
<span class="sd">               [     0, 125250],</span>
<span class="sd">               [     2, 120521],</span>
<span class="sd">               [     2, 120029],</span>
<span class="sd">               [     2, 120519],</span>
<span class="sd">               [     2, 121011],</span>
<span class="sd">               [     2, 120030],</span>
<span class="sd">               [     2, 121012],</span>
<span class="sd">               [     2, 120028],</span>
<span class="sd">               [     2, 121010],</span>
<span class="sd">               [     1, 108600],</span>
<span class="sd">               [     1, 109096],</span>
<span class="sd">               [     1, 108598],</span>
<span class="sd">               [     1, 108102],</span>
<span class="sd">               [     0, 125750],</span>
<span class="sd">               [     0, 125249],</span>
<span class="sd">               [     0, 124750],</span>
<span class="sd">               [     0, 125251],</span>
<span class="sd">               [     1, 124002]])</span>

<span class="sd">        ctail = np.array([[     0, 108759],</span>
<span class="sd">               [     0, 112252],</span>
<span class="sd">               [     0, 111259],</span>
<span class="sd">               [     0, 112257],</span>
<span class="sd">               [     0, 125723],</span>
<span class="sd">               [     0, 124223],</span>
<span class="sd">               [     0, 128231],</span>
<span class="sd">               [     0, 121728],</span>
<span class="sd">               [     0, 128228],</span>
<span class="sd">               [     0, 124236],</span>
<span class="sd">               [     0, 125736],</span>
<span class="sd">               [     0, 121731],</span>
<span class="sd">               [     0, 128227],</span>
<span class="sd">               [     0, 126236],</span>
<span class="sd">               [     0, 126223],</span>
<span class="sd">               [     0, 121732],</span>
<span class="sd">               [     0, 123723],</span>
<span class="sd">               [     0, 128232],</span>
<span class="sd">               [     0, 121727],</span>
<span class="sd">               [     0, 123736]])</span>

<span class="sd">        try:</span>
<span class="sd">            assert np.array_equal(chead, head)</span>
<span class="sd">            assert np.array_equal(ctail, tail)</span>
<span class="sd">        except AssertionError:</span>
<span class="sd">            print(&#39;arrays did not match&#39;)</span>
<span class="sd">            print(&#39;correct versions (from specific thresholds):&#39;)</span>
<span class="sd">            print(&#39;correct head:&#39;)</span>
<span class="sd">            print(chead)</span>
<span class="sd">            print(&#39;correct tail:&#39;)</span>
<span class="sd">            print(ctail)</span>
<span class="sd">            import ipdb; ipdb.set_trace()</span>
<span class="sd">        #</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">def</span> <span class="nf">match_iter_fn</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">scale_idx</span><span class="p">,</span> <span class="n">match_img_flat_idx</span> <span class="ow">in</span> <span class="n">all_scale_and_flat_indices</span><span class="o">.</span><span class="n">T</span><span class="p">[</span>
                <span class="n">one_order_indices</span><span class="p">]:</span>

                <span class="n">match_image</span> <span class="o">=</span> <span class="n">match_images</span><span class="p">[</span><span class="n">scale_idx</span><span class="p">]</span>
                <span class="n">match_pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">match_img_flat_idx</span><span class="p">,</span>
                    <span class="n">match_image</span><span class="o">.</span><span class="n">shape</span>
                <span class="p">)</span>
                <span class="k">yield</span> <span class="n">scale_idx</span><span class="p">,</span> <span class="n">match_pt</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">all_matches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">match_image</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">match_images</span><span class="p">):</span>
            <span class="n">flat_vals</span> <span class="o">=</span> <span class="n">all_flat_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">sorted_flat_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">flat_vals</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">thresholds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">flat_vals</span><span class="p">[</span><span class="n">sorted_flat_indices</span><span class="p">],</span>
                    <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">sorted_flat_indices</span> <span class="o">=</span> <span class="n">sorted_flat_indices</span><span class="p">[</span><span class="n">idx</span><span class="p">:]</span>
                <span class="k">del</span> <span class="n">idx</span>

            <span class="c1"># Reversing order so indices corresponding to biggest element is</span>
            <span class="c1"># first, and so on, decreasing.</span>
            <span class="n">sorted_flat_indices</span> <span class="o">=</span> <span class="n">sorted_flat_indices</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">sorted_flat_indices</span><span class="p">,</span> <span class="n">match_image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">all_matches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">multiscale_strategy</span> <span class="o">==</span> <span class="s1">&#39;fixed_scale_order&#39;</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">match_iter_fn</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">scale_idx</span> <span class="ow">in</span> <span class="n">scale_order</span><span class="p">:</span>
                    <span class="n">matches</span> <span class="o">=</span> <span class="n">all_matches</span><span class="p">[</span><span class="n">scale_idx</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">match_pt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">matches</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">scale_idx</span><span class="p">,</span> <span class="n">match_pt</span>

        <span class="k">elif</span> <span class="n">multiscale_strategy</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">match_iter_fn</span><span class="p">():</span>
                <span class="n">per_scale_last_idx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_scales</span>
                <span class="n">scale_ps</span> <span class="o">=</span> <span class="n">radii_px_ps</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">scale_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">n_scales</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">scale_ps</span><span class="p">)</span>
                    <span class="n">matches</span> <span class="o">=</span> <span class="n">all_matches</span><span class="p">[</span><span class="n">scale_idx</span><span class="p">]</span>

                    <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">last</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">last</span><span class="p">,</span> <span class="n">matches</span> <span class="ow">in</span>
                        <span class="nb">zip</span><span class="p">(</span><span class="n">per_scale_last_idx</span><span class="p">,</span> <span class="n">all_matches</span><span class="p">)]):</span>

                        <span class="c1"># This should end the generator&#39;s iteration.</span>
                        <span class="k">return</span>

                    <span class="c1"># Currently just opting to retry sampling when we</span>
                    <span class="c1"># got something for which we have already exhausted all</span>
                    <span class="c1"># matches, rather than changing probabilities and choices.</span>
                    <span class="k">if</span> <span class="n">per_scale_last_idx</span><span class="p">[</span><span class="n">scale_idx</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="k">continue</span>

                    <span class="n">match_idx</span> <span class="o">=</span> <span class="n">per_scale_last_idx</span><span class="p">[</span><span class="n">scale_idx</span><span class="p">]</span>
                    <span class="n">match_pt</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">match_idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">)</span>

                    <span class="n">per_scale_last_idx</span><span class="p">[</span><span class="n">scale_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="k">yield</span> <span class="n">scale_idx</span><span class="p">,</span> <span class="n">match_pt</span>

    <span class="n">match_iter</span> <span class="o">=</span> <span class="n">match_iter_fn</span><span class="p">()</span>

    <span class="c1"># TODO and any point to having subpixel circles anyway?</span>
    <span class="c1"># i.e. will packing decisions ever differ from those w/ rounded int</span>
    <span class="c1"># circles (and then also given that my ijroi currently only supports</span>
    <span class="c1"># saving non-subpixel rois...)?</span>

    <span class="n">claimed</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">center2radius</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="n">total_n_found</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">roi_centers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># roi_ prefix here is to disambiguate this from radii_px input, which</span>
    <span class="c1"># describes radii of various template scales to use for matching, but</span>
    <span class="c1"># NOT the radii of the particular matched ROI outputs.</span>
    <span class="n">roi_radii_px</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">ns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_found_per_scale</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_scales</span>

    <span class="n">max_exclusion_radius_px</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">exclusion_radius_frac</span> <span class="o">*</span> <span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">radii_px</span><span class="p">)</span>
    <span class="n">scale_info_printed</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_scales</span>
    <span class="k">for</span> <span class="n">scale_idx</span><span class="p">,</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">match_iter</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">total_n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">total_n_found</span> <span class="o">&gt;=</span> <span class="n">total_n</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">elif</span> <span class="n">ns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">n_found</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n_found</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">n_found_per_scale</span><span class="p">,</span> <span class="n">ns</span><span class="p">)]):</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="n">n_found_per_scale</span><span class="p">[</span><span class="n">scale_idx</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">ns</span><span class="p">[</span><span class="n">scale_idx</span><span class="p">]:</span>
                <span class="k">continue</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="n">scale_idx</span><span class="p">]</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">d</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">offset</span>

        <span class="k">if</span> <span class="n">exclusion_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">exclusion_mask</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">center</span><span class="p">)]:</span>
                <span class="k">continue</span>

        <span class="n">radius_px</span> <span class="o">=</span> <span class="n">radii_px</span><span class="p">[</span><span class="n">scale_idx</span><span class="p">]</span>
        <span class="n">exclusion_radius_px</span> <span class="o">=</span> <span class="n">radius_px</span> <span class="o">*</span> <span class="n">exclusion_radius_frac</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">scale_info_printed</span><span class="p">[</span><span class="n">scale_idx</span><span class="p">]:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;template d:&#39;</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;radius_px:&#39;</span><span class="p">,</span> <span class="n">radius_px</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;exclusion_radius_frac:&#39;</span><span class="p">,</span> <span class="n">exclusion_radius_frac</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;exclusion_radius_px:&#39;</span><span class="p">,</span> <span class="n">exclusion_radius_px</span><span class="p">)</span>
                <span class="n">scale_info_printed</span><span class="p">[</span><span class="n">scale_idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Ideally I&#39;d probably use a data structure that doesn&#39;t need to</span>
        <span class="c1"># be rebuilt each time (and k-d trees in general don&#39;t, but</span>
        <span class="c1"># scipy&#39;s doesn&#39;t support that (perhaps b/c issues w/ accumulating</span>
        <span class="c1"># rebalancing costs?), nor do they seem to offer spatial</span>
        <span class="c1"># structures that do)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">claimed</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="n">claimed</span><span class="p">)</span>
            <span class="c1"># (would need to relax if supporting 3d)</span>
            <span class="k">assert</span> <span class="n">tree</span><span class="o">.</span><span class="n">m</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="c1"># TODO tests to check whether this is right dist bound</span>
            <span class="c1"># ( / 2 ?)</span>
            <span class="n">dists</span><span class="p">,</span> <span class="n">locs</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">center</span><span class="p">,</span>
                <span class="n">distance_upper_bound</span><span class="o">=</span><span class="n">max_exclusion_radius_px</span> <span class="o">*</span> <span class="mi">2</span>
            <span class="p">)</span>
            <span class="c1"># Docs say this indicates no neighbors found.</span>
            <span class="k">if</span> <span class="n">locs</span> <span class="o">!=</span> <span class="n">tree</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">dists</span> <span class="o">=</span> <span class="p">[</span><span class="n">dists</span><span class="p">]</span>
                    <span class="n">locs</span> <span class="o">=</span> <span class="p">[</span><span class="n">locs</span><span class="p">]</span>

                <span class="n">conflict</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">dist</span><span class="p">,</span> <span class="n">neighbor_idx</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">locs</span><span class="p">):</span>
                    <span class="c1"># TODO TODO any way to add metadata to tree element to avoid</span>
                    <span class="c1"># this lookup? (+ dist bound above)</span>
                    <span class="n">neighbor_r</span> <span class="o">=</span> <span class="n">center2radius</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">neighbor_idx</span><span class="p">])]</span>
                    <span class="c1"># We already counted the radius about the tentative</span>
                    <span class="c1"># new ROI, but that assumes all neighbors are just points.</span>
                    <span class="c1"># This prevents small ROIs from being placed inside big</span>
                    <span class="c1"># ones.</span>
                    <span class="c1"># TODO check these two lines</span>
                    <span class="n">dist</span> <span class="o">-=</span> <span class="n">neighbor_r</span> <span class="o">*</span> <span class="n">exclusion_radius_frac</span>
                    <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">exclusion_radius_px</span><span class="p">:</span>
                        <span class="n">conflict</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">conflict</span><span class="p">:</span>
                    <span class="k">continue</span>

        <span class="n">total_n_found</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">roi_centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
        <span class="n">roi_radii_px</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">radius_px</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">draw_on</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">draw_pt</span> <span class="o">=</span> <span class="p">(</span><span class="n">ups</span> <span class="o">*</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ups</span> <span class="o">*</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">draw_c</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">ups</span> <span class="o">*</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span>
                <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">ups</span> <span class="o">*</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># TODO factor this stuff out into post-hoc drawing fn, so that</span>
            <span class="c1"># roi filters in here can exclude stuff? or maybe just factor out</span>
            <span class="c1"># the filtering stuff anyway?</span>

            <span class="k">if</span> <span class="n">draw_bboxes</span><span class="p">:</span>
                <span class="n">cv2</span><span class="o">.</span><span class="n">rectangle</span><span class="p">(</span><span class="n">draw_on</span><span class="p">,</span> <span class="n">draw_pt</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">draw_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ups</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span> <span class="n">draw_pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ups</span> <span class="o">*</span> <span class="n">d</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">),</span> <span class="mi">2</span>
                <span class="p">)</span>

            <span class="c1"># TODO maybe diff colors for diff scales? (random or from kwarg)</span>
            <span class="k">if</span> <span class="n">draw_circles</span><span class="p">:</span>
                <span class="n">cv2</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">draw_on</span><span class="p">,</span> <span class="n">draw_c</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">ups</span> <span class="o">*</span> <span class="n">radius_px</span><span class="p">)),</span>
                    <span class="p">(</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">2</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">draw_nums</span><span class="p">:</span>
                <span class="n">cv2</span><span class="o">.</span><span class="n">putText</span><span class="p">(</span><span class="n">draw_on</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">total_n_found</span><span class="p">),</span> <span class="n">draw_pt</span><span class="p">,</span>
                    <span class="n">cv2</span><span class="o">.</span><span class="n">FONT_HERSHEY_SIMPLEX</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">2</span>
                <span class="p">)</span>

        <span class="n">claimed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
        <span class="n">center2radius</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">center</span><span class="p">)]</span> <span class="o">=</span> <span class="n">radius_px</span>

    <span class="c1"># TODO change to not need to import (all of?) viz? would that help avoid some</span>
    <span class="c1"># circular import issues?</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    if debug and _show_packing_constraints:</span>
<span class="sd">        title = &#39;greedy_roi_packing overlap exlusion mask&#39;</span>
<span class="sd">        viz.imshow(claimed, title)</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">debug</span> <span class="ow">and</span> <span class="n">draw_on</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">_show_fit</span><span class="p">:</span>
        <span class="n">viz</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">draw_on</span><span class="p">,</span> <span class="s1">&#39;greedy_roi_packing fit&#39;</span><span class="p">)</span>

    <span class="c1"># TODO also use kdtree for this step</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">min_neighbors</span><span class="p">:</span>
        <span class="n">filtered_roi_centers</span> <span class="o">=</span> <span class="n">roi_centers</span>
        <span class="n">filtered_roi_radii</span> <span class="o">=</span> <span class="n">roi_radii_px</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># TODO maybe extend this to requiring the nth closest be closer than a</span>
        <span class="c1"># certain amount (to exclude 2 (or n) cells off by themselves)</span>
        <span class="n">filtered_roi_centers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">filtered_roi_radii</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">roi_centers</span><span class="p">,</span> <span class="n">roi_radii_px</span><span class="p">)):</span>
            <span class="n">n_neighbors</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">other_center</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">roi_centers</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">dist</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">euclidean_dist</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">other_center</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">min_dist2neighbor_px</span><span class="p">:</span>
                    <span class="n">n_neighbors</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">n_neighbors</span> <span class="o">&gt;=</span> <span class="n">min_neighbors</span><span class="p">:</span>
                    <span class="n">filtered_roi_centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
                    <span class="n">filtered_roi_radii</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>
                    <span class="k">break</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_roi_centers</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_roi_radii</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">filtered_roi_centers</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">filtered_roi_radii</span><span class="p">)</span></div>


<div class="viewcode-block" id="scale_template"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.scale_template">[docs]</a><span class="k">def</span> <span class="nf">scale_template</span><span class="p">(</span><span class="n">template_data</span><span class="p">,</span> <span class="n">um_per_pixel_xy</span><span class="p">,</span> <span class="n">target_cell_diam_um</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">target_cell_diam_px</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_template_d</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">cv2</span>

    <span class="k">if</span> <span class="n">target_cell_diam_um</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># TODO make either of other kwargs also work (any of the 3 should</span>
        <span class="c1"># be alone)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="n">template</span> <span class="o">=</span> <span class="n">template_data</span><span class="p">[</span><span class="s1">&#39;template&#39;</span><span class="p">]</span>
    <span class="n">margin</span> <span class="o">=</span> <span class="n">template_data</span><span class="p">[</span><span class="s1">&#39;margin&#39;</span><span class="p">]</span>
    <span class="c1"># We enforce both elements of shape are same at creation.</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">target_cell_diam_px</span> <span class="o">=</span> <span class="n">target_cell_diam_um</span> <span class="o">/</span> <span class="n">um_per_pixel_xy</span>

    <span class="c1"># TODO which of these is correct? both? assert one is w/in</span>
    <span class="c1"># rounding err of other?</span>
    <span class="n">template_cell_diam_px</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">margin</span>
    <span class="n">template_scale</span> <span class="o">=</span> <span class="n">target_cell_diam_px</span> <span class="o">/</span> <span class="n">template_cell_diam_px</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    template_cell_diam_um = template_data[&#39;mean_cell_diam_um&#39;]</span>
<span class="sd">    print(f&#39;template_cell_diam_um: {template_cell_diam_um}&#39;)</span>
<span class="sd">    template_scale = target_cell_diam_um / template_cell_diam_um</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">new_template_d</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">template_scale</span> <span class="o">*</span> <span class="n">d</span><span class="p">))</span>
    <span class="n">new_template_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">new_template_d</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">scale_template:</span><span class="se">\n</span><span class="s1">d: </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="se">\n</span><span class="s1">margin: </span><span class="si">{</span><span class="n">margin</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;um_per_pixel_xy: </span><span class="si">{</span><span class="n">um_per_pixel_xy</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;target_cell_diam_um: </span><span class="si">{</span><span class="n">target_cell_diam_um</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;target_cell_diam_px: </span><span class="si">{</span><span class="n">target_cell_diam_px</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;template_cell_diam_px: </span><span class="si">{</span><span class="n">template_cell_diam_px</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;template_scale: </span><span class="si">{</span><span class="n">template_scale</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;new_template_d: </span><span class="si">{</span><span class="n">new_template_d</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">new_template_d</span> <span class="o">!=</span> <span class="n">d</span><span class="p">:</span>
        <span class="n">scaled_template</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">new_template_shape</span><span class="p">)</span>
        <span class="n">scaled_template_cell_diam_px</span> <span class="o">=</span> \
            <span class="n">template_cell_diam_px</span> <span class="o">*</span> <span class="n">new_template_d</span> <span class="o">/</span> <span class="n">d</span>

        <span class="k">return</span> <span class="n">scaled_template</span><span class="p">,</span> <span class="n">scaled_template_cell_diam_px</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">template</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">template_cell_diam_px</span></div>


<span class="k">def</span> <span class="nf">_get_template_roi_radius_px</span><span class="p">(</span><span class="n">template_data</span><span class="p">,</span> <span class="n">if_template_d</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_round</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">template</span> <span class="o">=</span> <span class="n">template_data</span><span class="p">[</span><span class="s1">&#39;template&#39;</span><span class="p">]</span>
    <span class="n">margin</span> <span class="o">=</span> <span class="n">template_data</span><span class="p">[</span><span class="s1">&#39;margin&#39;</span><span class="p">]</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">template_cell_diam_px</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">margin</span>
    <span class="n">template_cell_radius_px</span> <span class="o">=</span> <span class="n">template_cell_diam_px</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="n">radius_frac</span> <span class="o">=</span> <span class="n">template_cell_radius_px</span> <span class="o">/</span> <span class="n">d</span>

    <span class="k">if</span> <span class="n">if_template_d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">if_template_d</span> <span class="o">=</span> <span class="n">d</span>

    <span class="n">radius_px</span> <span class="o">=</span> <span class="n">radius_frac</span> <span class="o">*</span> <span class="n">if_template_d</span>
    <span class="k">if</span> <span class="n">_round</span><span class="p">:</span>
        <span class="n">radius_px</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">radius_px</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">radius_px</span>


<span class="c1"># TODO test this w/ n.5 centers / radii</span>
<div class="viewcode-block" id="get_circle_ijroi_input"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.get_circle_ijroi_input">[docs]</a><span class="k">def</span> <span class="nf">get_circle_ijroi_input</span><span class="p">(</span><span class="n">center_px</span><span class="p">,</span> <span class="n">radius_px</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns appropriate first arg for my ijroi.write_roi</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">min_corner</span> <span class="o">=</span> <span class="p">[</span><span class="n">center_px</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">radius_px</span><span class="p">,</span> <span class="n">center_px</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">radius_px</span><span class="p">]</span>
    <span class="n">max_corner</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">min_corner</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">radius_px</span><span class="p">,</span>
        <span class="n">min_corner</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">radius_px</span>
    <span class="p">]</span>
    <span class="n">bbox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">min_corner</span><span class="p">,</span> <span class="n">max_corner</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">bbox</span></div>


<span class="c1"># TODO move to viz? or maybe move all roi stuff to a new module?</span>
<div class="viewcode-block" id="plot_circles"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.plot_circles">[docs]</a><span class="k">def</span> <span class="nf">plot_circles</span><span class="p">(</span><span class="n">draw_on</span><span class="p">,</span> <span class="n">centers</span><span class="p">,</span> <span class="n">radii</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">cv2</span>
    <span class="n">draw_on</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">draw_on</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mi">255</span><span class="p">,</span>
        <span class="n">norm_type</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">NORM_MINMAX</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">CV_8UC1</span>
    <span class="p">)</span>
    <span class="n">draw_on</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">equalizeHist</span><span class="p">(</span><span class="n">draw_on</span><span class="p">)</span>

    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">10.5</span><span class="p">))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">draw_on</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">center</span><span class="p">,</span> <span class="n">radius</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">centers</span><span class="p">,</span> <span class="n">radii</span><span class="p">):</span>
        <span class="n">roi_circle</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">((</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">radius</span><span class="p">,</span>
            <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">roi_circle</span><span class="p">)</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">set_frame_on</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="fit_circle_rois"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.fit_circle_rois">[docs]</a><span class="k">def</span> <span class="nf">fit_circle_rois</span><span class="p">(</span><span class="n">tif</span><span class="p">,</span> <span class="n">template_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">avg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">movie</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">method_str</span><span class="o">=</span><span class="s1">&#39;cv2.TM_CCOEFF_NORMED&#39;</span><span class="p">,</span> <span class="n">thresholds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">exclusion_radius_frac</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">min_neighbors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">_packing_debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">show_fit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">write_ijrois</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">_force_write_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">exclude_dark_regions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dark_fraction_beyond_dhist_min</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
    <span class="n">max_n_rois</span><span class="o">=</span><span class="mi">650</span><span class="p">,</span> <span class="n">min_n_rois</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span>
    <span class="n">per_scale_max_n_rois</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">per_scale_min_n_rois</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">threshold_update_factor</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
    <span class="n">update_factor_shrink_factor</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">max_threshold_tries</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">_um_per_pixel_xy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">multiscale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">roi_diams_px</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">roi_diams_um</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">roi_diams_from_kmeans_k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">multiscale_strategy</span><span class="o">=</span><span class="s1">&#39;one_order&#39;</span><span class="p">,</span> <span class="n">template_d2match_value_scale_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">allow_duplicate_px_scales</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">_show_scaled_templates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Even if movie or avg is passed in, tif is used to find metadata and</span>
<span class="sd">    determine where to save ImageJ ROIs.</span>

<span class="sd">    _um_per_pixel_xy only used for testing. Normally, XML is found from `tif`,</span>
<span class="sd">    and that is loaded to get this value.</span>

<span class="sd">    Returns centers_px, radii_px</span>
<span class="sd">    (both w/ coordinates and conventions ijrois uses)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">tifffile</span>
    <span class="kn">import</span> <span class="nn">cv2</span>
    <span class="kn">import</span> <span class="nn">ijroi</span>
    <span class="kn">from</span> <span class="nn">scipy.cluster.vq</span> <span class="kn">import</span> <span class="n">vq</span>

    <span class="k">if</span> <span class="n">debug</span> <span class="ow">and</span> <span class="n">show_fit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">show_fit</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># TODO update all kwargs to go through a dict (store existing defaults as</span>
    <span class="c1"># dict at module level?) + need to handle passing of remaining to greedy_...</span>
    <span class="c1"># appropriately (don&#39;t pass stuff it won&#39;t take / don&#39;t unwrap and modify</span>
    <span class="c1"># so it only uses relevant ones)</span>
    <span class="n">method_str2defaults</span> <span class="o">=</span> <span class="p">{</span>
        <span class="c1"># Though this does not work at all scales</span>
        <span class="c1"># (especially sensitive since not normed)</span>
        <span class="s1">&#39;cv2.TM_CCOEFF&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;threshold&#39;</span><span class="p">:</span> <span class="mf">4000.0</span><span class="p">,</span> <span class="s1">&#39;exclude_dark_regions&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
        <span class="s1">&#39;cv2.TM_CCOEFF_NORMED&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;threshold&#39;</span><span class="p">:</span> <span class="mf">0.3</span><span class="p">,</span> <span class="s1">&#39;exclude_dark_regions&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">method_str</span> <span class="ow">in</span> <span class="n">method_str2defaults</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">method_str2defaults</span><span class="p">[</span><span class="n">method_str</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="n">threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;threshold&#39;</span><span class="p">)</span>
    <span class="n">exclude_dark_regions</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;exclude_dark_regions&#39;</span><span class="p">)</span>

    <span class="c1"># Will divide rather than multiply by this,</span>
    <span class="c1"># if we need to increase threshold.</span>
    <span class="k">assert</span> <span class="n">threshold_update_factor</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">threshold_update_factor</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="c1"># TODO also provide fitting for this fn in extract_template?</span>
    <span class="n">mvw_key</span> <span class="o">=</span> <span class="s1">&#39;match_value_weights&#39;</span>
    <span class="k">if</span> <span class="n">template_d2match_value_scale_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">multiscale</span> <span class="ow">and</span> <span class="n">multiscale_strategy</span> <span class="o">==</span> <span class="s1">&#39;one_scale&#39;</span>
        <span class="k">assert</span> <span class="n">mvw_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span>
        <span class="n">match_value_weights</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">match_value_weights</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">mvw_key</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">match_value_weights</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">template_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># TODO maybe options to cache this data across calls?</span>
        <span class="c1"># might not matter...</span>
        <span class="n">template_data</span> <span class="o">=</span> <span class="n">load_template_data</span><span class="p">(</span><span class="n">err_if_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">template</span> <span class="o">=</span> <span class="n">template_data</span><span class="p">[</span><span class="s1">&#39;template&#39;</span><span class="p">]</span>
    <span class="n">margin</span> <span class="o">=</span> <span class="n">template_data</span><span class="p">[</span><span class="s1">&#39;margin&#39;</span><span class="p">]</span>
    <span class="n">mean_cell_diam_um</span> <span class="o">=</span> <span class="n">template_data</span><span class="p">[</span><span class="s1">&#39;mean_cell_diam_um&#39;</span><span class="p">]</span>
    <span class="n">frame_shape</span> <span class="o">=</span> <span class="n">template_data</span><span class="p">[</span><span class="s1">&#39;frame_shape&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">_um_per_pixel_xy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">tiff_filename2keys</span><span class="p">(</span><span class="n">tif</span><span class="p">)</span>
        <span class="n">ti_dir</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">thorimage_dir</span><span class="p">(</span><span class="o">*</span><span class="nb">tuple</span><span class="p">(</span><span class="n">keys</span><span class="p">))</span>
        <span class="n">xmlroot</span> <span class="o">=</span> <span class="n">thor</span><span class="o">.</span><span class="n">get_thorimage_xmlroot</span><span class="p">(</span><span class="n">ti_dir</span><span class="p">)</span>
        <span class="n">um_per_pixel_xy</span> <span class="o">=</span> <span class="n">thor</span><span class="o">.</span><span class="n">get_thorimage_pixelsize_um</span><span class="p">(</span><span class="n">xmlroot</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">keys</span><span class="p">,</span> <span class="n">ti_dir</span><span class="p">,</span> <span class="n">xmlroot</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">um_per_pixel_xy</span> <span class="o">=</span> <span class="n">_um_per_pixel_xy</span>

    <span class="k">if</span> <span class="n">multiscale</span><span class="p">:</span>
        <span class="c1"># Centroids are scalars in units of um diam</span>
        <span class="n">kmeans_k2cluster_cell_diams</span> <span class="o">=</span> \
            <span class="n">template_data</span><span class="p">[</span><span class="s1">&#39;kmeans_k2cluster_cell_diams&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">roi_diams_px</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">roi_diams_um</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">roi_diams_from_kmeans_k</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="n">roi_diams_um</span> <span class="o">=</span> <span class="p">[</span><span class="n">rd_px</span> <span class="o">*</span> <span class="n">um_per_pixel_xy</span> <span class="k">for</span> <span class="n">rd_px</span> <span class="ow">in</span> <span class="n">roi_diams_px</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">roi_diams_um</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">roi_diams_from_kmeans_k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">roi_diams_from_kmeans_k</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">roi_diams_um</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">roi_diams_um</span> <span class="o">=</span> <span class="n">kmeans_k2cluster_cell_diams</span><span class="p">[</span><span class="n">roi_diams_from_kmeans_k</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">in_px</span> <span class="o">=</span> <span class="n">roi_diams_um</span> <span class="o">/</span> <span class="n">um_per_pixel_xy</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Using ROI diameters </span><span class="si">{</span><span class="n">roi_diams_um</span><span class="si">}</span><span class="s1"> um (</span><span class="si">{</span><span class="n">in_px</span><span class="si">}</span><span class="s1"> px) from&#39;</span>
                    <span class="sa">f</span><span class="s1">&#39; K-means (k=</span><span class="si">{</span><span class="n">roi_diams_from_kmeans_k</span><span class="si">}</span><span class="s1">) on data used to &#39;</span>
                    <span class="s1">&#39;generate template.&#39;</span>
                <span class="p">)</span>
                <span class="k">del</span> <span class="n">in_px</span>

            <span class="k">if</span> <span class="n">multiscale_strategy</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
                <span class="n">all_cell_diams_um</span> <span class="o">=</span> <span class="n">template_data</span><span class="p">[</span><span class="s1">&#39;all_cell_diams_um&#39;</span><span class="p">]</span>
                <span class="n">clusters</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">vq</span><span class="p">(</span><span class="n">all_cell_diams_um</span><span class="p">,</span> <span class="n">roi_diams_um</span><span class="p">)</span>
                <span class="n">count_clusters</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1"># otherwise would need to reindex the counts</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">count_clusters</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">count_clusters</span><span class="p">))</span>
                <span class="n">radii_px_ps</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;radii_px_ps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">radii_px_ps</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Calculated these probabilities from template data:&#39;</span><span class="p">,</span>
                    <span class="n">radii_px_ps</span>
                <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">roi_diams_px</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="n">roi_diams_um</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="n">roi_diams_from_kmeans_k</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="n">roi_diams_um</span> <span class="o">=</span> <span class="p">[</span><span class="n">mean_cell_diam_um</span><span class="p">]</span>

    <span class="n">n_scales</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">roi_diams_um</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">thresholds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">thresholds</span> <span class="o">=</span> <span class="p">[</span><span class="n">threshold</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_scales</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># TODO better way to specify thresholds in kmeans case, where</span>
        <span class="c1"># user may not know # thresholds needed in advance?</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">thresholds</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_scales</span>
    <span class="k">del</span> <span class="n">threshold</span>
    <span class="n">thresholds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">thresholds</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">write_ijrois</span> <span class="ow">or</span> <span class="n">_force_write_to</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">write_ijrois</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">path</span><span class="p">,</span> <span class="n">tiff_last_part</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">tif</span><span class="p">)</span>
        <span class="n">tiff_parts</span> <span class="o">=</span> <span class="n">tiff_last_part</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.tif&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tiff_parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">tiff_parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">tiff_parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_rois.zip&#39;</span><span class="p">)</span>

        <span class="c1"># TODO TODO change. fname needs to always be under</span>
        <span class="c1"># analysis_output_root (or just change input in</span>
        <span class="c1"># kc_natural_mixes/populate_db.py).</span>
        <span class="c1"># TODO or at least err if not subdir of it</span>
        <span class="c1"># see: https://stackoverflow.com/questions/3812849</span>

        <span class="k">if</span> <span class="n">_force_write_to</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_force_write_to</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">fname</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">tiff_parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_auto_rois.zip&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fname</span> <span class="o">=</span> <span class="n">_force_write_to</span>

        <span class="c1"># TODO also check for modifications before overwriting (mtime in that hidden</span>
        <span class="c1"># file)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">overwrite</span> <span class="ow">and</span> <span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;already existed. returning.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">avg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">movie</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">movie</span> <span class="o">=</span> <span class="n">tifffile</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">tif</span><span class="p">)</span>
        <span class="n">avg</span> <span class="o">=</span> <span class="n">movie</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">avg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">avg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">orig_frame_d</span> <span class="o">=</span> <span class="n">avg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># It seemed to me that picking a new threshold on cv2.TM_CCOEFF_NORMED was</span>
    <span class="c1"># not sufficient to reproduce cv2.TM_CCOEFF performance, so even if the</span>
    <span class="c1"># normed version were useful to keep the same threshold across image scales,</span>
    <span class="c1"># it seems other problems prevent me from using that in my case, so I&#39;m</span>
    <span class="c1"># rescaling the image to match against.</span>

    <span class="n">frame_downscaling</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">if</span> <span class="n">avg</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">frame_shape</span><span class="p">:</span>
        <span class="n">scaled_avg</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">avg</span><span class="p">,</span> <span class="n">frame_shape</span><span class="p">)</span>

        <span class="n">new_frame_d</span> <span class="o">=</span> <span class="n">scaled_avg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">frame_downscaling</span> <span class="o">=</span> <span class="n">orig_frame_d</span> <span class="o">/</span> <span class="n">new_frame_d</span>
        <span class="k">del</span> <span class="n">new_frame_d</span>
        <span class="n">um_per_pixel_xy</span> <span class="o">*=</span> <span class="n">frame_downscaling</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">scaled_avg</span> <span class="o">=</span> <span class="n">avg</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;frame downscaling:&#39;</span><span class="p">,</span> <span class="n">frame_downscaling</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;scaled_avg.shape:&#39;</span><span class="p">,</span> <span class="n">scaled_avg</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">exclude_dark_regions</span><span class="p">:</span>
        <span class="n">histvals</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">scaled_avg</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">hv_deltas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">histvals</span><span class="p">)</span>
        <span class="c1"># TODO get the + 3 from a parameter controller percentage beyond</span>
        <span class="c1"># count delta min</span>
        <span class="c1"># min from: histvals[idx + 1] - histvals[idx]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">hv_deltas</span><span class="p">)</span>

        <span class="c1"># TODO if this method of calculating dark_thresh doesn&#39;t seem robust,</span>
        <span class="c1"># compare robustness to thresholds from percetile of overal image,</span>
        <span class="c1"># or fixed thresholds on image scaled to [0,1], or fixed fractional</span>
        <span class="c1"># adjustment from delta hist threshold</span>

        <span class="c1"># Originally, dark_thresh was from bins[idx + 4], and that seemed to</span>
        <span class="c1"># work OK, so on one image, I calculated initial value (~0.5 -&gt; 0.5)</span>
        <span class="c1"># of this from: ((scaled_avg &lt;= bins[idx + 4]).sum() -</span>
        <span class="c1"># (scaled_avg &lt;= bins[idx]).sum()) / scaled_avg.size (=0.543...)</span>
        <span class="c1">#dark_thresh = bins[idx + 4]</span>
        <span class="n">dh_min_fractile</span> <span class="o">=</span> <span class="p">(</span><span class="n">scaled_avg</span> <span class="o">&lt;=</span> <span class="n">bins</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">scaled_avg</span><span class="o">.</span><span class="n">size</span>
        <span class="n">dark_thresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">scaled_avg</span><span class="p">,</span>
            <span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="n">dark_fraction_beyond_dhist_min</span> <span class="o">+</span> <span class="n">dh_min_fractile</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">exclusion_mask</span> <span class="o">=</span> <span class="n">scaled_avg</span> <span class="o">&gt;=</span> <span class="n">dark_thresh</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">scaled_avg</span><span class="p">)</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">exclusion_mask</span><span class="p">)</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;exclusion mask&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">exclusion_mask</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># We enforce earlier that template must be symmetric.</span>
    <span class="n">d</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="n">d</span> <span class="o">==</span> <span class="n">d2</span>

    <span class="n">match_images</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">template_ds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">per_scale_radii_px</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">roi_diam_um</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">roi_diams_um</span><span class="p">):</span>
        <span class="n">scaled_template</span><span class="p">,</span> <span class="n">scaled_template_cell_diam_px</span> <span class="o">=</span> <span class="n">scale_template</span><span class="p">(</span>
            <span class="n">template_data</span><span class="p">,</span> <span class="n">um_per_pixel_xy</span><span class="p">,</span> <span class="n">roi_diam_um</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span>
        <span class="p">)</span>
        <span class="n">scaled_radius_px</span> <span class="o">=</span> <span class="n">scaled_template_cell_diam_px</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;scaled template shape:&#39;</span><span class="p">,</span> <span class="n">scaled_template</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">debug</span> <span class="ow">and</span> <span class="n">_show_scaled_templates</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">scaled_template</span><span class="p">)</span>
            <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;scaled template (roi_diam_um=</span><span class="si">{</span><span class="n">roi_diam_um</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">)&#39;</span>
            <span class="k">if</span> <span class="n">roi_diams_px</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">title</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">(roi_diam_px=</span><span class="si">{</span><span class="n">roi_diams_px</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s1">.1f</span><span class="si">}</span><span class="s1">)&#39;</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

        <span class="c1"># see note below about what i&#39;d need to do to continue using</span>
        <span class="c1"># a check like this</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        if template.shape != scaled_template.shape:</span>
<span class="sd">            # Just for checking that conversion back to original coordinates</span>
<span class="sd">            # (just scale diff) seems to be working.</span>
<span class="sd">            radius_px_before_scaling = int(round((d - 2 * margin) / 2))</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">match_image</span> <span class="o">=</span> <span class="n">template_match</span><span class="p">(</span><span class="n">scaled_avg</span><span class="p">,</span> <span class="n">scaled_template</span><span class="p">,</span>
            <span class="n">method_str</span><span class="o">=</span><span class="n">method_str</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;scaled_template_cell_diam_px: &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">scaled_template_cell_diam_px</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;scaled_radius_px: </span><span class="si">{</span><span class="n">scaled_radius_px</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">template_d</span> <span class="o">=</span> <span class="n">scaled_template</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">match_value_weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
            <span class="n">template_d2match_value_scale_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>

            <span class="n">match_value_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">template_d2match_value_scale_fn</span><span class="p">(</span><span class="n">template_d</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">match_images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">match_image</span><span class="p">)</span>
        <span class="n">template_ds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">template_d</span><span class="p">)</span>
        <span class="n">per_scale_radii_px</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scaled_radius_px</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;template_ds:&#39;</span><span class="p">,</span> <span class="n">template_ds</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">template_ds</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">template_ds</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_duplicate_px_scales</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;roi_diams_um: </span><span class="si">{</span><span class="n">roi_diams_um</span><span class="si">}</span><span class="s1"> led to duplicate &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;pixel template scales (</span><span class="si">{</span><span class="n">template_ds</span><span class="si">}</span><span class="s1">)&#39;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO would still probably have to de-duplicate before passing to</span>
            <span class="c1"># packing fn</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="c1"># TODO one fn that just returns circles, another to draw?</span>
    <span class="n">draw_on</span> <span class="o">=</span> <span class="n">scaled_avg</span>

    <span class="k">if</span> <span class="n">per_scale_max_n_rois</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">per_scale_min_n_rois</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">per_scale_max_n_rois</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">per_scale_max_n_rois</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_scales</span><span class="p">,</span> \
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">per_scale_max_n_rois</span><span class="p">)</span><span class="si">}</span><span class="s1"> != </span><span class="si">{</span><span class="n">n_scales</span><span class="si">}</span><span class="s1">&#39;</span>

        <span class="k">if</span> <span class="n">per_scale_min_n_rois</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">per_scale_min_n_rois</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_scales</span><span class="p">,</span> \
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">per_scale_min_n_rois</span><span class="p">)</span><span class="si">}</span><span class="s1"> != </span><span class="si">{</span><span class="n">n_scales</span><span class="si">}</span><span class="s1">&#39;</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Per-scale bounds on number of ROIs overriding global bounds.&#39;</span><span class="p">)</span>
        <span class="n">min_n_rois</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">max_n_rois</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">per_scale_n_roi_bounds</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">per_scale_n_roi_bounds</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">threshold_tries_remaining</span> <span class="o">=</span> <span class="n">max_threshold_tries</span>
    <span class="k">while</span> <span class="n">threshold_tries_remaining</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Regarding exclusion_radius_frac: 0.3 allowed too much overlap, 0.5</span>
        <span class="c1"># borderline too much w/ non-normed method (0.7 OK there)</span>
        <span class="c1"># (r=4,er=4,6 respectively, in 0.5 and 0.7 cases)</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;per_scale_radii_px:&#39;</span><span class="p">,</span> <span class="n">per_scale_radii_px</span><span class="p">)</span>

        <span class="n">centers_px</span><span class="p">,</span> <span class="n">radii_px</span> <span class="o">=</span> <span class="n">greedy_roi_packing</span><span class="p">(</span><span class="n">match_images</span><span class="p">,</span> <span class="n">template_ds</span><span class="p">,</span>
            <span class="n">per_scale_radii_px</span><span class="p">,</span> <span class="n">thresholds</span><span class="o">=</span><span class="n">thresholds</span><span class="p">,</span>
            <span class="n">min_neighbors</span><span class="o">=</span><span class="n">min_neighbors</span><span class="p">,</span> <span class="n">exclusion_mask</span><span class="o">=</span><span class="n">exclusion_mask</span><span class="p">,</span>
            <span class="n">exclusion_radius_frac</span><span class="o">=</span><span class="n">exclusion_radius_frac</span><span class="p">,</span> <span class="n">draw_on</span><span class="o">=</span><span class="n">draw_on</span><span class="p">,</span>
            <span class="n">draw_bboxes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">draw_nums</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">multiscale_strategy</span><span class="o">=</span><span class="n">multiscale_strategy</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">_packing_debug</span><span class="p">,</span>
            <span class="n">match_value_weights</span><span class="o">=</span><span class="n">match_value_weights</span><span class="p">,</span>
            <span class="n">_src_img_shape</span><span class="o">=</span><span class="n">scaled_avg</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="n">n_found_per_scale</span> <span class="o">=</span> <span class="p">{</span><span class="n">r_px</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">r_px</span> <span class="ow">in</span> <span class="n">per_scale_radii_px</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">r_px</span> <span class="ow">in</span> <span class="n">radii_px</span><span class="p">:</span>
            <span class="n">n_found_per_scale</span><span class="p">[</span><span class="n">r_px</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">centers_px</span><span class="p">)</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span><span class="n">n_found_per_scale</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;number of ROIs found at each pixel radius scale:&#39;</span><span class="p">)</span>
            <span class="n">pprint</span><span class="p">(</span><span class="n">n_found_per_scale</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">per_scale_n_roi_bounds</span><span class="p">:</span>
            <span class="n">wrong_num</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_scales</span><span class="p">):</span>
                <span class="n">r_px</span> <span class="o">=</span> <span class="n">per_scale_radii_px</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">thr</span> <span class="o">=</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">n_found</span> <span class="o">=</span> <span class="n">n_found_per_scale</span><span class="p">[</span><span class="n">r_px</span><span class="p">]</span>

                <span class="n">sstr</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39; w/ radius=</span><span class="si">{</span><span class="n">r_px</span><span class="si">}</span><span class="s1">px @ thr=</span><span class="si">{</span><span class="n">thr</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="n">have_retries</span> <span class="o">=</span> <span class="n">threshold_tries_remaining</span> <span class="o">&gt;</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">have_retries</span><span class="p">:</span>
                    <span class="n">sstr</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">thr:=</span><span class="se">{{</span><span class="s1">:.2f</span><span class="se">}}</span><span class="s1">&#39;</span>

                <span class="k">if</span> <span class="n">per_scale_max_n_rois</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">smax</span> <span class="o">=</span> <span class="n">per_scale_max_n_rois</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">smax</span> <span class="o">&lt;</span> <span class="n">n_found</span><span class="p">:</span>
                        <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">threshold_update_factor</span>
                        <span class="nb">print</span><span class="p">((</span><span class="sa">f</span><span class="s1">&#39;too many ROIs (</span><span class="si">{</span><span class="n">n_found</span><span class="si">}</span><span class="s1"> &gt; </span><span class="si">{</span><span class="n">smax</span><span class="si">}</span><span class="s1">)</span><span class="si">{</span><span class="n">sstr</span><span class="si">}</span><span class="s1">&#39;</span>
                            <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">thresholds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">have_retries</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">()</span>
                        <span class="p">))</span>
                        <span class="n">wrong_num</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="n">per_scale_min_n_rois</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">smin</span> <span class="o">=</span> <span class="n">per_scale_min_n_rois</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">n_found</span> <span class="o">&lt;</span> <span class="n">smin</span><span class="p">:</span>
                        <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">threshold_update_factor</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;too few ROIs (</span><span class="si">{</span><span class="n">n_found</span><span class="si">}</span><span class="s1"> &lt; </span><span class="si">{</span><span class="n">smin</span><span class="si">}</span><span class="s1">)</span><span class="si">{</span><span class="n">sstr</span><span class="si">}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">have_retries</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">()</span>
                        <span class="p">))</span>
                        <span class="n">wrong_num</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">wrong_num</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="n">n_rois_found</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">centers_px</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">per_scale_n_roi_bounds</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">min_n_rois</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">min_n_rois</span> <span class="o">&lt;=</span> <span class="n">n_rois_found</span><span class="p">)</span> <span class="ow">and</span>
                <span class="p">(</span><span class="n">max_n_rois</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">n_rois_found</span> <span class="o">&lt;=</span> <span class="n">max_n_rois</span><span class="p">)):</span>
                <span class="k">break</span>

        <span class="n">threshold_tries_remaining</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">threshold_tries_remaining</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">debug</span> <span class="ow">or</span> <span class="n">_packing_debug</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;too many/few (</span><span class="si">{</span><span class="n">n_rois_found</span><span class="si">}</span><span class="s1">) ROIs still &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;detected after </span><span class="si">{</span><span class="n">max_threshold_tries</span><span class="si">}</span><span class="s1"> attempts to modify &#39;</span>
                <span class="s1">&#39;threshold. try changing threshold(s)?&#39;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">per_scale_n_roi_bounds</span><span class="p">:</span>
            <span class="c1"># TODO maybe squeeze to threshold if just one</span>
            <span class="n">fail_notice_suffix</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;, with thresholds=</span><span class="si">{</span><span class="n">thresholds</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="k">if</span> <span class="n">max_n_rois</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">n_rois_found</span> <span class="o">&gt;</span> <span class="n">max_n_rois</span><span class="p">:</span>
                <span class="n">thresholds</span> <span class="o">/=</span> <span class="n">threshold_update_factor</span>
                <span class="n">fail_notice</span> <span class="o">=</span> \
                    <span class="sa">f</span><span class="s1">&#39;found too many ROIs (</span><span class="si">{</span><span class="n">n_rois_found</span><span class="si">}</span><span class="s1"> &gt; </span><span class="si">{</span><span class="n">max_n_rois</span><span class="si">}</span><span class="s1">)&#39;</span>

            <span class="k">elif</span> <span class="n">min_n_rois</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">n_rois_found</span> <span class="o">&lt;</span> <span class="n">min_n_rois</span><span class="p">:</span>
                <span class="n">thresholds</span> <span class="o">*=</span> <span class="n">threshold_update_factor</span>
                <span class="n">fail_notice</span> <span class="o">=</span> \
                    <span class="sa">f</span><span class="s1">&#39;found too few ROIs (</span><span class="si">{</span><span class="n">n_rois_found</span><span class="si">}</span><span class="s1"> &lt; </span><span class="si">{</span><span class="n">min_n_rois</span><span class="si">}</span><span class="s1">)&#39;</span>

            <span class="n">fail_notice</span> <span class="o">+=</span> <span class="n">fail_notice_suffix</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">fail_notice</span><span class="si">}</span><span class="se">\n\n</span><span class="s1">retrying with thresholds=</span><span class="si">{</span><span class="n">thresholds</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">update_factor_shrink_factor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">threshold_update_factor</span> <span class="o">=</span> \
                <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">threshold_update_factor</span><span class="p">)</span> <span class="o">*</span> <span class="n">update_factor_shrink_factor</span>

    <span class="k">if</span> <span class="n">frame_downscaling</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="c1"># TODO if i want to keep doing this check, while also supporting</span>
        <span class="c1"># multiscale case, gonna need to check (the set of?) radii returned</span>
        <span class="c1"># (would i need more info for that?)</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        # This is to invert any previous scaling into coordinates for matching</span>
<span class="sd">        radius_px = scaled_radius_px * frame_downscaling</span>

<span class="sd">        # always gonna be true? seems like if a frame were 7x7, converting size</span>
<span class="sd">        # down to say 2x2 and back up by same formula would yield same result</span>
<span class="sd">        # as a 6x6 input or something, no?</span>
<span class="sd">        assert radius_px == radius_px_before_scaling</span>
<span class="sd">        del radius_px_before_scaling</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">centers_px</span> <span class="o">=</span> <span class="n">centers_px</span> <span class="o">*</span> <span class="n">frame_downscaling</span>
        <span class="n">radii_px</span>  <span class="o">=</span> <span class="n">radii_px</span> <span class="o">*</span> <span class="n">frame_downscaling</span>

    <span class="c1"># TODO would some other (alternating?) rounding rule help?</span>
    <span class="c1"># TODO random seed then randomly choose between floor and ceil for stuff</span>
    <span class="c1"># at 0.5?</span>
    <span class="c1"># TODO TODO or is rounding wrong? do some tests to try to figure out</span>
    <span class="n">centers_px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">centers_px</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
    <span class="n">radii_px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">radii_px</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
    <span class="c1"># this work if centers is empty?</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">centers_px</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">centers_px</span> <span class="o">&lt;</span> <span class="n">orig_frame_d</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">show_fit</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plot_circles</span><span class="p">(</span><span class="n">avg</span><span class="p">,</span> <span class="n">centers_px</span><span class="p">,</span> <span class="n">radii_px</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tif</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;fit circles&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">tiff_title</span><span class="p">(</span><span class="n">tif</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

        <span class="n">roi_plot_dir</span> <span class="o">=</span> <span class="s1">&#39;auto_rois&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">roi_plot_dir</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;making directory </span><span class="si">{</span><span class="n">roi_plot_dir</span><span class="si">}</span><span class="s1"> for plots of ROI fits&#39;</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">roi_plot_dir</span><span class="p">)</span>

        <span class="n">roi_plot_fname</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">roi_plot_dir</span><span class="p">,</span> <span class="n">title</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span><span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.png&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Writing image showing fit ROIs to </span><span class="si">{</span><span class="n">roi_plot_fname</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">roi_plot_fname</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">write_ijrois</span><span class="p">:</span>
        <span class="n">auto_md_fname</span> <span class="o">=</span> <span class="n">autoroi_metadata_filename</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>

        <span class="n">name2bboxes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">center_px</span><span class="p">,</span> <span class="n">radius_px</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">centers_px</span><span class="p">,</span> <span class="n">radii_px</span><span class="p">)):</span>
            <span class="c1"># TODO TODO test that these radii are preserved across</span>
            <span class="c1"># round trip save / loads?</span>
            <span class="n">bbox</span> <span class="o">=</span> <span class="n">get_circle_ijroi_input</span><span class="p">(</span><span class="n">center_px</span><span class="p">,</span> <span class="n">radius_px</span><span class="p">)</span>
            <span class="n">name2bboxes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">bbox</span><span class="p">))</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Writing ImageJ ROIs to </span><span class="si">{}</span><span class="s1"> ...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
        <span class="c1"># TODO TODO TODO uncomment</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        ijroi.write_oval_roi_zip(name2bboxes, fname)</span>

<span class="sd">        with open(auto_md_fname, &#39;wb&#39;) as f:</span>
<span class="sd">            data = {</span>
<span class="sd">                &#39;mtime&#39;: getmtime(fname)</span>
<span class="sd">            }</span>
<span class="sd">            pickle.dump(data, f)</span>
<span class="sd">        &#39;&#39;&#39;</span>

    <span class="n">ns_found</span> <span class="o">=</span> <span class="p">[</span><span class="n">n_found_per_scale</span><span class="p">[</span><span class="n">rpx</span><span class="p">]</span> <span class="k">for</span> <span class="n">rpx</span> <span class="ow">in</span> <span class="n">per_scale_radii_px</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">centers_px</span><span class="p">,</span> <span class="n">radii_px</span><span class="p">,</span> <span class="n">thresholds</span><span class="p">,</span> <span class="n">ns_found</span></div>


<div class="viewcode-block" id="template_data_file"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.template_data_file">[docs]</a><span class="k">def</span> <span class="nf">template_data_file</span><span class="p">():</span>
    <span class="n">template_cache</span> <span class="o">=</span> <span class="s1">&#39;template.p&#39;</span>
    <span class="k">return</span> <span class="n">join</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">analysis_output_root</span><span class="p">(),</span> <span class="n">template_cache</span><span class="p">)</span></div>


<div class="viewcode-block" id="load_template_data"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.load_template_data">[docs]</a><span class="k">def</span> <span class="nf">load_template_data</span><span class="p">(</span><span class="n">err_if_missing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">template_cache</span> <span class="o">=</span> <span class="n">template_data_file</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">template_cache</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">template_cache</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">err_if_missing</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;template data not found at </span><span class="si">{</span><span class="n">template_cache</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<span class="c1"># TODO delete (+ probably delete contour2mask too and replace use of both w/ ijroi2mask)</span>
<span class="c1"># don&#39;t like this convexHull based approach though...</span>
<span class="c1"># (because roi may be intentionally not a convex hull)</span>
<div class="viewcode-block" id="ijroi2cv_contour"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.ijroi2cv_contour">[docs]</a><span class="k">def</span> <span class="nf">ijroi2cv_contour</span><span class="p">(</span><span class="n">roi</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">cv2</span>

    <span class="c1">## cnts = cv2.findContours(img, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span>
    <span class="c1">## cnts[1][0].shape</span>
    <span class="c1">## cnts[1][0].dtype</span>
    <span class="c1"># from inspecting output of findContours, as above:</span>
    <span class="c1">#cnt = np.expand_dims(ijroi, 1).astype(np.int32)</span>
    <span class="c1"># TODO fix so this isn&#39;t necessary. in case of rois that didn&#39;t start as</span>
    <span class="c1"># circles, the convexHull may occasionally not be equal to what i want</span>
    <span class="n">cnt</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">convexHull</span><span class="p">(</span><span class="n">roi</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>
    <span class="c1"># if only getting cnt from convexHull, this is probably a given...</span>
    <span class="k">assert</span> <span class="n">cv2</span><span class="o">.</span><span class="n">contourArea</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">cnt</span></div>
<span class="c1">#</span>


<div class="viewcode-block" id="roi_center"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.roi_center">[docs]</a><span class="k">def</span> <span class="nf">roi_center</span><span class="p">(</span><span class="n">roi</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">cv2</span>
    <span class="n">cnt</span> <span class="o">=</span> <span class="n">ijroi2cv_contour</span><span class="p">(</span><span class="n">roi</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">moments</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
    <span class="n">cx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;m10&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="s1">&#39;m00&#39;</span><span class="p">])</span>
    <span class="n">cy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">&#39;m01&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="s1">&#39;m00&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">))</span></div>


<div class="viewcode-block" id="roi_centers"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.roi_centers">[docs]</a><span class="k">def</span> <span class="nf">roi_centers</span><span class="p">(</span><span class="n">rois</span><span class="p">):</span>
    <span class="n">centers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">roi</span> <span class="ow">in</span> <span class="n">rois</span><span class="p">:</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">roi_center</span><span class="p">(</span><span class="n">roi</span><span class="p">)</span>
        <span class="c1"># pretty close to (w/in 0.5 in each dim) np.mean(roi, axis=0),</span>
        <span class="c1"># in at least one example i played with</span>
        <span class="n">centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span></div>


<div class="viewcode-block" id="point_idx"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.point_idx">[docs]</a><span class="k">def</span> <span class="nf">point_idx</span><span class="p">(</span><span class="n">xys_to_check</span><span class="p">,</span> <span class="n">pt_xy</span><span class="p">,</span> <span class="n">swap_xy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">swap_xy</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pt_xy</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">pt_xy</span>

    <span class="n">matching_pt</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">xys_to_check</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> <span class="o">&amp;</span>
        <span class="p">(</span><span class="n">xys_to_check</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">assert</span> <span class="n">matching_pt</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">matching_pt</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="correspond_rois"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.correspond_rois">[docs]</a><span class="k">def</span> <span class="nf">correspond_rois</span><span class="p">(</span><span class="n">left_centers_or_seq</span><span class="p">,</span> <span class="o">*</span><span class="n">right_centers</span><span class="p">,</span> <span class="n">cost_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">max_cost</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">write_plots</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">left_name</span><span class="o">=</span><span class="s1">&#39;Left&#39;</span><span class="p">,</span>
    <span class="n">right_name</span><span class="o">=</span><span class="s1">&#39;Right&#39;</span><span class="p">,</span> <span class="n">name_prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">draw_on</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">connect_centers</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pairwise_plots</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pairwise_same_style</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">roi_numbers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">jitter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug_points</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">    left_centers_or_seq (list): (length n_timepoints) list of (n_rois x 2)</span>
<span class="sd">        arrays of ROI center coordinates.</span>

<span class="sd">    Returns:</span>
<span class="sd">    lr_matches: list of arrays matching ROIs in one timepoint to ROIs in the</span>
<span class="sd">        next.</span>

<span class="sd">    left_unmatched: list of arrays with ROI labels at time t,</span>
<span class="sd">        without a match at time (t + 1)</span>

<span class="sd">    right_unmatched: same as left_unmatched, but for (t + 1) with respect to t.</span>

<span class="sd">    total_costs: array of sums of costs from matching.</span>

<span class="sd">    fig: matplotlib figure handle to the figure with all ROIs on it,</span>
<span class="sd">        for modification downstream.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO doc support for ROI inputs / rewrite to expect them</span>
    <span class="c1"># (to use jaccard, etc)</span>

    <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">linear_sum_assignment</span>
    <span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>

    <span class="k">if</span> <span class="n">cost_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># this was to avoid a circular import if it was in function definition</span>
        <span class="n">cost_fn</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">euclidean_dist</span>

    <span class="c1"># TODO maybe unsupport two args case to be more concise</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_centers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sequence_of_centers</span> <span class="o">=</span> <span class="n">left_centers_or_seq</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_centers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">right_centers</span> <span class="o">=</span> <span class="n">right_centers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sequence_of_centers</span> <span class="o">=</span> <span class="p">[</span><span class="n">left_centers_or_seq</span><span class="p">,</span> <span class="n">right_centers</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;wrong number of arguments&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">progress</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence_of_centers</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">10</span>
    <span class="k">if</span> <span class="n">progress</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>

    <span class="k">if</span> <span class="n">max_cost</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;max_cost must not be None&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;max_cost: </span><span class="si">{</span><span class="n">max_cost</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">default_two_colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence_of_centers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">pairwise_plots</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">scatter_alpha</span> <span class="o">=</span> <span class="mf">0.6</span>
        <span class="n">scatter_marker</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="s1">&#39; centers&#39;</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">(</span><span class="n">left_name</span><span class="p">,</span> <span class="n">right_name</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="n">default_two_colors</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">scatter_alpha</span> <span class="o">=</span> <span class="mf">0.8</span>
        <span class="n">scatter_marker</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">name_prefix</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sequence_of_centers</span><span class="p">))]</span>
        <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">color_palette</span><span class="p">(</span><span class="s1">&#39;hls&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence_of_centers</span><span class="p">))</span>

    <span class="c1"># TODO don&#39;t copy after removing need for flip</span>
    <span class="c1"># Copying so that flip doesn&#39;t screw with input data.</span>
    <span class="n">new_sequence_of_centers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">centers</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sequence_of_centers</span><span class="p">):</span>
        <span class="c1"># Otherwise it should be an ndarray representing centers</span>
        <span class="c1"># TODO assertion on dims in ndarray case</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">centers</span> <span class="o">=</span> <span class="n">roi_centers</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span>

        <span class="c1"># This is just to make them display right (not transposed).</span>
        <span class="c1"># Should not change any of the matching.</span>
        <span class="c1"># TODO remove need for this flip</span>
        <span class="n">new_sequence_of_centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">centers</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">sequence_of_centers</span> <span class="o">=</span> <span class="n">new_sequence_of_centers</span>

    <span class="n">fig</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
        <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">draw_on</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;black&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">draw_on</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
            <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;yellow&#39;</span>
        <span class="n">fontsize</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="n">text_x_offset</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">plot_format</span> <span class="o">=</span> <span class="s1">&#39;png&#39;</span>

        <span class="k">if</span> <span class="n">jitter</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
            <span class="n">jl</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.1</span>
            <span class="n">jh</span> <span class="o">=</span> <span class="mf">0.1</span>

    <span class="n">unmatched_left</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">unmatched_right</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">lr_matches</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cost_totals</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">progress</span><span class="p">:</span>
        <span class="n">centers_iter</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sequence_of_centers</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Matching ROIs across timepoints:&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">centers_iter</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sequence_of_centers</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ci</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">centers_iter</span><span class="p">):</span>
        <span class="n">left_centers</span> <span class="o">=</span> <span class="n">sequence_of_centers</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">right_centers</span> <span class="o">=</span> <span class="n">sequence_of_centers</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># TODO TODO use pdist / something else under scipy.spatial.distance?</span>
        <span class="c1"># TODO other / better ways to generate cost matrix?</span>
        <span class="c1"># pairwise jacard (would have to not take centers then)?</span>
        <span class="c1"># TODO why was there a &quot;RuntimeWarning: invalid valid encounterd in</span>
        <span class="c1"># multiply&quot; here ocassionally? it still seems like we had some left and</span>
        <span class="c1"># right centers, so idk</span>
        <span class="n">costs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">left_centers</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_centers</span><span class="p">)))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">left_centers</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">cr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">right_centers</span><span class="p">):</span>
                <span class="c1"># TODO short circuit as appropriate? better way to loop over</span>
                <span class="c1"># coords we need?</span>
                <span class="n">cost</span> <span class="o">=</span> <span class="n">cost_fn</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">cr</span><span class="p">)</span>
                <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&#39;(iteration {ci}) fraction of costs &gt;= max_cost:&#39;,</span>
<span class="sd">                &#39;{:.3f}&#39;.format((costs &gt;= max_cost).sum() / costs.size)</span>
<span class="sd">            )</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># TODO delete. problem does not seem to be in this fn.</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        if debug_points and ci in debug_points:</span>
<span class="sd">            print(f&#39;iteration {ci}:&#39;)</span>
<span class="sd">            ln = 3</span>
<span class="sd">            for pt_info in debug_points[ci]:</span>
<span class="sd">                name = pt_info[&#39;name&#39;]</span>
<span class="sd">                xy0 = pt_info[&#39;xy0&#39;]</span>
<span class="sd">                # TODO print cost wrt this point</span>
<span class="sd">                xy1 = pt_info[&#39;xy1&#39;]</span>

<span class="sd">                # swap_xy etc b/c of flip earlier</span>
<span class="sd">                idx = point_idx(left_centers, xy0, swap_xy=True)</span>
<span class="sd">                print(f&#39;lowest {ln} costs for point {name} in &#39;</span>
<span class="sd">                    &#39;left_centers:&#39;</span>
<span class="sd">                )</span>
<span class="sd">                # TODO also print to which other points (x,y)</span>
<span class="sd">                # correspond to these ln lowest costs</span>
<span class="sd">                print(np.sort(costs[idx, :])[:ln])</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># TODO TODO TODO test that setting these to an arbitrarily large number</span>
        <span class="c1"># produces matching equivalent to setting them to max_cost here</span>
        <span class="n">costs</span><span class="p">[</span><span class="n">costs</span> <span class="o">&gt;=</span> <span class="n">max_cost</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_cost</span>

        <span class="c1"># TODO was Kellan&#39;s method of matching points not equivalent to this?</span>
        <span class="c1"># or per-timestep maybe it was (or this was better), but he also</span>
        <span class="c1"># had a way to evolve points over time (+ a particular cost)?</span>

        <span class="n">left_idx</span><span class="p">,</span> <span class="n">right_idx</span> <span class="o">=</span> <span class="n">linear_sum_assignment</span><span class="p">(</span><span class="n">costs</span><span class="p">)</span>
        <span class="c1"># Just to double-check properties I assume about the assignment</span>
        <span class="c1"># procedure.</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_idx</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">left_idx</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_idx</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">right_idx</span><span class="p">))</span>

        <span class="n">n_not_drawn</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">jitter</span><span class="p">:</span>
                <span class="n">left_jitter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">jl</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">jh</span><span class="p">,</span>
                    <span class="n">size</span><span class="o">=</span><span class="n">left_centers</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">right_jitter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">jl</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">jh</span><span class="p">,</span>
                    <span class="n">size</span><span class="o">=</span><span class="n">right_centers</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

                <span class="n">left_centers_to_plot</span> <span class="o">=</span> <span class="n">left_centers</span> <span class="o">+</span> <span class="n">left_jitter</span>
                <span class="n">right_centers_to_plot</span> <span class="o">=</span> <span class="n">right_centers</span> <span class="o">+</span> <span class="n">right_jitter</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">left_centers_to_plot</span> <span class="o">=</span> <span class="n">left_centers</span>
                <span class="n">right_centers_to_plot</span> <span class="o">=</span> <span class="n">right_centers</span>

            <span class="k">if</span> <span class="n">pairwise_plots</span><span class="p">:</span>
                <span class="c1"># TODO maybe change multiple pairwise plots to be created as</span>
                <span class="c1"># axes within one the axes from one call to subplots</span>
                <span class="n">pfig</span><span class="p">,</span> <span class="n">pax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pairwise_same_style</span><span class="p">:</span>
                    <span class="n">pmarker</span> <span class="o">=</span> <span class="n">scatter_marker</span>
                    <span class="n">c1</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">c2</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pmarker</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">c1</span> <span class="o">=</span> <span class="n">default_two_colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">c2</span> <span class="o">=</span> <span class="n">default_two_colors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">draw_on</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">pax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">draw_on</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
                    <span class="n">pax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

                <span class="n">pax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="o">*</span><span class="n">left_centers_to_plot</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">labels</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">c1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">scatter_alpha</span><span class="p">,</span>
                    <span class="n">marker</span><span class="o">=</span><span class="n">pmarker</span>
                <span class="p">)</span>
                <span class="n">pax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="o">*</span><span class="n">right_centers_to_plot</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">labels</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">c2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">scatter_alpha</span><span class="p">,</span>
                    <span class="n">marker</span><span class="o">=</span><span class="n">pmarker</span>
                <span class="p">)</span>
                <span class="n">psuffix</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1"> vs. </span><span class="si">{</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">name_prefix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">psuffix</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name_prefix</span><span class="si">}</span><span class="s1"> &#39;</span> <span class="o">+</span> <span class="n">psuffix</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">title</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ptitle</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">title</span><span class="si">}</span><span class="s1">, &#39;</span> <span class="o">+</span> <span class="n">psuffix</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ptitle</span> <span class="o">=</span> <span class="n">psuffix</span>
                <span class="n">pax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">ptitle</span><span class="p">)</span>
                <span class="n">pax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="o">*</span><span class="n">left_centers_to_plot</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">labels</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="n">scatter_alpha</span><span class="p">,</span>
                <span class="n">marker</span><span class="o">=</span><span class="n">scatter_marker</span>
            <span class="p">)</span>
            <span class="c1"># TODO factor out scatter + opt numbers (internal fn?)</span>
            <span class="k">if</span> <span class="n">roi_numbers</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">left_centers_to_plot</span><span class="p">):</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">text_x_offset</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span>
                    <span class="p">)</span>

            <span class="c1"># Because generally this loop only scatterplots the left_centers,</span>
            <span class="c1"># so without this, the last set of centers would not get a</span>
            <span class="c1"># scatterplot.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sequence_of_centers</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">last_centers</span> <span class="o">=</span> <span class="n">right_centers_to_plot</span>

                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="o">*</span><span class="n">last_centers</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">labels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="n">scatter_alpha</span><span class="p">,</span>
                    <span class="n">marker</span><span class="o">=</span><span class="n">scatter_marker</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">roi_numbers</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">last_centers</span><span class="p">):</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">text_x_offset</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                            <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span>
                        <span class="p">)</span>

            <span class="k">if</span> <span class="n">connect_centers</span><span class="p">:</span>
                <span class="n">n_not_drawn</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">li</span><span class="p">,</span> <span class="n">ri</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">left_idx</span><span class="p">,</span> <span class="n">right_idx</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">costs</span><span class="p">[</span><span class="n">li</span><span class="p">,</span><span class="n">ri</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">max_cost</span><span class="p">:</span>
                        <span class="n">n_not_drawn</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">continue</span>
                        <span class="c1">#linestyle = &#39;--&#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">linestyle</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>

                    <span class="n">lc</span> <span class="o">=</span> <span class="n">left_centers_to_plot</span><span class="p">[</span><span class="n">li</span><span class="p">]</span>
                    <span class="n">rc</span> <span class="o">=</span> <span class="n">right_centers_to_plot</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span>
                    <span class="n">correspondence_line</span> <span class="o">=</span> <span class="p">([</span><span class="n">lc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rc</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">lc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rc</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">correspondence_line</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="n">linestyle</span><span class="p">,</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">pairwise_plots</span><span class="p">:</span>
                        <span class="n">pax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">correspondence_line</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="n">linestyle</span><span class="p">,</span>
                            <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

                <span class="c1"># TODO didn&#39;t i have some fn for getting filenames from things</span>
                <span class="c1"># like titles? use that if so</span>
                <span class="c1"># TODO plot format + flag to control saving + save to some</span>
                <span class="c1"># better dir</span>
                <span class="c1"># TODO separate dir for these figs? or at least place where some</span>
                <span class="c1"># of other figs currently go?</span>
                <span class="k">if</span> <span class="n">pairwise_plots</span> <span class="ow">and</span> <span class="n">write_plots</span><span class="p">:</span>
                    <span class="n">fname</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">to_filename</span><span class="p">(</span><span class="n">ptitle</span><span class="p">)</span> <span class="o">+</span> <span class="n">plot_format</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;writing to </span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">pfig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>

        <span class="n">k_unmatched_left</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">left_centers</span><span class="p">)))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">left_idx</span><span class="p">)</span>
        <span class="n">k_unmatched_right</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">right_centers</span><span class="p">)))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">right_idx</span><span class="p">)</span>

        <span class="c1"># TODO why is costs.min() actually 0? that seems unlikely?</span>
        <span class="n">match_costs</span> <span class="o">=</span> <span class="n">costs</span><span class="p">[</span><span class="n">left_idx</span><span class="p">,</span> <span class="n">right_idx</span><span class="p">]</span>
        <span class="n">total_cost</span> <span class="o">=</span> <span class="n">match_costs</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="n">to_unmatch</span> <span class="o">=</span> <span class="n">match_costs</span> <span class="o">&gt;=</span> <span class="n">max_cost</span>
        <span class="c1"># For checking consistent w/ draw output above</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">n_not_drawn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n_unmatched</span> <span class="o">=</span> <span class="n">to_unmatch</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">n_not_drawn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">n_not_drawn</span> <span class="o">==</span> <span class="n">n_unmatched</span><span class="p">,</span> \
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">n_not_drawn</span><span class="si">}</span><span class="s1"> != </span><span class="si">{</span><span class="n">n_unmatched</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;(iteration=</span><span class="si">{</span><span class="n">ci</span><span class="si">}</span><span class="s1">) unmatched </span><span class="si">{</span><span class="n">n_unmatched</span><span class="si">}</span><span class="s1"> for exceeding&#39;</span>
                    <span class="s1">&#39; max_cost&#39;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">debug_points</span> <span class="ow">and</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">debug_points</span><span class="p">:</span>
            <span class="n">l_idxs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">r_idxs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">pt_info</span> <span class="ow">in</span> <span class="n">debug_points</span><span class="p">[</span><span class="n">ci</span><span class="p">]:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">pt_info</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
                <span class="c1"># swap_xy etc b/c of flip earlier</span>
                <span class="n">xy0</span> <span class="o">=</span> <span class="n">pt_info</span><span class="p">[</span><span class="s1">&#39;xy0&#39;</span><span class="p">]</span>
                <span class="n">xy1</span> <span class="o">=</span> <span class="n">pt_info</span><span class="p">[</span><span class="s1">&#39;xy1&#39;</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;name: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">, xy0: </span><span class="si">{</span><span class="n">xy0</span><span class="si">}</span><span class="s1">, xy1: </span><span class="si">{</span><span class="n">xy1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="n">lidx</span> <span class="o">=</span> <span class="n">point_idx</span><span class="p">(</span><span class="n">left_centers</span><span class="p">,</span> <span class="n">xy0</span><span class="p">,</span> <span class="n">swap_xy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">left_idx</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_centers</span><span class="p">)</span>

                <span class="n">midx0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">left_idx</span> <span class="o">==</span> <span class="n">lidx</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">midx0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">midx0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                    <span class="n">midx0</span> <span class="o">=</span> <span class="n">midx0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">assert</span> <span class="n">left_idx</span><span class="p">[</span><span class="n">midx0</span><span class="p">]</span> <span class="o">==</span> <span class="n">lidx</span>
                    <span class="n">lpt</span> <span class="o">=</span> <span class="n">left_centers</span><span class="p">[</span><span class="n">left_idx</span><span class="p">[</span><span class="n">midx0</span><span class="p">]]</span>
                    <span class="k">assert</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lpt</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">xy0</span>
                    <span class="c1"># since by the time debug_points are generated, point</span>
                    <span class="c1"># matching seems off, rpt will not necessarily be</span>
                    <span class="c1"># equal to lpt.</span>
                    <span class="n">rpt_idx</span> <span class="o">=</span> <span class="n">right_idx</span><span class="p">[</span><span class="n">midx0</span><span class="p">]</span>
                    <span class="n">rpt</span> <span class="o">=</span> <span class="n">right_centers</span><span class="p">[</span><span class="n">rpt_idx</span><span class="p">]</span>
                    <span class="n">mcost0</span> <span class="o">=</span> <span class="n">match_costs</span><span class="p">[</span><span class="n">midx0</span><span class="p">]</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;xy0 matched (</span><span class="si">{</span><span class="n">lidx</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">lpt</span><span class="si">}</span><span class="s1"> -&gt; </span><span class="si">{</span><span class="n">rpt_idx</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">rpt</span><span class="si">}</span><span class="s1">) &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;at cost </span><span class="si">{</span><span class="n">mcost0</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">to_unmatch</span><span class="p">[</span><span class="n">midx0</span><span class="p">]:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;xy0 will be unmatched for cost &gt;= max_cost!&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">l_idxs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">lidx</span><span class="p">))</span>
                        <span class="c1"># For use debugging downstream of this function.</span>
                        <span class="n">pt_info</span><span class="p">[</span><span class="s1">&#39;xy0_lidx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lidx</span>
                        <span class="n">pt_info</span><span class="p">[</span><span class="s1">&#39;xy0_ridx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rpt_idx</span>
                        <span class="n">pt_info</span><span class="p">[</span><span class="s1">&#39;xy0_lpt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lpt</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">pt_info</span><span class="p">[</span><span class="s1">&#39;xy0_rpt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rpt</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;xy0 not matched!&#39;</span><span class="p">)</span>

                <span class="n">ridx</span> <span class="o">=</span> <span class="n">point_idx</span><span class="p">(</span><span class="n">right_centers</span><span class="p">,</span> <span class="n">xy1</span><span class="p">,</span> <span class="n">swap_xy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">right_idx</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_centers</span><span class="p">)</span>
                <span class="n">midx1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">right_idx</span> <span class="o">==</span> <span class="n">ridx</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">midx1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">midx1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                    <span class="n">midx1</span> <span class="o">=</span> <span class="n">midx1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">assert</span> <span class="n">right_idx</span><span class="p">[</span><span class="n">midx1</span><span class="p">]</span> <span class="o">==</span> <span class="n">ridx</span>
                    <span class="n">rpt</span> <span class="o">=</span> <span class="n">right_centers</span><span class="p">[</span><span class="n">right_idx</span><span class="p">[</span><span class="n">midx1</span><span class="p">]]</span>
                    <span class="k">assert</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rpt</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">xy1</span>
                    <span class="c1"># likewise, this is not necessarily equal to xy0, by the</span>
                    <span class="c1"># time downstream functions screw up propagating the matches</span>
                    <span class="n">lpt_idx</span> <span class="o">=</span> <span class="n">left_idx</span><span class="p">[</span><span class="n">midx1</span><span class="p">]</span>
                    <span class="n">lpt</span> <span class="o">=</span> <span class="n">left_centers</span><span class="p">[</span><span class="n">lpt_idx</span><span class="p">]</span>
                    <span class="n">mcost1</span> <span class="o">=</span> <span class="n">match_costs</span><span class="p">[</span><span class="n">midx1</span><span class="p">]</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;xy1 matched (</span><span class="si">{</span><span class="n">ridx</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">rpt</span><span class="si">}</span><span class="s1"> &lt;- </span><span class="si">{</span><span class="n">lpt_idx</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">lpt</span><span class="si">}</span><span class="s1">) &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;at cost </span><span class="si">{</span><span class="n">mcost1</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">to_unmatch</span><span class="p">[</span><span class="n">midx1</span><span class="p">]:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;xy1 will be unmatched for cost &gt;= max_cost!&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">r_idxs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">ridx</span><span class="p">))</span>
                        <span class="c1"># For use debugging downstream of this function.</span>
                        <span class="n">pt_info</span><span class="p">[</span><span class="s1">&#39;xy1_lidx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lpt_idx</span>
                        <span class="n">pt_info</span><span class="p">[</span><span class="s1">&#39;xy1_ridx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ridx</span>
                        <span class="n">pt_info</span><span class="p">[</span><span class="s1">&#39;xy1_lpt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lpt</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">pt_info</span><span class="p">[</span><span class="s1">&#39;xy1_rpt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rpt</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;xy1 not matched!&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="n">k_unmatched_left</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">left_idx</span><span class="p">[</span><span class="n">to_unmatch</span><span class="p">])</span>
        <span class="n">k_unmatched_right</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">right_idx</span><span class="p">[</span><span class="n">to_unmatch</span><span class="p">])</span>
        <span class="n">left_idx</span> <span class="o">=</span> <span class="n">left_idx</span><span class="p">[</span><span class="o">~</span> <span class="n">to_unmatch</span><span class="p">]</span>
        <span class="n">right_idx</span> <span class="o">=</span> <span class="n">right_idx</span><span class="p">[</span><span class="o">~</span> <span class="n">to_unmatch</span><span class="p">]</span>

        <span class="n">n_unassigned</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">left_centers</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_centers</span><span class="p">))</span>

        <span class="n">total_cost</span> <span class="o">+=</span> <span class="n">max_cost</span> <span class="o">*</span> <span class="n">n_unassigned</span>
        <span class="c1"># TODO better way to normalize error?</span>
        <span class="n">total_cost</span> <span class="o">=</span> <span class="n">total_cost</span> <span class="o">/</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">left_centers</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_centers</span><span class="p">))</span>

        <span class="c1"># TODO maybe compute costs for all unmatched w/ pdist, and check</span>
        <span class="c1"># nothing is &lt; max_cost</span>

        <span class="n">unmatched_left</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">k_unmatched_left</span><span class="p">)))</span>
        <span class="n">unmatched_right</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">k_unmatched_right</span><span class="p">)))</span>
        <span class="n">cost_totals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">total_cost</span><span class="p">)</span>
        <span class="n">lr_matches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">left_idx</span><span class="p">,</span> <span class="n">right_idx</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># These just need to be consistent w/ numbers printed before colons</span>
        <span class="c1"># above (and they are).</span>
        <span class="k">if</span> <span class="n">debug_points</span> <span class="ow">and</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">debug_points</span><span class="p">:</span>
            <span class="n">lrm</span> <span class="o">=</span> <span class="n">lr_matches</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">li</span> <span class="ow">in</span> <span class="n">l_idxs</span><span class="p">:</span>
                <span class="n">midx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">lrm</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">li</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">midx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">midx</span> <span class="o">=</span> <span class="n">midx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;name: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">, xy0 match row </span><span class="si">{</span><span class="n">midx</span><span class="si">}</span><span class="s1">:&#39;</span><span class="p">,</span> <span class="n">lrm</span><span class="p">[</span><span class="n">midx</span><span class="p">,</span> <span class="p">:])</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">ri</span> <span class="ow">in</span> <span class="n">r_idxs</span><span class="p">:</span>
                <span class="n">midx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">lrm</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">ri</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">midx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">midx</span> <span class="o">=</span> <span class="n">midx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;name: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">, xy1 match row </span><span class="si">{</span><span class="n">midx</span><span class="si">}</span><span class="s1">:&#39;</span><span class="p">,</span> <span class="n">lrm</span><span class="p">[</span><span class="n">midx</span><span class="p">,</span> <span class="p">:])</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">write_plots</span><span class="p">:</span>
            <span class="c1"># TODO and delete this extra hack</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence_of_centers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">extra</span> <span class="o">=</span> <span class="s1">&#39;_acrossblocks&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">extra</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">to_filename</span><span class="p">(</span><span class="n">title</span> <span class="o">+</span> <span class="n">extra</span><span class="p">)</span> <span class="o">+</span> <span class="n">plot_format</span>
            <span class="c1">#</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;writing to </span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="c1">#</span>

    <span class="c1"># TODO TODO change all parts that require squeeze=True to squeeze=False?</span>
    <span class="k">if</span> <span class="n">squeeze</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence_of_centers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">lr_matches</span> <span class="o">=</span> <span class="n">lr_matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">unmatched_left</span> <span class="o">=</span> <span class="n">unmatched_left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">unmatched_right</span> <span class="o">=</span> <span class="n">unmatched_right</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cost_totals</span> <span class="o">=</span> <span class="n">cost_totals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># TODO maybe stop returning unmatched_* . not sure it&#39;s useful.</span>

    <span class="k">return</span> <span class="n">lr_matches</span><span class="p">,</span> <span class="n">unmatched_left</span><span class="p">,</span> <span class="n">unmatched_right</span><span class="p">,</span> <span class="n">cost_totals</span><span class="p">,</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="stable_rois"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.stable_rois">[docs]</a><span class="k">def</span> <span class="nf">stable_rois</span><span class="p">(</span><span class="n">lr_matches</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a list of n_cells x 2 matrices, with each row taking an integer ROI</span>
<span class="sd">    label from one set of labels to the other.</span>

<span class="sd">    Input is as first output of correspond_rois.</span>

<span class="sd">    Returns:</span>
<span class="sd">    stable_cells: a n_stable_cells x (len(lr_matches) + 1) matrix, where rows</span>
<span class="sd">        represent different labels for the same real cells. Columns have the</span>
<span class="sd">        set of stable cells IDs, labelled as the inputs are.</span>

<span class="sd">    new_lost: a (len(lr_matches) - 1) length list of IDs lost when matching</span>
<span class="sd">        lr_matches[i] to lr_matches[i + 1]. only considers IDs that had</span>
<span class="sd">        been stable across all previous pairs of matchings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO TODO also test in cases where lr_matches is greater than len 2</span>
    <span class="c1"># (at least len 3)</span>

    <span class="c1"># TODO TODO also test when lr_matches is len 1, to support that case</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lr_matches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">lr_matches</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="n">orig_matches</span> <span class="o">=</span> <span class="n">lr_matches</span>
    <span class="c1"># Just since it gets written to in the loop.</span>
    <span class="n">lr_matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">lr_matches</span><span class="p">]</span>

    <span class="n">stable</span> <span class="o">=</span> <span class="n">lr_matches</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">UNLABELLED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">new_lost</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lr_matches</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">matches1</span> <span class="o">=</span> <span class="n">lr_matches</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">matches2</span> <span class="o">=</span> <span class="n">lr_matches</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># These two columns should have the ROI / center numbers</span>
        <span class="c1"># represent the same real ROI / point coordinates.</span>
        <span class="n">stable_1to2</span><span class="p">,</span> <span class="n">m1_idx</span><span class="p">,</span> <span class="n">m2_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span>
            <span class="n">matches1</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">matches2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">matches1</span><span class="p">[</span><span class="n">m1_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">matches2</span><span class="p">[</span><span class="n">m2_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="n">curr_stable_prior_labels</span> <span class="o">=</span> <span class="n">matches1</span><span class="p">[</span><span class="n">m1_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">matches2</span><span class="p">[</span><span class="n">m2_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_stable_prior_labels</span>

        <span class="c1"># To avoid confusion / errors related too using old, now meaningless</span>
        <span class="c1"># labels.</span>
        <span class="n">not_in_m2_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matches2</span><span class="p">)),</span> <span class="n">m2_idx</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">lr_matches</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">UNLABELLED</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="n">matches2</span><span class="p">[</span><span class="n">not_in_m2_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">UNLABELLED</span> 
        <span class="k">assert</span> <span class="p">(</span><span class="n">lr_matches</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">UNLABELLED</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">not_in_m2_idx</span><span class="p">)</span>

        <span class="n">ids_lost_at_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">stable</span><span class="p">,</span> <span class="n">curr_stable_prior_labels</span><span class="p">)</span>
        <span class="n">stable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">stable</span><span class="p">,</span> <span class="n">ids_lost_at_i</span><span class="p">)</span>
        <span class="n">new_lost</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ids_lost_at_i</span><span class="p">)</span>

        <span class="n">n_lost_at_i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids_lost_at_i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">n_lost_at_i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Lost </span><span class="si">{</span><span class="n">n_lost_at_i</span><span class="si">}</span><span class="s1"> ROI(s) between blocks </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> and </span><span class="si">{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># TODO make a test case where the total number of *matched* rois is</span>
    <span class="c1"># conserved at each time step, but the matching makes the length of the</span>
    <span class="c1"># ultimate stable set reduce</span>
    <span class="n">n_matched</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">-</span> <span class="p">((</span><span class="n">m</span> <span class="o">==</span> <span class="n">UNLABELLED</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">lr_matches</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">stable</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_matched</span><span class="p">)</span>

    <span class="n">stable_cells</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">matches</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lr_matches</span><span class="p">):</span>
        <span class="c1"># Because each of these columns will have been edited in the loop</span>
        <span class="c1"># above, to have labels matching the first set of center labels.</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">stable_indices_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">stable</span><span class="p">,</span> <span class="n">matches</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">assert</span> <span class="ow">not</span> <span class="n">UNLABELLED</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">[</span><span class="n">stable_indices_i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">orig_labels_stable_i</span> <span class="o">=</span> <span class="n">orig_matches</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">stable_indices_i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">stable_cells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">orig_labels_stable_i</span><span class="p">)</span>

    <span class="c1"># This last column in the last element in the last of matches</span>
    <span class="c1"># was the only column that did NOT get painted over with the new labels.</span>
    <span class="n">stable_cells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matches</span><span class="p">[</span><span class="n">stable_indices_i</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">stable_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">stable_cells</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># might be redundant...</span>
    <span class="n">stable_cells</span> <span class="o">=</span> <span class="n">stable_cells</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">stable_cells</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span> <span class="p">:]</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">stable_cells</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">stable</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">stable_cells</span><span class="p">,</span> <span class="n">new_lost</span></div>


<span class="c1"># TODO try to numba this</span>
<div class="viewcode-block" id="renumber_rois2"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.renumber_rois2">[docs]</a><span class="k">def</span> <span class="nf">renumber_rois2</span><span class="p">(</span><span class="n">matches_list</span><span class="p">,</span> <span class="n">centers_list</span><span class="p">):</span>
    <span class="n">id2frame_bounds</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">id2indices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">next_id</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">seen_at_i</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matches_list</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen_at_i</span><span class="p">:</span>
            <span class="n">seen_at_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">matches_list</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches_list</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">left</span> <span class="ow">in</span> <span class="n">seen_at_i</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="n">seen_at_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
                <span class="n">roi_indices_across_frames</span> <span class="o">=</span> <span class="p">[</span><span class="n">left</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">right</span> <span class="ow">in</span> <span class="n">seen_at_i</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="n">roi_indices_across_frames</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">first_frame</span> <span class="o">=</span> <span class="n">i</span>
            <span class="c1"># So that the frame counter increments as soon as we have one</span>
            <span class="c1"># &quot;right&quot; element (every match row must correspond to at least</span>
            <span class="c1"># two timepoints).</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches_list</span><span class="p">):</span>
                <span class="n">roi_indices_across_frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
                <span class="n">last_frame</span> <span class="o">=</span> <span class="n">j</span>

                <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">seen_at_i</span><span class="p">:</span>
                    <span class="n">seen_at_i</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">seen_at_i</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches_list</span><span class="p">):</span>
                    <span class="k">break</span>

                <span class="n">next_matches</span> <span class="o">=</span> <span class="n">matches_list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">next_row_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">next_matches</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">next_row_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="n">next_row_idx</span> <span class="o">=</span> <span class="n">next_row_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">next_matches</span><span class="p">[</span><span class="n">next_row_idx</span><span class="p">]</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">assert</span> <span class="p">(</span><span class="n">last_frame</span> <span class="o">-</span> <span class="n">first_frame</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">roi_indices_across_frames</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">id2frame_bounds</span><span class="p">[</span><span class="n">next_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_frame</span><span class="p">,</span> <span class="n">last_frame</span><span class="p">)</span>
            <span class="n">id2indices</span><span class="p">[</span><span class="n">next_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">roi_indices_across_frames</span>
            <span class="n">next_id</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches_list</span><span class="p">):</span>
            <span class="n">unmatched</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">centers_list</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span> <span class="n">m</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unmatched</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">centers_list</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span> <span class="n">m</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">unmatched</span><span class="p">:</span>
            <span class="c1"># TODO never need to check whether this is in seen, do i?</span>
            <span class="n">id2frame_bounds</span><span class="p">[</span><span class="n">next_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">id2indices</span><span class="p">[</span><span class="n">next_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span><span class="p">]</span>
            <span class="n">next_id</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">id2frame_bounds</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">id2indices</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">centers_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">centers_list</span><span class="p">),</span> <span class="n">next_id</span><span class="p">,</span>
        <span class="n">centers_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">for</span> <span class="n">roi_id</span> <span class="ow">in</span> <span class="n">id2frame_bounds</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">id2frame_bounds</span><span class="p">[</span><span class="n">roi_id</span><span class="p">]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">id2indices</span><span class="p">[</span><span class="n">roi_id</span><span class="p">]</span>
        <span class="n">centers_array</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">roi_id</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> \
            <span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">centers_list</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">indices</span><span class="p">)]</span>

    <span class="c1"># TODO assert min / max non-nan cover full frame for reasonable test data</span>

    <span class="k">return</span> <span class="n">centers_array</span></div>


<span class="c1"># TODO TODO should either this fn or correspond_rois try to handle the case</span>
<span class="c1"># where a cell drifts out of plane and then back into plane???</span>
<span class="c1"># possible? some kind of filtering?</span>
<div class="viewcode-block" id="renumber_rois"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.renumber_rois">[docs]</a><span class="k">def</span> <span class="nf">renumber_rois</span><span class="p">(</span><span class="n">matches_list</span><span class="p">,</span> <span class="n">centers_list</span><span class="p">,</span> <span class="n">debug_points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_cost</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Each sequence of matched ROIs gets an increasing integer identifier</span>
<span class="sd">    (including length-1 sequences, i.e. unmatched stuff).</span>

<span class="sd">    Returns lists of IDs in each element of input list and centers,</span>
<span class="sd">    re-indexed with new IDs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO use this function inside stable_rois / delete that function</span>
    <span class="c1"># altogether (?)</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">matches_list</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">centers_list</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;both input arguments must be lists&#39;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">centers_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches_list</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Since they get written to in the loop.</span>
    <span class="n">matches_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">matches_list</span><span class="p">]</span>
    <span class="n">centers_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">centers_list</span><span class="p">]</span>

    <span class="c1"># TODO test case where input is not == np.arange(input.max())</span>
    <span class="c1"># (both just missing some less and w/ ids beyond len(centers) - 1)</span>
    <span class="n">ids_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">first_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">centers_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">matches_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">first_ids</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="n">ids_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">first_ids</span><span class="p">)</span>
    <span class="n">next_new_id</span> <span class="o">=</span> <span class="n">first_ids</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;next_new_id (after making first_ids):&#39;</span><span class="p">,</span> <span class="n">next_new_id</span><span class="p">)</span>
    <span class="c1">##next_new_id = matches_list[0][:,0].max() + 1</span>

    <span class="c1">#if len(centers_list[0]) &gt; len(matches_list[0]):</span>
    <span class="c1">#    import ipdb; ipdb.set_trace()</span>

    <span class="c1"># TODO delete / put behind something like a `checks` flag</span>
    <span class="k">assert</span> <span class="n">max_cost</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="n">id2last_xy</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">c</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">first_ids</span><span class="p">,</span> <span class="n">centers_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,:</span><span class="mi">2</span><span class="p">])}</span>
    <span class="n">id2src_history</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span>
        <span class="p">[</span><span class="s1">&#39;first_match&#39;</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">matches_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="s1">&#39;new_first&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">first_ids</span>
    <span class="p">}</span>
    <span class="n">id2idx_history</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">first_ids</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">matches_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">id2idx_history</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">id2src_history</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">id2idx_history</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">nonshared_m2_idx_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matches_list</span><span class="p">)):</span>
        <span class="c1"># These centers are referred to by the IDs in matches_list[i + 1][:, 1],</span>
        <span class="c1"># and (if it exists) matches_list[i + 2][:, 1]</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="n">centers_list</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">matches1</span> <span class="o">=</span> <span class="n">matches_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        # This includes stuff shared and stuff lost by m2.</span>
<span class="sd">        # The only thing this should not include is stuff that should get</span>
<span class="sd">        # a new ID in m2.</span>
<span class="sd">        centers_in_m1 = matches1[:, 1]</span>

<span class="sd">        # These include both things in matches2 (those not shared with matches1)</span>
<span class="sd">        # and things we need to generate new IDs for.</span>
<span class="sd">        only_new_centers_idx = np.setdiff1d(</span>
<span class="sd">            np.arange(len(centers)),</span>
<span class="sd">            centers_in_m1</span>
<span class="sd">        )</span>
<span class="sd">        # This should be of the same length as centers and should index each</span>
<span class="sd">        # value, just in a different order.</span>
<span class="sd">        new_center_idx = np.concatenate((</span>
<span class="sd">            centers_in_m1,</span>
<span class="sd">            only_new_centers_idx</span>
<span class="sd">        ))</span>
<span class="sd">        assert np.array_equal(</span>
<span class="sd">            np.arange(len(centers)),</span>
<span class="sd">            np.unique(new_center_idx)</span>
<span class="sd">        )</span>

<span class="sd">        # We are re-ordering the centers, so that they are in the same order</span>
<span class="sd">        # as the IDs (both propagated and new) at this timestep (curr_ids).</span>
<span class="sd">        centers_list[i + 1] = centers[new_center_idx]</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># TODO TODO TODO i think this is the heart of the problem</span>
        <span class="c1"># (b/c all problem indices were in the new_ids that got cut off</span>
        <span class="c1"># when trying to fit into smaller space of nonshared_m2_idx</span>
        <span class="n">existing_ids</span> <span class="o">=</span> <span class="n">matches1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c1">#next_new_id = existing_ids.max() + 1</span>
        <span class="c1">###n_new_ids = len(only_new_centers_idx)</span>
        <span class="c1">##assert len(centers) - len(matches1) == n_new_ids</span>
        <span class="n">n_new_ids</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches1</span><span class="p">)</span>
        <span class="c1"># Not + 1 because arange does not include the endpoint.</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">next_new_id</span> <span class="o">+</span> <span class="n">n_new_ids</span>
        <span class="n">new_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">next_new_id</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ids_list</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="nb">print</span><span class="p">(</span><span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">new_ids</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">idl</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;overlap:&#39;</span><span class="p">,</span> <span class="n">overlap</span><span class="p">)</span>
                <span class="kn">import</span> <span class="nn">ipdb</span><span class="p">;</span> <span class="n">ipdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
        <span class="c1">#</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;i:&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;n_new_ids:&#39;</span><span class="p">,</span> <span class="n">n_new_ids</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;stop:&#39;</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;next_new_id:&#39;</span><span class="p">,</span> <span class="n">next_new_id</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;next_new_id - existing_ids.max():&#39;</span><span class="p">,</span>
            <span class="n">next_new_id</span> <span class="o">-</span> <span class="n">existing_ids</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">next_new_id</span> <span class="o">=</span> <span class="n">stop</span>

        <span class="n">curr_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">existing_ids</span><span class="p">,</span> <span class="n">new_ids</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_ids</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_ids</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">curr_ids</span><span class="p">))</span>

        <span class="c1"># TODO this is the necessary condition for having current centers not</span>
        <span class="c1"># get mis-ordered, right?</span>
        <span class="c1">#assert np.array_equal(np.argsort(curr_ids), np.argsort(new_center_idx))</span>
        <span class="c1">#</span>
        <span class="c1">#import ipdb; ipdb.set_trace()</span>

        <span class="c1">#&#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">_id</span><span class="p">,</span> <span class="n">cxy</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">curr_ids</span><span class="p">,</span> <span class="n">centers_list</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][:,:</span><span class="mi">2</span><span class="p">])):</span>
            <span class="k">if</span> <span class="n">_id</span> <span class="ow">in</span> <span class="n">id2last_xy</span><span class="p">:</span>
                <span class="n">last_xy</span> <span class="o">=</span> <span class="n">id2last_xy</span><span class="p">[</span><span class="n">_id</span><span class="p">]</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">euclidean_dist</span><span class="p">(</span><span class="n">cxy</span><span class="p">,</span> <span class="n">last_xy</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">max_cost</span>
                <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                    <span class="c1">#print(max_cost)</span>
                    <span class="c1">#print(dist)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;id:&#39;</span><span class="p">,</span> <span class="n">_id</span><span class="p">)</span>
                    <span class="c1">#print(last_xy)</span>
                    <span class="c1">#print(cxy)</span>
                    <span class="k">if</span> <span class="n">_id</span> <span class="ow">in</span> <span class="n">new_ids</span><span class="p">:</span>
                        <span class="n">fr</span> <span class="o">=</span> <span class="s1">&#39;new&#39;</span>
                    <span class="k">elif</span> <span class="n">_id</span> <span class="ow">in</span> <span class="n">existing_ids</span><span class="p">:</span>
                        <span class="n">fr</span> <span class="o">=</span> <span class="s1">&#39;old&#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="kc">False</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">fr</span><span class="p">)</span>

                    <span class="nb">print</span><span class="p">(</span><span class="n">id2src_history</span><span class="p">[</span><span class="n">_id</span><span class="p">])</span>
                    <span class="n">prev_idx</span> <span class="o">=</span> <span class="n">id2idx_history</span><span class="p">[</span><span class="n">_id</span><span class="p">]</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">prev_idx</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">prev_idx</span> <span class="o">=</span> <span class="n">prev_idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">prev_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="c1"># (previous entry in ids_list)</span>
                            <span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">ids_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">_id</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span>
                                <span class="n">prev_idx</span>
                            <span class="p">)</span>

                    <span class="kn">import</span> <span class="nn">ipdb</span><span class="p">;</span> <span class="n">ipdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>

            <span class="n">id2last_xy</span><span class="p">[</span><span class="n">_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">cxy</span>
            <span class="c1"># TODO delete these after debugging</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">_id</span> <span class="ow">in</span> <span class="n">id2src_history</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">_id</span> <span class="ow">in</span> <span class="n">id2idx_history</span><span class="p">)</span>
            <span class="n">src_hist</span> <span class="o">=</span> <span class="s1">&#39;new&#39;</span> <span class="k">if</span> <span class="n">_id</span> <span class="ow">in</span> <span class="n">new_ids</span> <span class="k">else</span> <span class="s1">&#39;old&#39;</span>
            <span class="k">if</span> <span class="n">_id</span> <span class="ow">in</span> <span class="n">id2src_history</span><span class="p">:</span>
                <span class="n">id2src_history</span><span class="p">[</span><span class="n">_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">src_hist</span><span class="p">)</span>
                <span class="n">id2idx_history</span><span class="p">[</span><span class="n">_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">id2src_history</span><span class="p">[</span><span class="n">_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">src_hist</span><span class="p">]</span>
                <span class="n">id2idx_history</span><span class="p">[</span><span class="n">_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="c1">#</span>
        <span class="c1">#&#39;&#39;&#39;</span>

        <span class="n">ids_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_ids</span><span class="p">)</span>

        <span class="c1"># TODO TODO TODO some assertion that re-ordered centers are still</span>
        <span class="c1"># fully equiv to old centers, when indexing as they get indexed below?</span>
        <span class="c1"># though ordering across centers is what really matters...</span>

        <span class="c1"># TODO `i` as well?</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        if debug_points and i + 1 in debug_points:</span>
<span class="sd">            print(f&#39;I + 1 = {i + 1}&#39;)</span>
<span class="sd">            for pt_info in debug_points[i + 1]:</span>
<span class="sd">                roi_id = int(pt_info[&#39;name&#39;])</span>
<span class="sd">                xy0 = pt_info[&#39;xy0&#39;]</span>
<span class="sd">                xy1 = pt_info[&#39;xy1&#39;]</span>
<span class="sd">                print(&#39;roi_id:&#39;, roi_id)</span>
<span class="sd">                print(&#39;xy0:&#39;, xy0)</span>

<span class="sd">                # TODO turn into assertion</span>
<span class="sd">                # shouldn&#39;t happen?</span>
<span class="sd">                if roi_id not in curr_ids:</span>
<span class="sd">                    print(&#39;not in curr_ids&#39;)</span>
<span class="sd">                    import ipdb; ipdb.set_trace()</span>
<span class="sd">                #</span>

<span class="sd">                if roi_id in matches1[:,0]:</span>
<span class="sd">                    print(&#39;in matches1[:,0] (old IDs)&#39;)</span>
<span class="sd">                elif roi_id in new_ids:</span>
<span class="sd">                    print(&#39;in new_ids!&#39;)</span>
<span class="sd">                else:</span>
<span class="sd">                    assert False, &#39;neither in old nor new ids&#39;</span>

<span class="sd">                id_idx = np.argmax(curr_ids == roi_id)</span>
<span class="sd">                cxy = tuple(centers_list[i + 1][id_idx][:2])</span>
<span class="sd">                assert cxy == xy0</span>
<span class="sd">                lidx = pt_info.get(&#39;xy0_lidx&#39;)</span>
<span class="sd">                if lidx is not None:</span>
<span class="sd">                    xy0_was_matched = True</span>
<span class="sd">                    lpt = pt_info.get(&#39;xy0_lpt&#39;)</span>
<span class="sd">                    # so we can still index in to the non-re-ordered centers</span>
<span class="sd">                    assert tuple(centers[lidx, :2]) == xy0</span>
<span class="sd">                    print(&#39;xy0_lidx:&#39;, lidx)</span>
<span class="sd">                else:</span>
<span class="sd">                    xy0_was_matched = False</span>

<span class="sd">                #if xy0_was_matched:</span>
<span class="sd">                #    assert</span>
<span class="sd">                #import ipdb; ipdb.set_trace()</span>

<span class="sd">            #import ipdb; ipdb.set_trace()</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches_list</span><span class="p">):</span>
            <span class="n">matches2</span> <span class="o">=</span> <span class="n">matches_list</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span>

            <span class="c1"># These two columns should have the ROI / center numbers</span>
            <span class="c1"># represent the same real ROI / point coordinates.</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">shared_m1_idx</span><span class="p">,</span> <span class="n">shared_m2_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span>
                <span class="n">matches1</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">matches2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span>
                <span class="n">matches1</span><span class="p">[</span><span class="n">shared_m1_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">matches2</span><span class="p">[</span><span class="n">shared_m2_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">prior_ids_of_shared</span> <span class="o">=</span> <span class="n">matches1</span><span class="p">[</span><span class="n">shared_m1_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">matches2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">matches2</span><span class="p">[</span><span class="n">shared_m2_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">prior_ids_of_shared</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">matches2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span>

            <span class="n">nonshared_m2_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matches2</span><span class="p">)),</span>
                <span class="n">shared_m2_idx</span>
            <span class="p">)</span>
            <span class="c1"># ROIs unmatched in matches2 get any remaining higher IDs in new_ids</span>
            <span class="c1"># It is possible for there to be new_ids without any</span>
            <span class="c1"># nonshared_m2_idx.</span>
            <span class="c1"># TODO TODO TODO will we ever need to map from these new_ids that</span>
            <span class="c1"># run off the end to specific centers later?</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;new_ids:&#39;</span><span class="p">,</span> <span class="n">new_ids</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;new_ids[:len(nonshared_m2_idx)]:&#39;</span><span class="p">,</span>
                <span class="n">new_ids</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">nonshared_m2_idx</span><span class="p">)]</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;nonshared_m2_idx:&#39;</span><span class="p">,</span> <span class="n">nonshared_m2_idx</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;matches2[nonshared_m2_idx, 0]:&#39;</span><span class="p">,</span>
                <span class="n">matches2</span><span class="p">[</span><span class="n">nonshared_m2_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="kn">import</span> <span class="nn">ipdb</span><span class="p">;</span> <span class="n">ipdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
            <span class="n">matches2</span><span class="p">[</span><span class="n">nonshared_m2_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_ids</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">nonshared_m2_idx</span><span class="p">)]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">matches2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ids_list</span><span class="p">,</span> <span class="n">centers_list</span><span class="p">)):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">cs</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;(i=</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">) </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span><span class="si">}</span><span class="s1"> != </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="n">centers_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">centers_list</span><span class="p">),</span> <span class="n">next_new_id</span><span class="p">,</span>
        <span class="n">centers_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">centers</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ids_list</span><span class="p">,</span> <span class="n">centers_list</span><span class="p">)):</span>
        <span class="n">centers_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">centers</span>

        <span class="k">if</span> <span class="n">debug_points</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">debug_points</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">pt_info</span> <span class="ow">in</span> <span class="n">debug_points</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">roi_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pt_info</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
                    <span class="n">xy0</span> <span class="o">=</span> <span class="n">pt_info</span><span class="p">[</span><span class="s1">&#39;xy0&#39;</span><span class="p">]</span>
                    <span class="n">cidx</span> <span class="o">=</span> <span class="n">point_idx</span><span class="p">(</span><span class="n">centers_array</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">xy0</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="n">cidx</span> <span class="o">==</span> <span class="n">roi_id</span>

    <span class="k">return</span> <span class="n">centers_array</span></div>


<div class="viewcode-block" id="roi_jumps"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.roi_jumps">[docs]</a><span class="k">def</span> <span class="nf">roi_jumps</span><span class="p">(</span><span class="n">roi_xyd</span><span class="p">,</span> <span class="n">max_cost</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns dict of first_frame -&gt; list of (x, y, str(point idx)) for each</span>
<span class="sd">    time an ROI jumps by &gt;= max_cost on consecutive frames.</span>

<span class="sd">    correspond_rois should have not matched these points.</span>

<span class="sd">    Output suitable for debug_points kwarg to correspond_rois</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">diffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">roi_xyd</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">roi_xyd</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
    <span class="c1"># to avoid NaN comparison warning on &gt;= (dists must be positive anyway)</span>
    <span class="n">dists</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dists</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">jumps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">dists</span> <span class="o">&gt;=</span> <span class="n">max_cost</span><span class="p">)</span>
    <span class="n">dists</span><span class="p">[</span><span class="n">dists</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">first_frames</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">jumps</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">debug_points</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="n">first_frames</span><span class="p">:</span>
        <span class="n">ff_rois</span> <span class="o">=</span> <span class="n">jumps</span><span class="p">[</span><span class="n">jumps</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ff</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># switching frame and roi axes so iteration is over rois</span>
        <span class="c1"># (zippable w/ ff_rois below)</span>
        <span class="n">xys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">roi_xyd</span><span class="p">[</span><span class="n">ff</span><span class="p">:</span><span class="n">ff</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">ff_rois</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
        <span class="p">)</span>
        <span class="n">ff_info</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">roi</span><span class="p">,</span> <span class="n">roi_xys</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ff_rois</span><span class="p">,</span> <span class="n">xys</span><span class="p">):</span>
            <span class="n">xy0</span><span class="p">,</span> <span class="n">xy1</span> <span class="o">=</span> <span class="n">roi_xys</span>
            <span class="n">pt_info</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">roi</span><span class="p">),</span> <span class="s1">&#39;xy0&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">xy0</span><span class="p">),</span> <span class="s1">&#39;xy1&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">xy1</span><span class="p">)}</span>
            <span class="n">ff_info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt_info</span><span class="p">)</span>
        <span class="n">debug_points</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span> <span class="o">=</span> <span class="n">ff_info</span>

    <span class="k">return</span> <span class="n">debug_points</span></div>


<span class="c1"># TODO TODO use in unit tests of roi tracking w/ some real data as input</span>
<div class="viewcode-block" id="check_no_roi_jumps"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.check_no_roi_jumps">[docs]</a><span class="k">def</span> <span class="nf">check_no_roi_jumps</span><span class="p">(</span><span class="n">roi_xyd</span><span class="p">,</span> <span class="n">max_cost</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">roi_jumps</span><span class="p">(</span><span class="n">roi_xyd</span><span class="p">,</span> <span class="n">max_cost</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span></div>


<span class="c1"># TODO TODO TODO re-enable checks!!!</span>
<div class="viewcode-block" id="correspond_and_renumber_rois"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.correspond_and_renumber_rois">[docs]</a><span class="k">def</span> <span class="nf">correspond_and_renumber_rois</span><span class="p">(</span><span class="n">roi_xyd_sequence</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">checks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_renumber_rois2</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="n">max_cost</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_cost&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">max_cost</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># TODO maybe switch to max / check current approach yields results</span>
        <span class="c1"># just as reasonable as those w/ larger max_cost</span>
        <span class="n">min_diam</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">xyd</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="k">for</span> <span class="n">xyd</span> <span class="ow">in</span> <span class="n">roi_xyd_sequence</span><span class="p">])</span>
        <span class="c1"># + 1 b/c cost == max_cost is thrown out</span>
        <span class="n">max_cost</span> <span class="o">=</span> <span class="n">min_diam</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;max_cost&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_cost</span>

    <span class="c1"># TODO fix what seems to be making correspond_rois fail in case where</span>
    <span class="c1"># diameter info is also passed in (so it can be used here and elsewhere</span>
    <span class="c1"># w/o having to toss that data first)</span>
    <span class="n">roi_xy_seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">xyd</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">xyd</span> <span class="ow">in</span> <span class="n">roi_xyd_sequence</span><span class="p">]</span>

    <span class="n">lr_matches</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">correspond_rois</span><span class="p">(</span><span class="n">roi_xy_seq</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="c1">#    verbose=debug, show=debug, write_plots=False, **kwargs</span>
        <span class="n">verbose</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">write_plots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    if debug:</span>
<span class="sd">        # For stuff plotted in correspond_rois</span>
<span class="sd">        plt.show()</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">debug_points</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;debug_points&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_renumber_rois2</span><span class="p">:</span>
        <span class="n">new_roi_xyd</span> <span class="o">=</span> <span class="n">renumber_rois2</span><span class="p">(</span><span class="n">lr_matches</span><span class="p">,</span> <span class="n">roi_xyd_sequence</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_roi_xyd</span> <span class="o">=</span> <span class="n">renumber_rois</span><span class="p">(</span><span class="n">lr_matches</span><span class="p">,</span> <span class="n">roi_xyd_sequence</span><span class="p">,</span>
            <span class="n">debug_points</span><span class="o">=</span><span class="n">debug_points</span><span class="p">,</span> <span class="n">max_cost</span><span class="o">=</span><span class="n">max_cost</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">checks</span><span class="p">:</span>
        <span class="n">check_no_roi_jumps</span><span class="p">(</span><span class="n">new_roi_xyd</span><span class="p">,</span> <span class="n">max_cost</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_roi_xyd</span></div>


<span class="c1"># TODO add nonoverlap constraint? somehow make closer to real data?</span>
<span class="c1"># TODO use this to test gui/fitting/tracking</span>
<div class="viewcode-block" id="make_test_centers"><a class="viewcode-back" href="../../apidoc/hong2p.roi.html#hong2p.roi.make_test_centers">[docs]</a><span class="k">def</span> <span class="nf">make_test_centers</span><span class="p">(</span><span class="n">initial_n</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">nt</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">frame_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">),</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">exlusion_radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">max_n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">round_</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">diam_px</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
    <span class="n">add_diameters</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># TODO maybe adapt p so it&#39;s the p over the course of the</span>
    <span class="c1"># nt steps, and derivce single timestep p from that?</span>

    <span class="k">if</span> <span class="n">exlusion_radius</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="c1"># So that we can pre-allocate the center coordinates over time</span>
    <span class="c1"># (rather than having to figure out how many were added by the end,</span>
    <span class="c1"># and then pad all the preceding arrays of centers w/ NaN)</span>
    <span class="k">if</span> <span class="n">p</span><span class="p">:</span>
        <span class="n">max_n</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">initial_n</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Don&#39;t need to allocate extra space if the number of ROIs is</span>
        <span class="c1"># deterministic.</span>
        <span class="n">max_n</span> <span class="o">=</span> <span class="n">initial_n</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="n">frame_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">frame_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">frame_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">max_coord</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># Also using this for new centers gained while iterating.</span>
    <span class="n">initial_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">max_n</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

    <span class="c1"># TODO more idiomatic numpy way to generate cumulative noise?</span>
    <span class="c1"># (if so, just repeat initial_centers to generate centers, and add the</span>
    <span class="c1"># two) (maybe not, with my constraints...)</span>
    <span class="c1"># TODO TODor generate inside the loop (only as many as non-NaN, and only</span>
    <span class="c1"># apply to non NaN)</span>
    <span class="n">xy_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">nt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_n</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">sigma</span>

    <span class="n">next_trajectory_idx</span> <span class="o">=</span> <span class="n">initial_n</span>
    <span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nt</span><span class="p">,</span> <span class="n">max_n</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">centers</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="n">initial_n</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_centers</span><span class="p">[:</span><span class="n">initial_n</span><span class="p">]</span>
    <span class="c1"># TODO should i be generating the noise differently, so that the x and y</span>
    <span class="c1"># components are not independent (so that if deviation is high in one,</span>
    <span class="c1"># it&#39;s more likely to be lower in other coordinate, to more directly</span>
    <span class="c1"># constrain the distance? maybe it&#39;s just a scaling thing though...)</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nt</span><span class="p">):</span>
        <span class="c1"># TODO maybe handle this differently...</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">and</span> <span class="n">next_trajectory_idx</span> <span class="o">==</span> <span class="n">max_n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;reached max_n (</span><span class="si">{</span><span class="n">max_n</span><span class="si">}</span><span class="s1">) on step </span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s1"> &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;(before </span><span class="si">{</span><span class="n">nt</span><span class="si">}</span><span class="s1"> requested steps&#39;</span>
            <span class="p">)</span>
            <span class="c1">#break</span>

        <span class="n">centers</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">centers</span><span class="p">[</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">xy_steps</span><span class="p">[</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># TODO make sure NaN stuff handled correctly here</span>
        <span class="c1"># The centers should stay within the imaginary frame bounds.</span>
        <span class="n">centers</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">centers</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_coord</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_coord</span>
        <span class="n">centers</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">centers</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">lose</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">max_n</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">nonnan</span> <span class="o">=</span> <span class="o">~</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">centers</span><span class="p">[</span><span class="n">t</span><span class="p">,:,</span><span class="mi">0</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;# non-nan:&#39;</span><span class="p">,</span> <span class="n">nonnan</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
            <span class="n">n_lost</span> <span class="o">=</span> <span class="p">(</span><span class="n">nonnan</span> <span class="o">&amp;</span> <span class="n">lose</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">n_lost</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;t=</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s1">, losing </span><span class="si">{</span><span class="n">n_lost</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">centers</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">lose</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># TODO TODO note: if not allowed to fill NaN that come from losing</span>
        <span class="c1"># stuff, then max_n might more often limit # unique rather than #</span>
        <span class="c1"># concurrent tracks... (and that would prob make a format more close to</span>
        <span class="c1"># what i was already implementing in association code...)</span>
        <span class="c1"># maybe this all means i could benefit from a different</span>
        <span class="c1"># representation...</span>
        <span class="c1"># one more like id -&gt; (start frame, end frame, coordinates)</span>

        <span class="c1"># Currently, giving any new trajectories different indices (IDs)</span>
        <span class="c1"># from any previous trajectories, by putting them in ranges that</span>
        <span class="c1"># had so far only had NaN. As association code may be, this also</span>
        <span class="c1"># groups new ones in the next-unused-integer-indices, rather</span>
        <span class="c1"># than giving each remaining index a chance.</span>
        <span class="c1"># To justify first arg (n), imagine case where initial_n=0 and</span>
        <span class="c1"># max_n=1.</span>
        <span class="n">n_to_gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="n">max_n</span> <span class="o">-</span> <span class="n">initial_n</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_to_gain</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;t=</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s1">, gaining </span><span class="si">{</span><span class="n">n_to_gain</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="n">first_ic_idx</span> <span class="o">=</span> <span class="n">next_trajectory_idx</span> <span class="o">-</span> <span class="n">initial_n</span>
            <span class="n">centers</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">next_trajectory_idx</span><span class="p">:</span><span class="n">next_trajectory_idx</span> <span class="o">+</span> <span class="n">n_to_gain</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">initial_centers</span><span class="p">[</span><span class="n">first_ic_idx</span><span class="p">:</span><span class="n">first_ic_idx</span> <span class="o">+</span> <span class="n">n_to_gain</span><span class="p">]</span>
            <span class="n">next_trajectory_idx</span> <span class="o">+=</span> <span class="n">n_to_gain</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span> <span class="o">==</span> <span class="n">nt</span>

    <span class="c1"># This seems to convert NaN to zero...</span>
    <span class="k">if</span> <span class="n">round_</span><span class="p">:</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">add_diameters</span><span class="p">:</span>
        <span class="n">roi_diams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">centers</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">diam_px</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">centers</span><span class="p">,</span> <span class="n">roi_diams</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># TODO check output is in same kind of format as output of my matching fns</span>

    <span class="k">return</span> <span class="n">centers</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2022, Tom O&#39;Connell.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
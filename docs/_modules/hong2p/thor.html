

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>hong2p.thor &mdash; hong2p 0.0.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> hong2p
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../apidoc/modules.html">hong2p</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">hong2p</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>hong2p.thor</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for hong2p.thor</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Functions for working with ThorImage / ThorSync outputs, including for dealing</span>
<span class="sd">with naming conventions we use for outputs of these programs.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">listdir</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">join</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">exists</span><span class="p">,</span> <span class="n">isdir</span><span class="p">,</span> <span class="n">normpath</span><span class="p">,</span> <span class="n">getmtime</span><span class="p">,</span> <span class="n">abspath</span>
<span class="c1"># TODO replace w/ stock ElementTree name? no good justification for this renaming</span>
<span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="k">as</span> <span class="nn">etree</span>
<span class="kn">from</span> <span class="nn">xml.etree.ElementTree</span> <span class="kn">import</span> <span class="n">Element</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">pformat</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">zip_longest</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">hong2p.types</span> <span class="kn">import</span> <span class="n">Pathlike</span><span class="p">,</span> <span class="n">PathPair</span>


<span class="c1"># Note: these other names may get converted to these via hdf5_dataset_rename_dict/etc</span>
<span class="n">_acquisition_trigger_names</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;scope_pin&#39;</span><span class="p">,)</span>
<span class="n">_odor_timing_names</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;olf_disp_pin&#39;</span><span class="p">,)</span>

<span class="n">DIGITAL_THRESHOLD</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="c1"># Since some electrical bug (?) on downstairs scope has led to ~4v pulses before and</span>
<span class="c1"># after recording. Used to use 2.5 before that.</span>
<span class="c1">#</span>
<span class="c1"># This change didn&#39;t fix handling of the 2022-10-07/1/megamat0_part2 data I was</span>
<span class="c1"># expecting it to fix though...</span>
<span class="n">ANALOG_0_TO_5V_THRESHOLD</span> <span class="o">=</span> <span class="mf">4.5</span>


<div class="viewcode-block" id="OnsetOffsetNumMismatch"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.OnsetOffsetNumMismatch">[docs]</a><span class="k">class</span> <span class="nc">OnsetOffsetNumMismatch</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span></div>

<div class="viewcode-block" id="NotAllFramesAssigned"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.NotAllFramesAssigned">[docs]</a><span class="k">class</span> <span class="nc">NotAllFramesAssigned</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="xmlroot"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.xmlroot">[docs]</a><span class="k">def</span> <span class="nf">xmlroot</span><span class="p">(</span><span class="n">xml_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Element</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Loads contents of xml_path into xml.etree.ElementTree and returns root.</span>

<span class="sd">    Use calls to &lt;node&gt;.find(&lt;child name&gt;) to traverse down tree and at leaves,</span>
<span class="sd">    use &lt;leaf&gt;.attrib[&lt;attribute name&gt;] to get values. There are other functions</span>
<span class="sd">    too, but see `xml` documentation for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">etree</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">xml_path</span><span class="p">)</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span></div>


<span class="c1"># TODO maybe rename everything to get rid of &#39;get_&#39; prefix? mainly here so i</span>
<span class="c1"># can name what these functions return naturally without shadowing...</span>

<span class="n">thorimage_xml_basename</span> <span class="o">=</span> <span class="s1">&#39;Experiment.xml&#39;</span>
<div class="viewcode-block" id="get_thorimage_xml_path"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_thorimage_xml_path">[docs]</a><span class="k">def</span> <span class="nf">get_thorimage_xml_path</span><span class="p">(</span><span class="n">thorimage_dir</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Takes ThorImage output dir to (expected) path to its XML output.</span>

<span class="sd">    Raises IOError if either thorimage_dir or Experiment.xml contained within it do not</span>
<span class="sd">    exist.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isdir</span><span class="p">(</span><span class="n">thorimage_dir</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;thorimage_dir </span><span class="si">{</span><span class="n">thorimage_dir</span><span class="si">}</span><span class="s1"> does not exist!&#39;</span><span class="p">)</span>

    <span class="n">xml_path</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">thorimage_dir</span><span class="p">,</span> <span class="n">thorimage_xml_basename</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">xml_path</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">thorimage_xml_basename</span><span class="si">}</span><span class="s1"> did not exist in </span><span class="si">{</span><span class="n">thorimage_dir</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">xml_path</span></div>


<span class="c1"># TODO does this work?</span>
<span class="n">PathOrXML</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Element</span><span class="p">]</span>


<span class="c1"># TODO TODO now that this behaves as identity if given xml object, actually use that to</span>
<span class="c1"># collapse some of the functions w/ and w/o _xml suffix and allow those of only one type</span>
<span class="c1"># to work with both types of input</span>
<span class="c1"># TODO should i relax typehing to something like PathlikeOrXML or nah?</span>
<div class="viewcode-block" id="get_thorimage_xmlroot"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_thorimage_xmlroot">[docs]</a><span class="k">def</span> <span class="nf">get_thorimage_xmlroot</span><span class="p">(</span><span class="n">thorimage_dir_or_xmlroot</span><span class="p">:</span> <span class="n">PathOrXML</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Element</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Takes ThorImage output dir to object w/ XML data.</span>

<span class="sd">    Returns the input without doing anything if it is already the same type of XML</span>
<span class="sd">    object that would be returned, to allow writing functions that can either be given</span>
<span class="sd">    paths to ThorImage directories or re-use an already loaded representation of its</span>
<span class="sd">    XML.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">thorimage_dir_or_xmlroot</span><span class="p">,</span> <span class="n">Element</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">thorimage_dir_or_xmlroot</span>

    <span class="n">thorimage_dir</span> <span class="o">=</span> <span class="n">thorimage_dir_or_xmlroot</span>

    <span class="n">xml_path</span> <span class="o">=</span> <span class="n">get_thorimage_xml_path</span><span class="p">(</span><span class="n">thorimage_dir</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">xmlroot</span><span class="p">(</span><span class="n">xml_path</span><span class="p">)</span></div>


<span class="c1"># TODO doc</span>
<div class="viewcode-block" id="thorimage_xml"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.thorimage_xml">[docs]</a><span class="k">def</span> <span class="nf">thorimage_xml</span><span class="p">(</span><span class="n">fn_taking_xml</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts an attribute lookup fn taking XML to allow ThorImage directory input.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">fn_taking_xml</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fn_taking_path_or_xml</span><span class="p">(</span><span class="n">thorimage_dir_or_xmlroot</span><span class="p">:</span> <span class="n">PathOrXML</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">xml</span> <span class="o">=</span> <span class="n">get_thorimage_xmlroot</span><span class="p">(</span><span class="n">thorimage_dir_or_xmlroot</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fn_taking_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">fn_taking_path_or_xml</span></div>


<div class="viewcode-block" id="get_thorimage_time"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_thorimage_time">[docs]</a><span class="nd">@thorimage_xml</span>
<span class="k">def</span> <span class="nf">get_thorimage_time</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">datetime</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Takes etree XML root object to recording start time.</span>

<span class="sd">    XML object should be as returned by `get_thorimage_xmlroot`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">date_ele</span> <span class="o">=</span> <span class="n">xml</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;Date&#39;</span><span class="p">)</span>
    <span class="n">from_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">date_ele</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">],</span> <span class="s1">&#39;%m/</span><span class="si">%d</span><span class="s1">/%Y %H:%M:%S&#39;</span><span class="p">)</span>
    <span class="n">from_utime</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">fromtimestamp</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">date_ele</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;uTime&#39;</span><span class="p">]))</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">from_date</span> <span class="o">-</span> <span class="n">from_utime</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">from_utime</span></div>


<div class="viewcode-block" id="get_thorimage_n_frames"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_thorimage_n_frames">[docs]</a><span class="nd">@thorimage_xml</span>
<span class="k">def</span> <span class="nf">get_thorimage_n_frames</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span> <span class="n">without_flyback</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">num_volumes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the number of XY planes (# of timepoints) in the recording.</span>

<span class="sd">    This is the number of frames *after* any averaging configured in ThorImage.</span>

<span class="sd">    Any flyback frames are included.</span>

<span class="sd">    If additional color channels are enabled but other parameters remain the same, this</span>
<span class="sd">    number will not change.</span>

<span class="sd">    Args:</span>
<span class="sd">        without_flyback: if True, subtract the number of flyback frames (if any)</span>

<span class="sd">        num_volumes: if True, return number of volumes instead of number of XY frames.</span>
<span class="sd">            since there are a fixed number of flyback frames per volume, this option</span>
<span class="sd">            will return the same number regardless of without_flyback.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">num_volumes</span><span class="p">:</span>
        <span class="n">without_flyback</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">n_raw_xy_frames</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">xml</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;Streaming&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;frames&#39;</span><span class="p">])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">without_flyback</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n_raw_xy_frames</span>

    <span class="n">n_flyback</span> <span class="o">=</span> <span class="n">get_thorimage_n_flyback_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span>

    <span class="n">z</span> <span class="o">=</span> <span class="n">get_thorimage_z_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span>
    <span class="n">z_total</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="n">n_flyback</span>

    <span class="n">n_volumes</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">n_raw_xy_frames</span><span class="p">,</span> <span class="n">z_total</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">remainder</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">num_volumes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n_volumes</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n_raw_xy_frames</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_flyback</span> <span class="o">*</span> <span class="n">n_volumes</span><span class="p">)</span></div>


<div class="viewcode-block" id="is_fast_z_enabled_xml"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.is_fast_z_enabled_xml">[docs]</a><span class="nd">@thorimage_xml</span>
<span class="k">def</span> <span class="nf">is_fast_z_enabled_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">streaming</span> <span class="o">=</span> <span class="n">xml</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;Streaming&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">streaming</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;enable&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span>
        <span class="c1"># zFastEnable can still be 1 when we aren&#39;t doing fast Z (e.g. in some</span>
        <span class="c1"># anatomical stack data)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">streaming</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;zFastEnable&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span></div>


<span class="k">def</span> <span class="nf">_get_zstage</span><span class="p">(</span><span class="n">xml</span><span class="p">):</span>
    <span class="c1"># TODO assert there is only one ZStage object? is it always only primary (assumed</span>
    <span class="c1"># piezo) saved into xml, even if there is a stepper secondary z-axis too?</span>
    <span class="n">zstage</span> <span class="o">=</span> <span class="n">xml</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;ZStage&#39;</span><span class="p">)</span>

    <span class="c1"># TODO replace .find w/ findall(...)[0]?</span>
    <span class="c1">#</span>
    <span class="c1"># yang&#39;s test XML she sent has multiple ZStage elements, but only one with name</span>
    <span class="c1"># defined (=&#39;ThorZPiezo&#39;)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xml</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;ZStage&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="s1">&#39;name&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">attrib</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="c1"># TODO and if fastZ is enabled, is that sufficient evidence it is piezo?</span>
    <span class="c1"># NO! (at least it&#39;s possible to misconfigure downstairs system so that non-piezo</span>
    <span class="c1"># stage is selected for both primary/secondary, and it will still let you collect a</span>
    <span class="c1"># recording with fast Z apparently enabled)</span>

    <span class="k">return</span> <span class="n">zstage</span>


<div class="viewcode-block" id="get_thorimage_z_xml"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_thorimage_z_xml">[docs]</a><span class="nd">@thorimage_xml</span>
<span class="k">def</span> <span class="nf">get_thorimage_z_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns number of different Z depths measured in ThorImage recording.</span>

<span class="sd">    Does NOT include any flyback frames there may be.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">zstage</span> <span class="o">=</span> <span class="n">_get_zstage</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">zstage</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;steps&#39;</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">z</span></div>


<div class="viewcode-block" id="get_thorimage_z_stream_frames"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_thorimage_z_stream_frames">[docs]</a><span class="nd">@thorimage_xml</span>
<span class="k">def</span> <span class="nf">get_thorimage_z_stream_frames</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns number of different Z depths measured in ThorImage recording.</span>

<span class="sd">    Does NOT include any flyback frames there may be.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">zstage</span> <span class="o">=</span> <span class="n">_get_zstage</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">zstage</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;zStreamFrames&#39;</span><span class="p">])</span>
    <span class="c1"># TODO warn if streaming acqusition mode (or something else to rule out anatomical</span>
    <span class="c1"># recordings) AND is_fast_z_enabled_xml(xml) is False?</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">n</span></div>


<div class="viewcode-block" id="get_thorimage_zstep_um"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_thorimage_zstep_um">[docs]</a><span class="nd">@thorimage_xml</span>
<span class="k">def</span> <span class="nf">get_thorimage_zstep_um</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="n">zstage</span> <span class="o">=</span> <span class="n">_get_zstage</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">zstage</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;stepSizeUM&#39;</span><span class="p">])</span></div>


<span class="c1"># TODO maybe add a function to get expected movie.size from thorimage .raw</span>
<span class="c1"># file, and then include a check that these sizes match those expected by</span>
<span class="c1"># multiplying all the relevant dimensions (including flyback) in the metadata</span>
<span class="c1"># (would also check assumption that n_frames in ThorImage XML always acurately</span>
<span class="c1"># reflects the number of frames in the ThorImage .raw file, and would need to</span>
<span class="c1"># modify / not do such a check if this assumption turns out to be false)</span>
<span class="c1"># TODO also would need to check that i&#39;m using the correct means of getting the</span>
<span class="c1"># size of the file, as we want how much data it actually contains not like how</span>
<span class="c1"># much space the particular storage media / filesystem happens to need to store</span>
<span class="c1"># it (which i think can slightly exceed the real amount of data the file should</span>
<span class="c1"># have, from what i remember using `du`)</span>


<div class="viewcode-block" id="get_thorimage_n_channels_xml"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_thorimage_n_channels_xml">[docs]</a><span class="nd">@thorimage_xml</span>
<span class="k">def</span> <span class="nf">get_thorimage_n_channels_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">pmt</span> <span class="o">=</span> <span class="n">xml</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;PMT&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrib</span>

    <span class="c1"># It does seem that for channel B (perhaps also A but not C/D), you can have it</span>
    <span class="c1"># enabled with zero gain and it will still have corresponding data in the file.</span>
    <span class="k">def</span> <span class="nf">is_enabled</span><span class="p">(</span><span class="n">channel</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">pmt</span><span class="p">[</span><span class="s1">&#39;enable&#39;</span> <span class="o">+</span> <span class="n">channel</span><span class="p">])</span>

    <span class="c1"># TODO also check gain is nonzero? or maybe we don&#39;t want that since it seems some</span>
    <span class="c1"># data can have one channel w/ zero gain yet still &quot;data&quot; occupies that space in the</span>
    <span class="c1"># (at least raw) file format</span>

    <span class="c1"># Technically ThorImage metadata seems to go out to C and D as well, but even if</span>
    <span class="c1"># those are accidentally enabled, it seems that no additional garbage data going in</span>
    <span class="c1"># the .raw files at least (maybe it does into one of the TIFF output formats?), so</span>
    <span class="c1"># I&#39;m just not checking C and D.</span>
    <span class="n">n_channels</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">is_enabled</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">n_channels</span></div>


<span class="c1"># TODO probably also include number of &quot;frames&quot; (*planes* over time) here too</span>
<span class="c1"># (and in functions that call this)</span>
<span class="c1"># (though would need to take into account flyback as well as potentially</span>
<span class="c1"># averaging in order to have this dimension reflect shape of movie (as if the</span>
<span class="c1"># output of this function were `movie.shape` for the corresponding movie))</span>
<div class="viewcode-block" id="get_thorimage_dims"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_thorimage_dims">[docs]</a><span class="nd">@thorimage_xml</span>
<span class="k">def</span> <span class="nf">get_thorimage_dims</span><span class="p">(</span><span class="n">xml</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes etree XML root object to (xy, z, c) dimensions of movie.</span>

<span class="sd">    XML object should be as returned by `get_thorimage_xmlroot`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO exclude ~empty LSM tags, when multiple (finding first *should* still work),</span>
    <span class="c1"># like in test data yang sent. attrib[&#39;name&#39;] should only be defined for one tag?</span>
    <span class="c1"># TODO factor out LSM tag getting to do this (-&gt; share w/ other fns getting it)</span>
    <span class="n">lsm_attribs</span> <span class="o">=</span> <span class="n">xml</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;LSM&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrib</span>
    <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lsm_attribs</span><span class="p">[</span><span class="s1">&#39;pixelX&#39;</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lsm_attribs</span><span class="p">[</span><span class="s1">&#39;pixelY&#39;</span><span class="p">])</span>
    <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="c1"># TODO what is Streaming -&gt; flybackLines? (we already have flybackFrames...)</span>

    <span class="n">z</span> <span class="o">=</span> <span class="n">get_thorimage_z_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">get_thorimage_n_channels_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span>

    <span class="c1"># may want to add ZStage -&gt; stepSizeUM to TIFF metadata?</span>

    <span class="k">return</span> <span class="n">xy</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">c</span></div>


<div class="viewcode-block" id="get_thorimage_pixelsize_um"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_thorimage_pixelsize_um">[docs]</a><span class="nd">@thorimage_xml</span>
<span class="k">def</span> <span class="nf">get_thorimage_pixelsize_um</span><span class="p">(</span><span class="n">xml</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes etree XML root object to XY pixel size in um.</span>

<span class="sd">    Pixel size in X is the same as pixel size in Y.</span>

<span class="sd">    XML object should be as returned by `get_thorimage_xmlroot`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lsm</span> <span class="o">=</span> <span class="n">xml</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;LSM&#39;</span><span class="p">)</span>

    <span class="c1"># TODO put behind a checks= bool kwarg?</span>
    <span class="c1"># TODO does thorimage (and their xml) ever support unequal x and y resolution?</span>
    <span class="n">pixelsize_x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">lsm</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;widthUM&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">lsm</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;pixelX&#39;</span><span class="p">])</span>
    <span class="n">pixelsize_y</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">lsm</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;heightUM&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">lsm</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;pixelY&#39;</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">pixelsize_x</span><span class="p">,</span> <span class="n">pixelsize_y</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">pixelsize_x</span><span class="si">=}</span><span class="s1"> != </span><span class="si">{</span><span class="n">pixelsize_y</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="n">pixelsize_xy</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">lsm</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;pixelSizeUM&#39;</span><span class="p">])</span>

    <span class="c1"># pixelSizeUM is entered with 3 digits after decimal place in XML</span>
    <span class="c1"># [width|height]UM both have 5 sig figs in XML, with pixel[X|Y] generally having 3.</span>
    <span class="c1">#</span>
    <span class="c1"># atol=6e-4 should ignore anything different beyond pixelSizeUM&#39;s 3 digits after</span>
    <span class="c1"># decimal (and assuming rounding going into that)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">pixelsize_xy</span><span class="p">,</span> <span class="n">pixelsize_x</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">6e-4</span><span class="p">),</span> \
        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">pixelsize_xy</span><span class="si">=}</span><span class="s1"> != </span><span class="si">{</span><span class="n">pixelsize_x</span><span class="si">=}</span><span class="s1">&#39;</span>

    <span class="k">return</span> <span class="n">pixelsize_xy</span></div>


<span class="c1"># TODO replace w/ wrapped version + remove _xml suffix (and replace all calls similarly)</span>
<div class="viewcode-block" id="get_thorimage_n_averaged_frames_xml"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_thorimage_n_averaged_frames_xml">[docs]</a><span class="k">def</span> <span class="nf">get_thorimage_n_averaged_frames_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns how many frames ThorImage averaged for a single output frame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lsm_attribs</span> <span class="o">=</span> <span class="n">xml</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;LSM&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrib</span>

    <span class="c1"># TODO is this correct handling of averageMode?</span>
    <span class="n">average_mode</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lsm_attribs</span><span class="p">[</span><span class="s1">&#39;averageMode&#39;</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">average_mode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n_averaged_frames</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># TODO this sufficient check that frame averaging broken, or also/only check</span>
        <span class="c1"># z&gt;1?</span>
        <span class="c1"># TODO is there some cutoff version beyond which volumetric frame averaging is</span>
        <span class="c1"># supported for real?</span>
        <span class="c1"># NOTE: i think all thorimage versions we are using don&#39;t actually support frame</span>
        <span class="c1"># averaging if recording volumetrically. raw output will have all frames despite</span>
        <span class="c1"># value of this.</span>
        <span class="k">if</span> <span class="n">is_fast_z_enabled_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">):</span>
            <span class="c1"># TODO flag to disable warning?</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">get_thorimage_name</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">: XML indicates frame averaging was configured, &#39;</span>
                <span class="s1">&#39;but our ThorImage versions do not actually support this when fastZ &#39;</span>
                <span class="s1">&#39;is enabled. setting n_averaged_frames=1.&#39;</span>
            <span class="p">)</span>

            <span class="n">n_averaged_frames</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_averaged_frames</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lsm_attribs</span><span class="p">[</span><span class="s1">&#39;averageNum&#39;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">n_averaged_frames</span></div>


<span class="c1"># TODO replace w/ wrapped version + remove _xml suffix (and replace all calls similarly)</span>
<div class="viewcode-block" id="get_thorimage_fps_xml"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_thorimage_fps_xml">[docs]</a><span class="k">def</span> <span class="nf">get_thorimage_fps_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span> <span class="n">before_averaging</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># TODO TODO clarify in doc whether this is volumes-per-second or</span>
    <span class="c1"># xy-planes-per-second in the volumetric case (latter, i believe, though</span>
    <span class="c1"># maybe add kwarg to get former?)</span>
    <span class="sd">&quot;&quot;&quot;Takes XML root object to fps of recording.</span>

<span class="sd">    xml: etree XML root object as returned by `get_thorimage_xmlroot`.</span>

<span class="sd">    before_averaging (bool): (default=False) pass True to return the fps before</span>
<span class="sd">        any averaging.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lsm_attribs</span> <span class="o">=</span> <span class="n">xml</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;LSM&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrib</span>
    <span class="n">raw_fps</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">lsm_attribs</span><span class="p">[</span><span class="s1">&#39;frameRate&#39;</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">before_averaging</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">raw_fps</span>
    <span class="n">n_averaged_frames</span> <span class="o">=</span> <span class="n">get_thorimage_n_averaged_frames_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span>

    <span class="n">saved_fps</span> <span class="o">=</span> <span class="n">raw_fps</span> <span class="o">/</span> <span class="n">n_averaged_frames</span>
    <span class="k">return</span> <span class="n">saved_fps</span></div>


<div class="viewcode-block" id="get_thorimage_fps"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_thorimage_fps">[docs]</a><span class="k">def</span> <span class="nf">get_thorimage_fps</span><span class="p">(</span><span class="n">thorimage_directory</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># TODO TODO clarify in doc whether this is volumes-per-second or</span>
    <span class="c1"># xy-planes-per-second in the volumetric case (latter, i believe, though</span>
    <span class="c1"># maybe add kwarg to get former?)</span>
    <span class="sd">&quot;&quot;&quot;Takes ThorImage dir to fps of recording.</span>

<span class="sd">    before_averaging (bool): (default=False) pass True to return the fps before</span>
<span class="sd">        any averaging.</span>

<span class="sd">    All `kwargs` are passed through to `get_thorimage_fps_xml`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xml</span> <span class="o">=</span> <span class="n">get_thorimage_xmlroot</span><span class="p">(</span><span class="n">thorimage_directory</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">get_thorimage_fps_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_thorimage_n_flyback_xml"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_thorimage_n_flyback_xml">[docs]</a><span class="nd">@thorimage_xml</span>
<span class="k">def</span> <span class="nf">get_thorimage_n_flyback_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">is_fast_z_enabled_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">):</span>
        <span class="n">streaming</span> <span class="o">=</span> <span class="n">xml</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;Streaming&#39;</span><span class="p">)</span>
        <span class="n">n_flyback_frames</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">streaming</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;flybackFrames&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_flyback_frames</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="n">n_flyback_frames</span></div>


<div class="viewcode-block" id="get_thorimage_notes"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_thorimage_notes">[docs]</a><span class="nd">@thorimage_xml</span>
<span class="k">def</span> <span class="nf">get_thorimage_notes</span><span class="p">(</span><span class="n">xml</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">xml</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;ExperimentNotes&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="get_thorimage_name"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_thorimage_name">[docs]</a><span class="nd">@thorimage_xml</span>
<span class="k">def</span> <span class="nf">get_thorimage_name</span><span class="p">(</span><span class="n">xml</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">xml</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;Name&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="get_thorimage_version"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_thorimage_version">[docs]</a><span class="nd">@thorimage_xml</span>
<span class="k">def</span> <span class="nf">get_thorimage_version</span><span class="p">(</span><span class="n">xml</span><span class="p">):</span>
    <span class="c1"># e.g. &#39;3.0.2016.10131&#39;. no other attribs under Software tag (on this older</span>
    <span class="c1"># ThorImage version, at least)</span>
    <span class="k">return</span> <span class="n">xml</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;Software&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;version&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="get_thorimage_scannertype"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_thorimage_scannertype">[docs]</a><span class="nd">@thorimage_xml</span>
<span class="k">def</span> <span class="nf">get_thorimage_scannertype</span><span class="p">(</span><span class="n">xml</span><span class="p">):</span>
    <span class="n">lp</span> <span class="o">=</span> <span class="n">xml</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;LightPath&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrib</span>
    <span class="c1"># TODO can there ever be multiple LightPath tags (yes, but first should probably</span>
    <span class="c1"># still work. exclude elements with nothing or only cam enabled. share logic w/</span>
    <span class="c1"># other places i want to get a unique tag)? (test on output from systems w/</span>
    <span class="c1"># camera enabled too?)</span>

    <span class="n">lsm_name</span> <span class="o">=</span> <span class="n">xml</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;LSM&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">lp</span><span class="p">[</span><span class="s1">&#39;GalvoGalvo&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span>
        <span class="n">scanner</span> <span class="o">=</span> <span class="s1">&#39;GalvoGalvo&#39;</span>
        <span class="k">assert</span> <span class="n">lsm_name</span> <span class="o">==</span> <span class="s1">&#39;GalvoGalvo&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">lp</span><span class="p">[</span><span class="s1">&#39;GalvoResonance&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span>
        <span class="n">scanner</span> <span class="o">=</span> <span class="s1">&#39;GalvoResonance&#39;</span>
        <span class="c1"># NOTE: different str from above. this is the case in at least output from</span>
        <span class="c1"># 4.3.2023.6261 Yang sent me</span>
        <span class="k">assert</span> <span class="n">lsm_name</span> <span class="o">==</span> <span class="s1">&#39;ResonanceGalvo&#39;</span>

    <span class="k">return</span> <span class="n">scanner</span></div>


<span class="c1"># TODO TODO delete this fn / fix. ThorStage does (hopefully) not seem at all to imply we</span>
<span class="c1"># are not using a piezo. probably need to check fast z.</span>
<span class="c1"># TODO TODO what happens if you try to do fast z downstairs w/ just non-piezo zstage? or</span>
<span class="c1"># w/ it as primary? does it work? data issues? slower? ideally, we could tell from xml</span>
<span class="c1"># output, or it wouldn&#39;t allow recording...</span>
<div class="viewcode-block" id="get_thorimage_zstage_type"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_thorimage_zstage_type">[docs]</a><span class="nd">@thorimage_xml</span>
<span class="k">def</span> <span class="nf">get_thorimage_zstage_type</span><span class="p">(</span><span class="n">xml</span><span class="p">):</span>
    <span class="c1"># TODO TODO fastZ enabled imply that a ThorStage is actually piezo?</span>
    <span class="c1"># NO! (at least it&#39;s possible to misconfigure downstairs system so that non-piezo</span>
    <span class="c1"># stage is selected for both primary/secondary, and it will still let you collect a</span>
    <span class="c1"># recording with fast Z apparently enabled)</span>

    <span class="c1"># NOTE: enable=1 set in yang&#39;s newer test data, but not referenced in one of mine.</span>
    <span class="n">zstage</span> <span class="o">=</span> <span class="n">_get_zstage</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span><span class="o">.</span><span class="n">attrib</span>
    <span class="n">regtype</span> <span class="o">=</span> <span class="n">zstage</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">regtype</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ThorStage&#39;</span><span class="p">,</span> <span class="s1">&#39;ThorZPiezo&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">regtype</span></div>


<div class="viewcode-block" id="get_thorimage_power_regtype_and_level"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_thorimage_power_regtype_and_level">[docs]</a><span class="nd">@thorimage_xml</span>
<span class="c1"># TODO modify to return a third item, a dict w/ any remaining settings relevant to the</span>
<span class="c1"># particular power regulator (e.g. w/ &#39;offset&#39; for &#39;non-pockel&#39;, or &#39;minV&#39;/&#39;maxV&#39;/etc</span>
<span class="c1"># for pockel)?</span>
<span class="k">def</span> <span class="nf">get_thorimage_power_regtype_and_level</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Returns `regtype`, `power_level` where `regtype` is either &#39;pockel&#39;|&#39;non_pockel&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># looks like if there is any &lt;Pockels&gt; tag w/ start=&quot;&lt;nonzero&gt;&quot; (presumably ==</span>
    <span class="c1"># stop), then it&#39;s a pockel?</span>
    <span class="c1">#</span>
    <span class="c1"># there can still be &lt;PowerRegulator[2]&gt; elements w/ enable=&quot;1&quot;, just start/stop</span>
    <span class="c1"># should be 0</span>

    <span class="c1"># first element should be fine. seems to be only one that has non-zero start/stop</span>
    <span class="c1"># ever, at least in 3 test outputs from diff systems.</span>
    <span class="n">pockels</span> <span class="o">=</span> <span class="n">xml</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;Pockels&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrib</span>
    <span class="n">pockel_start</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">pockels</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">])</span>
    <span class="n">pockel_stop</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">pockels</span><span class="p">[</span><span class="s1">&#39;stop&#39;</span><span class="p">])</span>
    <span class="c1"># would need to support (and don&#39;t think we ever use)</span>
    <span class="k">assert</span> <span class="n">pockel_start</span> <span class="o">==</span> <span class="n">pockel_stop</span>

    <span class="n">reg</span> <span class="o">=</span> <span class="n">xml</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;PowerRegulator&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrib</span>
    <span class="n">reg_start</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">])</span>
    <span class="n">reg_stop</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="s1">&#39;stop&#39;</span><span class="p">])</span>
    <span class="c1"># would need to support (and don&#39;t think we ever use)</span>
    <span class="k">assert</span> <span class="n">reg_start</span> <span class="o">==</span> <span class="n">reg_stop</span>

    <span class="k">if</span> <span class="n">pockel_start</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">reg_start</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="c1"># TODO blank percentage? min/maxV? always return these other settings in 3rd</span>
        <span class="c1"># return arg as dict (and use for offset above?)?</span>
        <span class="k">return</span> <span class="s1">&#39;pockel&#39;</span><span class="p">,</span> <span class="n">pockel_start</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">reg_start</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="c1"># TODO better str here (&#39;waveplate&#39;? accurate?)?</span>
        <span class="c1"># TODO also return offset?</span>
        <span class="k">return</span> <span class="s1">&#39;non-pockel&#39;</span><span class="p">,</span> <span class="n">reg_start</span></div>


<div class="viewcode-block" id="print_xml"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.print_xml">[docs]</a><span class="nd">@thorimage_xml</span>
<span class="k">def</span> <span class="nf">print_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">:</span> <span class="n">Element</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">encoding</span> <span class="o">=</span> <span class="s1">&#39;utf-8&#39;</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span> <span class="n">encoding</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">))</span></div>


<span class="c1"># TODO unit test</span>
<span class="k">def</span> <span class="nf">_parse_driver_and_indicator</span><span class="p">(</span><span class="n">fly_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">debug</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>

    <span class="c1"># TODO move a \b from indicator to uas regex? have at start of both? make</span>
    <span class="c1"># optional in one/both?</span>
    <span class="c1"># works, at least for all but negative lookahead within driver</span>
    <span class="c1">#uas_regex = &#39;u?(?:as)?&#39;</span>
    <span class="n">uas_regex</span> <span class="o">=</span> <span class="s1">&#39;(?:u(?:as)?)&#39;</span>
    <span class="c1"># TODO explicitly exclude u[as] match in driver_regex?</span>
    <span class="c1"># (e.g. so that &#39;uas-6f&#39; doesn&#39;t parse as driver=&#39;uas&#39; indicator=&#39;6f&#39;)</span>
    <span class="n">driver_regex</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\b(?P&lt;driver&gt;\w+)\s?-\s?g?(?:al)?4?&#39;</span>
    <span class="c1"># TODO fix? was trying to get &quot;negative lookahead assertion&quot; to work to exclude</span>
    <span class="c1"># uas from matching in driver portion</span>
    <span class="c1"># https://stackoverflow.com/questions/5030041</span>
    <span class="c1"># (but can&#39;t get this one to match anything)</span>
    <span class="c1">#driver_regex = f&#39;\\b(?P&lt;driver&gt;^(?!{uas_regex})\\w+)\\s?-\\s?g?(?:al)?4?&#39;</span>

    <span class="c1"># TODO fix how we aren&#39;t matching e.g. &#39;6f&#39; alone</span>
    <span class="c1"># (or add a hack to try matching w/ just indicator_regex?)</span>
    <span class="c1">#</span>
    <span class="c1"># worked w/ commented uas_regex above</span>
    <span class="c1">#indicator_regex = f&#39;\\b{uas_regex}-?g?(?:camp)?(?P&lt;indicator&gt;[6-9][fms])\\b&#39;</span>
    <span class="n">indicator_regex</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">uas_regex</span><span class="si">}</span><span class="s1">?-?g?(?:camp)?(?P&lt;indicator&gt;[6-9][fms])</span><span class="se">\\</span><span class="s1">b&#39;</span>

    <span class="c1"># making driver_regex optional this way seems to break it... not sure why</span>
    <span class="c1"># fly_str=&#39;5 day old pb-Gal4/+;+;UAS-G6f/+ from prat&#39;</span>
    <span class="c1"># ipdb&gt; re.findall(f&#39;{driver_regex}.*{indicator_regex}&#39;, fly_str, flags=re.IGNORECASE)</span>
    <span class="c1"># [(&#39;pb&#39;, &#39;6f&#39;)]</span>
    <span class="c1"># ipdb&gt; re.findall(f&#39;(?:{driver_regex}).*{indicator_regex}&#39;, fly_str, flags=re.IGNORECASE)</span>
    <span class="c1"># [(&#39;pb&#39;, &#39;6f&#39;)]</span>
    <span class="c1"># ipdb&gt; re.findall(f&#39;(?:{driver_regex})?.*{indicator_regex}&#39;, fly_str, flags=re.IGNORECASE)</span>
    <span class="c1"># [(&#39;&#39;, &#39;6f&#39;)]</span>

    <span class="c1"># e.g. &#39;5 day old pb-Gal4/+;+;UAS-G6f/+ from prat&#39; -&gt; (&#39;pb&#39;, &#39;6f&#39;)</span>
    <span class="c1"># &#39;;&#39; and &#39;/&#39; seem to count as a word boundaries (\b)</span>
    <span class="c1"># TODO can i make driver_regex optional? can i do that be wrapping it w/ another</span>
    <span class="c1"># non-matching group here, or can&#39;t nest?</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">driver_regex</span><span class="si">}</span><span class="s1">.*</span><span class="si">{</span><span class="n">indicator_regex</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">fly_str</span><span class="p">,</span>
        <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span>
    <span class="p">)</span>
    <span class="n">driver</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">indicator</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">driver</span><span class="p">,</span> <span class="n">indicator</span> <span class="o">=</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">driver</span> <span class="o">=</span> <span class="n">driver</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="c1"># hack since i couldn&#39;t figure out how to exclude uas_regex match from</span>
        <span class="c1"># &lt;driver&gt; group in driver_regex above</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;^</span><span class="si">{</span><span class="n">uas_regex</span><span class="si">}</span><span class="s1">$&#39;</span><span class="p">,</span> <span class="n">driver</span><span class="p">):</span>
            <span class="n">driver</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># hack since i couldn&#39;t figure out how to get the one large regex to match</span>
        <span class="c1"># indicator strs by themselves</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">b</span><span class="si">{</span><span class="n">indicator_regex</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">fly_str</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
        <span class="c1"># TODO test this branch</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">indicator</span> <span class="o">=</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">indicator</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span>

    <span class="k">if</span> <span class="n">indicator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">indicator</span> <span class="o">=</span> <span class="n">indicator</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">driver</span><span class="p">,</span> <span class="n">indicator</span>


<div class="viewcode-block" id="parse_thorimage_notes"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.parse_thorimage_notes">[docs]</a><span class="nd">@thorimage_xml</span>
<span class="k">def</span> <span class="nf">parse_thorimage_notes</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">debug</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns dict of metadata, with `&lt;key&gt;: &lt;val&gt;` lines and rest parsed separately.</span>

<span class="sd">    Args:</span>
<span class="sd">        thorimage_dir_or_xml: path to ThorImage output directory or XML Element</span>
<span class="sd">            containing parsed contents of the corresponding Experiment.xml file.</span>

<span class="sd">    Lines not matching the `&lt;key&gt;: &lt;val&gt;` format will be appended together under the</span>
<span class="sd">    &#39;prose&#39; key in the returned dict.</span>

<span class="sd">    It is assumed there will be a single line with the YAML path from `olf`, and this</span>
<span class="sd">    line is not included in output (should be handled separately, via</span>
<span class="sd">    `util.stimulus_yaml_from_thorimage`, and would only add noise in dealing with what</span>
<span class="sd">    remains here).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">notes</span> <span class="o">=</span> <span class="n">get_thorimage_notes</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span>
    <span class="n">recording_start_time</span> <span class="o">=</span> <span class="n">get_thorimage_time</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;notes:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">notes</span><span class="p">)</span>

    <span class="c1"># TODO unit test?</span>
    <span class="c1"># TODO rename (_parse_power?)</span>
    <span class="k">def</span> <span class="nf">_match_power</span><span class="p">(</span><span class="n">power_str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;~?(?P&lt;power_mw&gt;\d+(\.\d*)?)\s?m[wW]\s*(?P&lt;power_note&gt;.*)\s*&#39;</span><span class="p">,</span>
            <span class="n">power_str</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">m</span>

        <span class="n">power_dict</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
        <span class="k">assert</span> <span class="p">(</span><span class="s1">&#39;power_mw&#39;</span> <span class="ow">in</span> <span class="n">power_dict</span> <span class="ow">and</span> <span class="s1">&#39;power_note&#39;</span> <span class="ow">in</span> <span class="n">power_dict</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">power_dict</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="n">power_dict</span><span class="p">[</span><span class="s1">&#39;power_mw&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">power_dict</span><span class="p">[</span><span class="s1">&#39;power_mw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">power_dict</span><span class="p">[</span><span class="s1">&#39;power_mw&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">power_dict</span>

    <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">non_dict_lines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">n_yaml_parts</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n_power_lines</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># stimulus_yaml_from_thorimage uses .split() instead of .splitlines(), so just want</span>
    <span class="c1"># to check that I never actually had any experiments where a line has a YAML path</span>
    <span class="c1"># AND any other non-whitespace chars. would be simpler to just use .splitlines() in</span>
    <span class="c1"># both places, if checks below never fail.</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">notes</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.yaml&#39;</span><span class="p">):</span>
            <span class="n">n_yaml_parts</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># should be the single line containing yaml_path (the path parsed by</span>
            <span class="c1"># hong2p.util.stimulus_yaml_from_thorimage)</span>
            <span class="k">continue</span>

        <span class="n">parts</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="c1"># see comment above if this ever fails</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.yaml&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">)</span>

        <span class="n">p0</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># seems this should be behavior of &lt;str&gt;.strip() no matter the amount of</span>
        <span class="c1"># whitespace</span>
        <span class="k">assert</span> <span class="n">p0</span> <span class="o">==</span> <span class="n">p0</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">p0</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">):</span>
            <span class="c1"># TODO may need to make parseing more complex (or just use a regex that</span>
            <span class="c1"># allows whitespace between key and &#39;:&#39; or something?), if this fails</span>
            <span class="k">assert</span> <span class="s1">&#39;:&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">line</span>

            <span class="n">power_dict</span> <span class="o">=</span> <span class="n">_match_power</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">power_dict</span><span class="p">:</span>
                <span class="c1"># TODO refactor to share?</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">in</span> <span class="n">data</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">power_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">data</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">power_dict</span><span class="p">)</span>
                <span class="n">n_power_lines</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1">#</span>
                <span class="k">continue</span>

            <span class="n">non_dict_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">p0</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">value</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="k">assert</span> <span class="n">key</span> <span class="o">!=</span> <span class="s1">&#39;prose&#39;</span>

        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;power&#39;</span><span class="p">:</span>
            <span class="n">power_dict</span> <span class="o">=</span> <span class="n">_match_power</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="c1"># TODO refactor to share?</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">power_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">value</span><span class="si">=}</span><span class="s1">&#39;</span>
            <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;could not parse power from &#39;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
                <span class="c1"># TODO or put this whole line into power_note instead?</span>
                <span class="n">non_dict_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">assert</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">in</span> <span class="n">data</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">power_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">data</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">power_dict</span><span class="p">)</span>
            <span class="n">n_power_lines</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1">#</span>
            <span class="k">continue</span>

        <span class="k">assert</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span>
        <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;prose&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">non_dict_lines</span><span class="p">)</span>

    <span class="c1"># TODO or maybe &lt;= 1 (if some recordings don&#39;t have this path, which should be true</span>
    <span class="c1"># for anatomical recording)</span>
    <span class="k">assert</span> <span class="n">n_yaml_parts</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="c1"># not guaranteed. should ffill from previous recordings on same fly.</span>
    <span class="k">assert</span> <span class="n">n_power_lines</span> <span class="o">&lt;=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="s1">&#39;fly&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="c1"># TODO also support strings like this:</span>
        <span class="c1"># &#39;pb&gt;6f (same lines/genetics as all recent experiments), ecclosed 11/14. from</span>
        <span class="c1"># sam.&#39;</span>
        <span class="c1"># TODO TODO why current date parsing not working w/ ecclosed 11/14?</span>

        <span class="c1"># example strings to match:</span>
        <span class="c1"># &#39;5 day old pb-Gal4/+;+;UAS-G6f/+ from prat&#39;</span>
        <span class="n">fly_str</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;fly&#39;</span><span class="p">]</span>

        <span class="c1"># TODO is this guaranteed to match largest number of chars for n_days_old that</span>
        <span class="c1"># would satisfy \d+? using search (vs match) in case i didn&#39;t always say this at</span>
        <span class="c1"># start of fly line value</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\b(?P&lt;n_days_old&gt;\d+)\s*days?(?:\sold)?\b&#39;</span><span class="p">,</span> <span class="n">fly_str</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">m</span><span class="p">[</span><span class="s1">&#39;n_days_old&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">n_days_old</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="s1">&#39;n_days_old&#39;</span><span class="p">])</span>
            <span class="c1"># see comment below on why i&#39;m assuming it starts from 1</span>
            <span class="k">assert</span> <span class="n">n_days_old</span> <span class="o">&gt;=</span> <span class="mi">1</span>
            <span class="c1"># TODO delete</span>
            <span class="c1">#assert n_days_old &gt;= 0</span>
            <span class="k">assert</span> <span class="s1">&#39;n_days_old&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_days_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_days_old</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">n_days_old</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;no match for n_days_old!&#39;</span><span class="p">)</span>

            <span class="c1"># TODO similar post-processing of &#39;odors&#39; value (look for date)?</span>
            <span class="c1"># example odor strings to match:</span>
            <span class="c1"># (actually do i want to match this? can i always rely on just getting first</span>
            <span class="c1"># date?)</span>
            <span class="c1"># &#39;3/27 except few diagnostics changed on 4/11&#39;</span>

            <span class="c1"># TODO should there need to be an &#39;ec[c]losed &#39; prefix? is there always tho?</span>
            <span class="c1"># &#39;pb-Gal/x;;U-G6f/+ eclosed 4/23&#39;</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\b(?P&lt;month&gt;\d\d?)/(?P&lt;day&gt;\d\d?)\b&#39;</span><span class="p">,</span> <span class="n">fly_str</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">matches</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">)</span>

                <span class="c1"># only one date should be in line</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">month</span><span class="p">,</span> <span class="n">day</span> <span class="o">=</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># TODO warn if recording_start_time is in first few weeks of year?</span>
                <span class="n">eclosion_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="n">recording_start_time</span><span class="o">.</span><span class="n">year</span><span class="p">,</span>
                    <span class="n">month</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">month</span><span class="p">),</span> <span class="n">day</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">day</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># TODO TODO are flies considered 1 or 0 days old on eclosion day?</span>
                <span class="c1"># (let&#39;s operate under assumption it&#39;s 1 for now)</span>
                <span class="c1"># what have i been doing before? what does prat think? what&#39;s min of</span>
                <span class="c1"># n_days_old values parsed directly in branch above?</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">recording_start_time</span> <span class="o">-</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">hours</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>

                <span class="c1"># this seems to be essentially taking floor, since seconds/etc fields</span>
                <span class="c1"># can be &gt;=0, but are ignored by using .days (e.g. so any time on 4/26</span>
                <span class="c1"># is still 3 days after eclosion_date=4/23)</span>
                <span class="n">n_days_old</span> <span class="o">=</span> <span class="p">(</span><span class="n">curr</span> <span class="o">-</span> <span class="n">eclosion_date</span><span class="p">)</span><span class="o">.</span><span class="n">days</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_days_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_days_old</span>
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">eclosion_date</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">curr</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">n_days_old</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;no match for eclosion_date!&#39;</span><span class="p">)</span>

        <span class="n">driver</span><span class="p">,</span> <span class="n">indicator</span> <span class="o">=</span> <span class="n">_parse_driver_and_indicator</span><span class="p">(</span><span class="n">fly_str</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">)</span>
        <span class="k">assert</span> <span class="s1">&#39;driver&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;driver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">driver</span>
        <span class="k">assert</span> <span class="s1">&#39;indicator&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;indicator&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">indicator</span>

    <span class="c1"># there should also not be any whitespace-only string values at this point</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;data:&#39;</span><span class="p">)</span>
        <span class="n">pprint</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="load_thorimage_metadata"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.load_thorimage_metadata">[docs]</a><span class="k">def</span> <span class="nf">load_thorimage_metadata</span><span class="p">(</span><span class="n">thorimage_dir</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">,</span> <span class="n">return_xml</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns (fps, xy, z, c, n_flyback, raw_output_path) for ThorImage dir.</span>

<span class="sd">    Returns xml as an additional final return value if `return_xml` is True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">thorimage_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">thorimage_dir</span><span class="p">)</span>
    <span class="n">xml</span> <span class="o">=</span> <span class="n">get_thorimage_xmlroot</span><span class="p">(</span><span class="n">thorimage_dir</span><span class="p">)</span>

    <span class="c1"># TODO TODO in volumetric streaming case (at least w/ input from thorimage</span>
    <span class="c1"># 3.0 from downstairs scope), this is the xy fps (&lt; time per volume). also</span>
    <span class="c1"># doesn&#39;t include flyback frame. probably want to convert it to</span>
    <span class="c1"># volumes-per-second in that case here, and return that for fps. just need</span>
    <span class="c1"># to check it doesn&#39;t break other stuff.</span>
    <span class="n">fps</span> <span class="o">=</span> <span class="n">get_thorimage_fps_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span>
    <span class="n">xy</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">get_thorimage_dims</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span>

    <span class="n">n_flyback_frames</span> <span class="o">=</span> <span class="n">get_thorimage_n_flyback_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">n_flyback_frames</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;n_flyback_frames &gt; 0 but z == 1&#39;</span>

    <span class="c1"># So far, I have seen this be one of:</span>
    <span class="c1"># - Image_0001_0001.raw</span>
    <span class="c1"># - Image_001_001.raw</span>
    <span class="c1"># ...but not sure if there any meaning behind the differences.</span>
    <span class="n">imaging_files</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">thorimage_dir</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;Image_*.raw&#39;</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">imaging_files</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;no .raw files in ThorImage directory </span><span class="si">{</span><span class="n">thorimage_dir</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">imaging_files</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;multiple .raw files in ThorImage directory &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">thorimage_dir</span><span class="si">}</span><span class="s1">. ambiguous!&#39;</span>
        <span class="p">)</span>

    <span class="n">imaging_file</span> <span class="o">=</span> <span class="n">imaging_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># TODO probably return as some kind of dict / dataclass, and always return xml while</span>
    <span class="c1"># we are at it</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_xml</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fps</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n_flyback_frames</span><span class="p">,</span> <span class="n">imaging_file</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fps</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n_flyback_frames</span><span class="p">,</span> <span class="n">imaging_file</span><span class="p">,</span> <span class="n">xml</span></div>


<span class="n">thorsync_xml_basename</span> <span class="o">=</span> <span class="s1">&#39;ThorRealTimeDataSettings.xml&#39;</span>
<div class="viewcode-block" id="get_thorsync_xml_path"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_thorsync_xml_path">[docs]</a><span class="k">def</span> <span class="nf">get_thorsync_xml_path</span><span class="p">(</span><span class="n">thorsync_dir</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes ThorSync output dir to (expected) path to its XML output.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">join</span><span class="p">(</span><span class="n">thorsync_dir</span><span class="p">,</span> <span class="n">thorsync_xml_basename</span><span class="p">)</span></div>


<span class="c1"># TODO is this also updated past start of recording, as I think the ThorImage</span>
<span class="c1"># one is?</span>
<div class="viewcode-block" id="get_thorsync_time"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_thorsync_time">[docs]</a><span class="k">def</span> <span class="nf">get_thorsync_time</span><span class="p">(</span><span class="n">thorsync_dir</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns modification time of ThorSync XML.</span>

<span class="sd">    Not perfect, but it doesn&#39;t seem any ThorSync outputs have timestamps.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">syncxml</span> <span class="o">=</span> <span class="n">get_thorsync_xml_path</span><span class="p">(</span><span class="n">thorsync_dir</span><span class="p">)</span>
    <span class="c1"># TODO is there not a timestamp embedded?</span>
    <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">fromtimestamp</span><span class="p">(</span><span class="n">getmtime</span><span class="p">(</span><span class="n">syncxml</span><span class="p">))</span></div>


<span class="n">thorsync_h5_basename</span> <span class="o">=</span> <span class="s1">&#39;Episode001.h5&#39;</span>
<div class="viewcode-block" id="is_thorsync_h5"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.is_thorsync_h5">[docs]</a><span class="k">def</span> <span class="nf">is_thorsync_h5</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;True if filename indicates file is ThorSync HDF5 output.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">f_basename</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="c1"># So far I&#39;ve only seen these files named *exactly* &#39;Episode001.h5&#39;, but</span>
    <span class="c1"># this function could be adapted if this naming convention has some</span>
    <span class="c1"># variations in the future.</span>
    <span class="k">if</span> <span class="n">f_basename</span> <span class="o">==</span> <span class="n">thorsync_h5_basename</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="get_thorsync_samplerate_hz"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_thorsync_samplerate_hz">[docs]</a><span class="k">def</span> <span class="nf">get_thorsync_samplerate_hz</span><span class="p">(</span><span class="n">thorsync_dir</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns int sample rate (Hz) of ThorSync HDF5 data in `thorsync_dir`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xml_path</span> <span class="o">=</span> <span class="n">get_thorsync_xml_path</span><span class="p">(</span><span class="n">thorsync_dir</span><span class="p">)</span>
    <span class="n">xml</span> <span class="o">=</span> <span class="n">xmlroot</span><span class="p">(</span><span class="n">xml_path</span><span class="p">)</span>
    <span class="n">devices</span> <span class="o">=</span> <span class="n">xml</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;DaqDevices&#39;</span><span class="p">)</span>

    <span class="c1"># TODO some of the keys seem to hint that this xml also describes which</span>
    <span class="c1"># channel was used to trigger the recording, though they don&#39;t seem set as i</span>
    <span class="c1"># would think... maybe they are for something else</span>
    <span class="c1"># (if this data is there, could automatically pull out the channel that is</span>
    <span class="c1"># used to trigger the thorimage recording, or something like that)</span>
    <span class="c1"># (maybe that data is in thorimage config actually?)</span>

    <span class="n">active_device</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">device</span> <span class="ow">in</span> <span class="n">devices</span><span class="o">.</span><span class="n">getchildren</span><span class="p">():</span>
        <span class="n">attrib</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">attrib</span>

        <span class="k">if</span> <span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Simulator&#39;</span> <span class="ow">or</span> <span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;devID&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;NONE&#39;</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;active&#39;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">active_device</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;multiple AcquireBoard elements active in &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">xml_path</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="p">)</span>
            <span class="n">active_device</span> <span class="o">=</span> <span class="n">device</span>

    <span class="k">if</span> <span class="n">active_device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;no AcquireBoard elements active in </span><span class="si">{</span><span class="n">xml_path</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">samplerate_hz</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">samprate_ele</span> <span class="ow">in</span> <span class="n">active_device</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;SampleRate&#39;</span><span class="p">):</span>
        <span class="n">attrib</span> <span class="o">=</span> <span class="n">samprate_ele</span><span class="o">.</span><span class="n">attrib</span>
        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;enable&#39;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">samplerate_hz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;multiple SampleRate elements active in &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">xml_path</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="p">)</span>
            <span class="n">samplerate_hz</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">samprate_ele</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;rate&#39;</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">samplerate_hz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;no SampleRate elements active in </span><span class="si">{</span><span class="n">xml_path</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">samplerate_hz</span></div>


<div class="viewcode-block" id="get_thorsync_h5"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_thorsync_h5">[docs]</a><span class="k">def</span> <span class="nf">get_thorsync_h5</span><span class="p">(</span><span class="n">thorsync_dir</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns path to ThorSync .h5 output given a directory created by ThorSync</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># NOTE: if in the future this filename varies, could instead iterate over</span>
    <span class="c1"># files, calling `is_thorsync_h5` and returning list / [asserting one +</span>
    <span class="c1"># returning it]</span>
    <span class="k">return</span> <span class="n">join</span><span class="p">(</span><span class="n">thorsync_dir</span><span class="p">,</span> <span class="n">thorsync_h5_basename</span><span class="p">)</span></div>


<span class="c1"># TODO rename to indicate a thor (+raw?) format</span>
<span class="c1"># TODO rename to &#39;load_movie&#39; to be consistent w/ other similar fns in here?</span>
<span class="c1"># TODO refactor this to something like &#39;load_thorimage_raw&#39; + have</span>
<span class="c1"># &#39;[load/read]_movie&#39; call either this or appropriate tifffile calls to load any</span>
<span class="c1"># TIFF outputs thorimage might have saved (check that dimension orders are the</span>
<span class="c1"># same!)?</span>
<div class="viewcode-block" id="read_movie"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.read_movie">[docs]</a><span class="k">def</span> <span class="nf">read_movie</span><span class="p">(</span><span class="n">thorimage_dir</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">,</span> <span class="n">discard_flyback</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">discard_channel_b</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">checks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">_debug</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns (t,[z,]y,x) indexed timeseries as a numpy array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">thorimage_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">thorimage_dir</span><span class="p">)</span>
    <span class="n">fps</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n_flyback</span><span class="p">,</span> <span class="n">imaging_file</span><span class="p">,</span> <span class="n">xml</span> <span class="o">=</span> <span class="n">load_thorimage_metadata</span><span class="p">(</span><span class="n">thorimage_dir</span><span class="p">,</span>
        <span class="n">return_xml</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>

    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">xy</span>

    <span class="c1"># From ThorImage manual: &quot;unsigned, 16-bit, with little-endian byte-order&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;&lt;u2&#39;</span><span class="p">)</span>

    <span class="n">pmt</span> <span class="o">=</span> <span class="n">xml</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;PMT&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrib</span>
    <span class="k">if</span> <span class="n">checks</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">int</span><span class="p">(</span><span class="n">pmt</span><span class="p">[</span><span class="s1">&#39;enableA&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">pmt</span><span class="p">[</span><span class="s1">&#39;gainA&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;channel A not used&#39;</span>

    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">pmt</span><span class="p">[</span><span class="s1">&#39;enableB&#39;</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">pmt</span><span class="p">[</span><span class="s1">&#39;gainB&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;channel B was enabled but gain was zero. discarding.&#39;</span><span class="p">)</span>
            <span class="n">discard_channel_b</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">discard_channel_b</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;you may set discard_channel_b=True for now&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Not warning / erroring in this case so that discard_channel_b can be specified</span>
        <span class="c1"># for data that may or may not have channel B, without extra nuisance.</span>
        <span class="n">discard_channel_b</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">imaging_file</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># TODO maybe just don&#39;t read the data known to be flyback frames?</span>

    <span class="n">n_frame_pixels</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
    <span class="n">n_frames</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">//</span> <span class="n">n_frame_pixels</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">%</span> <span class="n">n_frame_pixels</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;apparent incomplete frames&#39;</span>

    <span class="n">n_frames</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">n_frames</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">remainder</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="c1"># This does not fail in the volumetric case, because &#39;frames&#39; here</span>
    <span class="c1"># refers to XY frames there too.</span>
    <span class="c1"># TODO test this assertion on all data, though perhaps via a new function</span>
    <span class="c1"># get get expected n_frames from size of .raw file + other metadata</span>
    <span class="c1"># (mentioned in comments above get_thorimage_dims)</span>
    <span class="k">assert</span> <span class="n">n_frames</span> <span class="o">==</span> <span class="n">get_thorimage_n_frames</span><span class="p">(</span><span class="n">xml</span><span class="p">),</span> \
        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">n_frames</span><span class="si">}</span><span class="s1"> != </span><span class="si">{</span><span class="n">get_thorimage_n_frames</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="c1"># TODO delete?</span>
    <span class="k">if</span> <span class="n">_debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;read_movie: initial </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;read_movie: </span><span class="si">{</span><span class="n">x</span><span class="si">=}</span><span class="s1"> </span><span class="si">{</span><span class="n">y</span><span class="si">=}</span><span class="s1"> </span><span class="si">{</span><span class="n">z</span><span class="si">=}</span><span class="s1"> </span><span class="si">{</span><span class="n">n_frames</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="c1">#</span>

    <span class="c1"># TODO how to reshape if there are also multiple channels?</span>

    <span class="c1"># TODO TODO TODO just delete the data that needed special casing here unless it</span>
    <span class="c1"># actually seems like it might be useful -&gt; delete the special casing in the code</span>
    <span class="k">if</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># TODO TODO some way to set pockel power to zero during flyback frames?</span>
        <span class="c1"># not sure why that data is even wasting space in the file...</span>
        <span class="c1"># TODO possible to skip reading the flyback frames? maybe it wouldn&#39;t</span>
        <span class="c1"># save time though...</span>
        <span class="c1"># just so i can hardcode some fixes based on part of path (assuming</span>
        <span class="c1"># certain structure under mb_team, at least for the inputs i need to</span>
        <span class="c1"># fix)</span>
        <span class="n">thorimage_dir</span> <span class="o">=</span> <span class="n">thorimage_dir</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>
        <span class="n">date_part</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">thorimage_dir</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">try_to_fix_flyback</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># TODO do more testing to determine 1) if this really was a flyback issue and</span>
        <span class="c1"># not some bug in thor / some change in thor behavior on update, and 2) what is</span>
        <span class="c1"># appropriate flyback [and which change from 2020-04-* stuff is what made this</span>
        <span class="c1"># flyback innapropriate? less averaging?]</span>
        <span class="k">if</span> <span class="n">date_part</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;2020-11-29&#39;</span><span class="p">,</span> <span class="s1">&#39;2020-11-30&#39;</span><span class="p">}:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;trying to fix flyback frames since date_part match&#39;</span><span class="p">)</span>
            <span class="c1"># this branch is purely a hacky fix to what seems like an</span>
            <span class="c1"># insufficient number of flyback frames with data from a few</span>
            <span class="c1"># particular days.</span>
            <span class="n">try_to_fix_flyback</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">n_flyback</span> <span class="o">=</span> <span class="n">n_flyback</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">z_total</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="n">n_flyback</span>

        <span class="n">orig_n_frames</span> <span class="o">=</span> <span class="n">n_frames</span>
        <span class="n">n_frames</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">n_frames</span><span class="p">,</span> <span class="n">z_total</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">try_to_fix_flyback</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">remainder</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">try_to_fix_flyback</span> <span class="ow">and</span> <span class="n">remainder</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># TODO maybe don&#39;t warn [the same way?] if dropped frames are just</span>
            <span class="c1"># flyback-equivalent?</span>

            <span class="c1"># remainder is int but checking equality against float still works</span>
            <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="p">(</span><span class="n">n_frame_pixels</span> <span class="o">*</span> <span class="n">remainder</span><span class="p">)])</span>
                <span class="p">)</span> <span class="o">/</span> <span class="n">n_frame_pixels</span> <span class="o">==</span> <span class="n">remainder</span>

            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;dropping last </span><span class="si">{</span><span class="n">remainder</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">orig_n_frames</span><span class="si">}</span><span class="s1"> frames &#39;</span>
                <span class="s1">&#39;because of flyback issue&#39;</span>
            <span class="p">)</span>
            <span class="c1"># otherwise the reshape won&#39;t work, because it requires even</span>
            <span class="c1"># division</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="p">(</span><span class="n">n_frame_pixels</span> <span class="o">*</span> <span class="n">remainder</span><span class="p">)]</span>

            <span class="c1"># TODO maybe some other check that flyback time was appropriate (to</span>
            <span class="c1"># not have to hardcode certain paths + to identify accidental</span>
            <span class="c1"># flyback issues) [if flyback is even the issue at all... do more</span>
            <span class="c1"># tests] (or just pass through a flag... including to thor2tiff)</span>

        <span class="c1"># TODO check this against method by reshaping as before and slicing</span>
        <span class="c1"># w/ appropriate strides [+ concatenating?] (what was &quot;before&quot;?)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">n_frames</span><span class="p">,</span> <span class="n">z_total</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">discard_flyback</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="p">:</span><span class="n">z</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># TODO test multi-channel handling in this case</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">n_frames</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>

    <span class="c1"># TODO delete</span>
    <span class="k">if</span> <span class="n">_debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;read_movie: after reshaping </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="c1">#</span>

    <span class="k">if</span> <span class="n">discard_channel_b</span><span class="p">:</span>
        <span class="c1"># TODO delete?</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        if _debug:</span>
<span class="sd">            from hong2p.viz import image_grid</span>
<span class="sd">            import matplotlib.pyplot as plt</span>

<span class="sd">            mean = data.mean(axis=0)</span>

<span class="sd">            if len(mean.shape) == 4:</span>
<span class="sd">                ch1_images = mean[:, 0]</span>
<span class="sd">                ch2_images = mean[:, 1]</span>

<span class="sd">            elif len(mean.shape) == 3:</span>
<span class="sd">                ch1_images = [mean[0]]</span>
<span class="sd">                ch2_images = [mean[1]]</span>

<span class="sd">            else:</span>
<span class="sd">                assert False</span>

<span class="sd">            # To visually verify that the data in this channel (when gain is zero) is</span>
<span class="sd">            # not meaningful and can be discarded</span>
<span class="sd">            image_grid(ch1_images)</span>
<span class="sd">            image_grid(ch2_images)</span>
<span class="sd">            plt.show()</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1"># TODO delete</span>
        <span class="k">if</span> <span class="n">_debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;read_movie: </span><span class="si">{</span><span class="n">slices</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;read_movie: assuming </span><span class="si">{</span><span class="n">slices</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="si">=}</span><span class="s1"> corresponds to color channel dim&#39;</span><span class="p">)</span>
        <span class="c1">#</span>

        <span class="c1"># (the channel dimension)</span>
        <span class="n">slices</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slices</span><span class="p">)]</span>
        <span class="c1"># TODO delete</span>
        <span class="k">if</span> <span class="n">_debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;read_movie: after slicing to exclude color channel </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;channel dimension should no longer&#39;</span>
            <span class="s1">&#39;be in shape&#39;</span>
        <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Just for now, since write_tiff currently doesn&#39;t support the extra dimension</span>
        <span class="c1"># the &#39;c&#39; channel would add.</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span> <span class="ow">and</span>
            <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[(</span><span class="o">-</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):])</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;data.shape: </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span>

        <span class="k">assert</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;c: </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s1">, data.shape: </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span></div>


<span class="k">def</span> <span class="nf">_get_column</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">possible_col_names</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns `pd.Series` corresponding to first matching column in `df`.</span>

<span class="sd">    Raises ValueError if no matches are found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">possible_col_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="n">possible_col_names</span><span class="p">]</span>

    <span class="n">col</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">possible_col_names</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;no column with name in </span><span class="si">{</span><span class="n">possible_col_names</span><span class="si">}</span><span class="s1"> in df&#39;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">col</span>


<span class="n">time_col</span> <span class="o">=</span> <span class="s1">&#39;time_s&#39;</span>
<span class="n">hdf5_default_exclude_datasets</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s1">&#39;piezo_monitor&#39;</span><span class="p">,</span>
    <span class="s1">&#39;pockels1_monitor&#39;</span><span class="p">,</span>
    <span class="s1">&#39;frame_in&#39;</span><span class="p">,</span>
    <span class="s1">&#39;light_path_shutter&#39;</span><span class="p">,</span>
    <span class="s1">&#39;flipper_mirror&#39;</span><span class="p">,</span>
    <span class="s1">&#39;pid&#39;</span><span class="p">,</span>
    <span class="s1">&#39;frame_counter&#39;</span><span class="p">,</span>
<span class="p">)</span>
<span class="c1"># Any datasets with names in the keys of this dict will have the corresponding</span>
<span class="c1"># value used for the column name. This will happen before any lowercasing /</span>
<span class="c1"># space-&gt;underscore conversion in `load_thorsync_hdf5`.</span>
<span class="n">hdf5_dataset_rename_dict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1"># Adding the space when column names lack it, so underscore separated</span>
    <span class="c1"># version will become the standard after normalization.</span>
    <span class="s1">&#39;FrameIn&#39;</span><span class="p">:</span> <span class="s1">&#39;Frame In&#39;</span><span class="p">,</span>
    <span class="s1">&#39;FrameOut&#39;</span><span class="p">:</span> <span class="s1">&#39;Frame Out&#39;</span><span class="p">,</span>
    <span class="s1">&#39;FrameCounter&#39;</span><span class="p">:</span> <span class="s1">&#39;Frame Counter&#39;</span><span class="p">,</span>

    <span class="c1"># Also lower casing this one since it&#39;s under the AI group, and wouldn&#39;t be</span>
    <span class="c1"># lower cased automatically.</span>
    <span class="s1">&#39;PiezoMonitor&#39;</span><span class="p">:</span> <span class="s1">&#39;piezo monitor&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Piezo Monitor&#39;</span><span class="p">:</span> <span class="s1">&#39;piezo monitor&#39;</span><span class="p">,</span>

    <span class="c1"># Stuff under AI that wouldn&#39;t be lowercased automatically, but that I still</span>
    <span class="c1"># want snakecase for, to be consistent. I believe the pockels monitor</span>
    <span class="c1"># channel might be a Thor built-in output, even though it&#39;s under AI?</span>
    <span class="s1">&#39;Pockels1Monitor&#39;</span><span class="p">:</span> <span class="s1">&#39;pockels1_monitor&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Pockels1 Monitor&#39;</span><span class="p">:</span> <span class="s1">&#39;pockels1_monitor&#39;</span><span class="p">,</span>
    <span class="s1">&#39;flipperMirror&#39;</span><span class="p">:</span> <span class="s1">&#39;flipper_mirror&#39;</span><span class="p">,</span>
    <span class="s1">&#39;lightPathShutter&#39;</span><span class="p">:</span> <span class="s1">&#39;light_path_shutter&#39;</span><span class="p">,</span>
    <span class="s1">&#39;lightpathshutter&#39;</span><span class="p">:</span> <span class="s1">&#39;light_path_shutter&#39;</span><span class="p">,</span>
    <span class="s1">&#39;olfDispPin&#39;</span><span class="p">:</span> <span class="s1">&#39;olf_disp_pin&#39;</span><span class="p">,</span>
    <span class="s1">&#39;scopePin&#39;</span><span class="p">:</span> <span class="s1">&#39;scope_pin&#39;</span><span class="p">,</span>
<span class="p">}</span>
<span class="c1"># TODO maybe refactor this a bit and add a function to list datasets, just so</span>
<span class="c1"># people can figure out their own data post hoc w/o needing other tools</span>
<span class="c1"># TODO account for return_dataset_names_only=True path in return typehint</span>
<div class="viewcode-block" id="load_thorsync_hdf5"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.load_thorsync_hdf5">[docs]</a><span class="k">def</span> <span class="nf">load_thorsync_hdf5</span><span class="p">(</span><span class="n">thorsync_dir</span><span class="p">,</span> <span class="n">datasets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude_datasets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">drop_gctr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_dataset_names_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">skip_dict_rename</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">skip_normalization</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rename_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_tqdm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">_debug</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Loads ThorSync .h5 output within `thorsync_dir` into a `pd.DataFrame`</span>

<span class="sd">    A column &#39;time_s&#39; will be added, which is derived from &#39;GCtr&#39;, and</span>
<span class="sd">    represents the time (in seconds) from the start of the ThorSync recording.</span>

<span class="sd">    Args:</span>
<span class="sd">        datasets (iterable of str | None): Load only datasets with these names.</span>
<span class="sd">            Do not include the group names preceding the dataset name. Pass only</span>
<span class="sd">            one of either this or `exclude_datasets`. Names are checked after any</span>
<span class="sd">            renaming via `rename_dict` or normalization.</span>

<span class="sd">        exclude_datasets (iterable of str | False | None): Load only datasets *except*</span>
<span class="sd">            those with these names. Do not include &#39;gctr&#39; here. Defaults to</span>
<span class="sd">            `hdf5_default_exclude_datasets` if neither this nor `datasets` is passed.</span>
<span class="sd">            If `False`, all datasets are loaded.</span>

<span class="sd">        drop_gctr (bool): (default=True) Drop &#39;/Global/GCtr&#39; data (would be returned</span>
<span class="sd">            as column &#39;gctr&#39;) after using it to calculate &#39;time_s&#39; column.</span>

<span class="sd">        rename_dict (None or dict): (default=None) a dict of original-&gt;new name. If</span>
<span class="sd">            not passed, `hdf5_dataset_rename_dict` is used. Applied before any</span>
<span class="sd">            further operations on the column (dataset) names.</span>

<span class="sd">    These HDF5 files have the following hierarchical structure, where leaves of</span>
<span class="sd">    this tree are &quot;Datasets&quot; and their parents are &quot;Groups&quot; (via inspection of a</span>
<span class="sd">    ThorSync 3.0 output):</span>
<span class="sd">    - Global:</span>
<span class="sd">      - GCtr</span>
<span class="sd">        (from ThorSync 3.0 manual) &quot;ThorSync records data into a table with</span>
<span class="sd">        clock cycles beginning with 0.  The time of acquisition can be</span>
<span class="sd">        determined by dividing the clock cycle by the frequency of the data</span>
<span class="sd">        collection set at 20 MHz. Thus, each sequential clock cycle represents</span>
<span class="sd">        an increment of 0.05 μs.&quot;</span>

<span class="sd">        Note that this 20 MHz is not the same as the sampling rate specified in</span>
<span class="sd">        the ThorSync XML output. See commented example at end of this function.</span>

<span class="sd">    - DI:</span>
<span class="sd">      - Frame In</span>
<span class="sd">        - completely zero in the file I was exploring</span>

<span class="sd">      - Frame Out</span>
<span class="sd">        - may have one high pulse (==2 for some reason; low==0) per frame</span>
<span class="sd">        - seems to only be low briefly before returning high again. perhaps just</span>
<span class="sd">          for one / a few samples?</span>
<span class="sd">        - it may be possible there are cases where there are more high pulses</span>
<span class="sd">          here than there are frames in the movie, perhaps in cases with</span>
<span class="sd">          averaging or multiple separate acquisition periods.</span>

<span class="sd">    - CI:</span>
<span class="sd">      - Frame Counter</span>

<span class="sd">    - AI:</span>
<span class="sd">      - &lt;one entry for each user-configured analog input&gt;</span>

<span class="sd">    Three changes will be made in translating HDF5 dataset names to DataFrame</span>
<span class="sd">    column names:</span>
<span class="sd">    1. If any dataset name is in the keys of `rename_dict`, it will be replaced</span>
<span class="sd">       with the corresponding value, unless `skip_dict_rename` is passed.</span>

<span class="sd">    2. Names *except* those under the group &#39;AI&#39; (mostly user configurable</span>
<span class="sd">       inputs) will be lowercased, unless `skip_normalization` is passed.</span>

<span class="sd">    3. All names will have any spaces converted to underscores, unless</span>
<span class="sd">       `skip_normalization` is passed.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO TODO DI/Frame [In/Out] useful? how?</span>

    <span class="c1"># I tried to use `pd.read_hdf` in place of this, but no matter how I used it</span>
    <span class="c1"># (tried various arguments to key=), just got various errors.</span>
    <span class="kn">import</span> <span class="nn">h5py</span>

    <span class="c1"># TODO maybe just silently ignore exclude_datasets if datasets is passed, so</span>
    <span class="c1"># i can have some defaults in exclude_datasets that can be overridden if</span>
    <span class="c1"># need be...</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">datasets</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">exclude_datasets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;only pass at most one of datasets or exclude_datasets&#39;</span><span class="p">)</span>

    <span class="n">using_default_excludes</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">datasets</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">exclude_datasets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">using_default_excludes</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">exclude_datasets</span> <span class="o">=</span> <span class="n">hdf5_default_exclude_datasets</span>

    <span class="c1"># Structure of hdf5 can be explored via:</span>
    <span class="c1"># h5dump -H &lt;h5 path&gt;</span>
    <span class="c1"># (need to `sudo apt install hdf5-tools` first)</span>
    <span class="n">hdf5_fname</span> <span class="o">=</span> <span class="n">get_thorsync_h5</span><span class="p">(</span><span class="n">thorsync_dir</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">_debug</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">getsize</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;HDF5 (</span><span class="si">{</span><span class="n">hdf5_fname</span><span class="si">}</span><span class="s1">) size: </span><span class="si">{</span><span class="n">getsize</span><span class="p">(</span><span class="n">hdf5_fname</span><span class="p">)</span><span class="si">:</span><span class="s1">,</span><span class="si">}</span><span class="s1"> bytes&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">rename_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rename_dict</span> <span class="o">=</span> <span class="n">hdf5_dataset_rename_dict</span>

    <span class="k">if</span> <span class="n">return_dataset_names_only</span><span class="p">:</span>
        <span class="n">full_dataset_names</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">data_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">load_datasets</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="c1"># Could also check if `obj` has a &#39;shape&#39; attribute if this approach has</span>
        <span class="c1"># issues.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">h5py</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">return_dataset_names_only</span><span class="p">:</span>
                <span class="n">full_dataset_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="n">parent_name</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span>

            <span class="c1"># In data from 2019-05-03/3/SyncData002, this has keys &#39;Hz&#39; and</span>
            <span class="c1"># &#39;FitHz&#39; under it, each of shape (3000, 1) (&lt;&lt; length of other</span>
            <span class="c1"># arrays, so would cause DataFrame creation to fail). min/max of</span>
            <span class="c1"># both datasets were 0, so they don&#39;t seem to be used, at least as I</span>
            <span class="c1"># had the acquisition configured.</span>
            <span class="k">if</span> <span class="n">parent_name</span> <span class="o">==</span> <span class="s1">&#39;/Freq&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;skipping </span><span class="si">{</span><span class="n">obj</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> because it is under /Freq, and will &#39;</span>
                        <span class="s1">&#39;have a different length than the other datasets&#39;</span>
                    <span class="p">)</span>

                <span class="k">return</span>

            <span class="c1"># Excluding the names of the Group(s) containing this Dataset.</span>
            <span class="n">dataset_name</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">name</span><span class="p">[(</span><span class="nb">len</span><span class="p">(</span><span class="n">parent_name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;parent name:&#39;</span><span class="p">,</span> <span class="n">parent_name</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;original name:&#39;</span><span class="p">,</span> <span class="n">dataset_name</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_dict_rename</span> <span class="ow">and</span> <span class="n">dataset_name</span> <span class="ow">in</span> <span class="n">rename_dict</span><span class="p">:</span>
                <span class="n">dataset_name</span> <span class="o">=</span> <span class="n">rename_dict</span><span class="p">[</span><span class="n">dataset_name</span><span class="p">]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_normalization</span><span class="p">:</span>
                <span class="c1"># Seemingly consistent with what the Thorlabs MATLAB scripts are</span>
                <span class="c1"># doing, and something I&#39;d want to do anyway.</span>
                <span class="n">dataset_name</span> <span class="o">=</span> <span class="n">dataset_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">parent_name</span> <span class="o">!=</span> <span class="s1">&#39;/AI&#39;</span><span class="p">:</span>
                    <span class="c1"># This could in theory eliminate some uniqueness of the</span>
                    <span class="c1"># names, but in practice it really shouldn&#39;t.  Not doing</span>
                    <span class="c1"># this for all keys so that things like &#39;olfDispPin&#39; don&#39;t</span>
                    <span class="c1"># become hard to read.</span>
                    <span class="n">dataset_name</span> <span class="o">=</span> <span class="n">dataset_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;normalized name:&#39;</span><span class="p">,</span> <span class="n">dataset_name</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">datasets</span> <span class="ow">and</span> <span class="n">dataset_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;skipping because not among names passed in datasets</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="k">return</span>

            <span class="k">if</span> <span class="n">exclude_datasets</span> <span class="ow">and</span> <span class="n">dataset_name</span> <span class="ow">in</span> <span class="n">exclude_datasets</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">using_default_excludes</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;skipping because in default exclude_datasets&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;skipping because in exclude_datasets&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">()</span>

                <span class="k">return</span>

            <span class="n">shape</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;unexpected shape&#39;</span>
            <span class="c1"># NOTE: would be an issue if someone named one of the user-nameable</span>
            <span class="c1"># analog inputs to be the same as one of the builtin dataset names</span>
            <span class="k">assert</span> <span class="n">dataset_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="p">,</span> <span class="s1">&#39;dataset names not unique&#39;</span>

            <span class="c1"># Seems to be about twice as fast as `values = obj[:, 0]`</span>
            <span class="c1"># Doesn&#39;t seem like there is a faster way to do this. IO limited hopefully.</span>
            <span class="c1"># There is h5py &lt;dataset&gt;.read_direct(&lt;empty np array&gt;, ...), but I think it</span>
            <span class="c1"># would behave the same.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">parent_name</span> <span class="o">==</span> <span class="s1">&#39;/DI&#39;</span><span class="p">:</span>
                <span class="c1"># Anything non-zero gets converted to True</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>

            <span class="n">data_dict</span><span class="p">[</span><span class="n">dataset_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">()</span>


    <span class="c1"># TODO warn/err (configurable via kwarg?) if any datasets requested were not</span>
    <span class="c1"># found (to help identify naming convention changes in the HDF5 files, etc)</span>

    <span class="c1"># NOTE: for some reason, opening a debugger (e.g. via `ipdb.set_trace()`)</span>
    <span class="c1"># inside this context manager has `self` in `dir()`, seemingly pointing to</span>
    <span class="c1"># `f`, but `f` can not be referenced directly.</span>
    <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">hdf5_fname</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="c1"># Populates data_dict</span>
        <span class="n">f</span><span class="o">.</span><span class="n">visititems</span><span class="p">(</span><span class="n">load_datasets</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_dataset_names_only</span><span class="p">:</span>
        <span class="c1"># TODO account for this in return typehint</span>
        <span class="k">return</span> <span class="n">full_dataset_names</span>

    <span class="c1"># TODO maybe compare performance w/ w/o conversion to Dataframe?</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data_dict</span><span class="p">)</span>


    <span class="c1"># TODO probably refactor this up top, along with time_col and something similar for</span>
    <span class="c1"># &#39;frame_out&#39;</span>
    <span class="n">gctr_col</span> <span class="o">=</span> <span class="s1">&#39;gctr&#39;</span>
    <span class="k">if</span> <span class="n">gctr_col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="c1"># TODO check whether this is (nearly) equivalent to multiplying arange</span>
        <span class="c1"># len samples by 1 / thorsync sampling rate</span>
        <span class="c1"># Dividing what I think is the clock cycle counter by the 20MHz</span>
        <span class="c1"># mentioned in the 3.0 ThorSync manual (section 5.2 &quot;Reviewing Data&quot;).</span>
        <span class="n">df</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">gctr_col</span><span class="p">]</span> <span class="o">/</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2e7</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">drop_gctr</span><span class="p">:</span>
            <span class="c1"># This is surprisingly slow. ~25% of runtime of this function loading a few</span>
            <span class="c1"># columns of a ~1.7Gb file (kernprof). Faster way?</span>
            <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">gctr_col</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Valid as long as gctr_col has no spaces and (exclude_datasets and</span>
        <span class="c1"># datasets) are mutually exclusive.</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">datasets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">({</span><span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">})</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">gctr_col</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">{</span><span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">})</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">datasets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
            <span class="n">gctr_col</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">}</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">_debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;ThorSync dataframe memory usage: </span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">memory_usage</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">:</span><span class="s1">,</span><span class="si">}</span><span class="s1"> &#39;</span>
            <span class="s1">&#39;bytes&#39;</span>
        <span class="p">)</span>

    <span class="c1"># Just to illustrate what the sampling rate in the XML is. This check should</span>
    <span class="c1"># work, but no need for it to be routine.</span>
    <span class="c1">#</span>
    <span class="c1"># samprate_hz = get_thorsync_samplerate_hz(thorsync_dir)</span>
    <span class="c1"># mean_sample_interval = df[time_col].diff().mean()</span>
    <span class="c1"># expected_sample_interval = 1 / samprate_hz</span>
    <span class="c1"># assert np.isclose(mean_sample_interval, expected_sample_interval), \</span>
    <span class="c1">#     &#39;ThorSync XML sample rate or acquisition clock frequency wrong&#39;</span>

    <span class="k">return</span> <span class="n">df</span></div>


<span class="c1"># TODO is this slow / are there faster alternatives?</span>
<span class="c1"># (copied from my deprecated al_imaging/al_imaging/util.py)</span>
<div class="viewcode-block" id="threshold_crossings"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.threshold_crossings">[docs]</a><span class="k">def</span> <span class="nf">threshold_crossings</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">onsets</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">offsets</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="c1"># TODO clarify &quot;ignored&quot; in equality case in doc</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns indices where signal goes from &lt; threshold to &gt; threshold as onsets,</span>
<span class="sd">    and where signal goes from &gt; threshold to &lt; threshold as offsets.</span>

<span class="sd">    Cases where it at one index equals the threshold are ignored. Shouldn&#39;t</span>
<span class="sd">    happen and may indicate electrical problems for our application.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">ANALOG_0_TO_5V_THRESHOLD</span>

    <span class="c1"># TODO could redefine in terms of np.diff</span>
    <span class="c1"># might be off by one?</span>
    <span class="c1"># TODO TODO TODO detect whether input is pandas series and only use .values</span>
    <span class="c1"># in that case</span>
    <span class="c1"># NOTE: we must call .values or else some of the comparison operations</span>
    <span class="c1"># across series will behave in a manner we don&#39;t want (np.logical_and, I</span>
    <span class="c1"># think).</span>
    <span class="n">shifted</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">truncated</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

    <span class="n">onset_indices</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">offset_indices</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># TODO maybe special case boolean (np.bool_ dtype; digital) inputs to not</span>
    <span class="c1"># use comparison against a float, if something else is faster</span>

    <span class="k">if</span> <span class="n">onsets</span><span class="p">:</span>
        <span class="n">onset_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="n">shifted</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">,</span>
            <span class="n">truncated</span> <span class="o">&lt;</span> <span class="n">threshold</span>
        <span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">offsets</span><span class="p">:</span>
        <span class="n">offset_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="n">shifted</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">,</span>
            <span class="n">truncated</span> <span class="o">&gt;</span> <span class="n">threshold</span>
        <span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># TODO TODO check whether these indices lead to off-by-one if used to index</span>
    <span class="c1"># times (+ fix here if so)</span>
    <span class="k">return</span> <span class="n">onset_indices</span><span class="p">,</span> <span class="n">offset_indices</span></div>


<span class="c1"># TODO TODO generalize + refactor other stuff to use / maybe delete</span>
<span class="c1"># (and maybe just take xml / thorimage_dir as input, as may want to handle `c`</span>
<span class="c1"># / averaging / etc later)</span>
<div class="viewcode-block" id="get_flyback_indices"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_flyback_indices">[docs]</a><span class="k">def</span> <span class="nf">get_flyback_indices</span><span class="p">(</span><span class="n">n_frames</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n_flyback</span><span class="p">,</span> <span class="n">series</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns indices of XY frames during piezo flyback, or empty array if none</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">series</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">n_frames</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">n_frames</span><span class="si">}</span><span class="s1"> != </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">if</span> <span class="n">n_flyback</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="c1"># TODO return appropriate values to cause no-op in subsequent operations if</span>
    <span class="c1"># input does not have flyback frames (e.g. not volumetric)</span>

    <span class="n">z_total</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="n">n_flyback</span>

    <span class="n">n_volumes</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">n_frames</span><span class="p">,</span> <span class="n">z_total</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">remainder</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="c1">#data = np.reshape(data, (n_frames, z_total, x, y))</span>
    <span class="c1"># TODO TODO slice a movie with the opposite of these indices and verify it&#39;s</span>
    <span class="c1"># same as what we&#39;d get by reslicing as above (by checking equality)</span>

    <span class="c1"># TODO TODO what extra info we need if this fn is also supposed to drop</span>
    <span class="c1"># stuff beyond end of recording? maybe just leave that to other stuff and</span>
    <span class="c1"># make clear in doc?</span>

    <span class="n">flyback_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">((</span><span class="n">z_total</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">z</span><span class="p">,</span> <span class="p">(</span><span class="n">z_total</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">z_total</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_volumes</span><span class="p">)</span>
    <span class="p">])</span>

    <span class="k">return</span> <span class="n">flyback_indices</span></div>


<div class="viewcode-block" id="get_col_onset_indices"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_col_onset_indices">[docs]</a><span class="k">def</span> <span class="nf">get_col_onset_indices</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">possible_col_names</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns arrays onsets, offsets with appropriate indices in `df`.</span>

<span class="sd">    Args:</span>
<span class="sd">        possible_col_names (str or tuple): can be either exact column name in</span>
<span class="sd">            `df` or an iterable of column names, where the first matching a column</span>
<span class="sd">            in `df` will be used.</span>

<span class="sd">        **kwargs: passed through to `threshold_crossings`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">col</span> <span class="o">=</span> <span class="n">_get_column</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">possible_col_names</span><span class="p">)</span>
    <span class="n">onsets</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">threshold_crossings</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
        <span class="n">offsets</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">onsets</span></div>


<span class="c1"># TODO how to type hint arbitrary length tuple (/iterable) of str (in a union)?</span>
<div class="viewcode-block" id="get_col_onset_offset_indices"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_col_onset_offset_indices">[docs]</a><span class="k">def</span> <span class="nf">get_col_onset_offset_indices</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">possible_col_names</span><span class="p">,</span>
    <span class="n">checks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns arrays onsets, offsets with appropriate indices in `df`.</span>

<span class="sd">    Args:</span>
<span class="sd">        possible_col_names (str or tuple): can be either exact column name in</span>
<span class="sd">            `df` or an iterable of column names, where the first matching a column</span>
<span class="sd">            in `df` will be used.</span>

<span class="sd">        threshold (float): passed to `threshold_crossings` under the same name.</span>

<span class="sd">    Raises OnsetOffsetNumMismatch if `checks=True` and the number of onsets and offsets</span>
<span class="sd">    differ.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">col</span> <span class="o">=</span> <span class="n">_get_column</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">possible_col_names</span><span class="p">)</span>

    <span class="c1"># TODO TODO refactor to delete this hack (fixes change to scope_pin)</span>
    <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">):</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">DIGITAL_THRESHOLD</span>
    <span class="c1">#</span>

    <span class="c1"># TODO have this (inside) probably warn if there are no threshold crossings</span>
    <span class="c1"># (and maybe compare thresh to max/min/dtype values in generating warning to</span>
    <span class="c1"># indicate if that might be the cause of the error, which i guess it</span>
    <span class="c1"># must...)</span>
    <span class="n">onsets</span><span class="p">,</span> <span class="n">offsets</span> <span class="o">=</span> <span class="n">threshold_crossings</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">checks</span><span class="p">:</span>
        <span class="c1"># TODO maybe just have threshold_crossings make these checks by default, w/ a</span>
        <span class="c1"># kwarg to override (which gets threaded through here)?</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">onsets</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">offsets</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">OnsetOffsetNumMismatch</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">onsets</span><span class="p">)</span><span class="si">}</span><span class="s1"> != </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">offsets</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">onsets</span> <span class="o">&lt;</span> <span class="n">offsets</span><span class="p">),</span> <span class="s1">&#39;at least one offset before onset&#39;</span>

    <span class="k">return</span> <span class="n">onsets</span><span class="p">,</span> <span class="n">offsets</span></div>


<div class="viewcode-block" id="get_col_onset_offset_times"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_col_onset_offset_times">[docs]</a><span class="k">def</span> <span class="nf">get_col_onset_offset_times</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">possible_col_names</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns arrays onsets, offsets with appropriate values from `df.time_s`.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (DataFrame): must have a column `&#39;time_s&#39;`, as generated by</span>
<span class="sd">            `load_thorsync_hdf5`.</span>

<span class="sd">        possible_col_names (str or tuple): can be either exact column name in</span>
<span class="sd">            `df` or an iterable of column names, where the first matching a column</span>
<span class="sd">            in `df` will be used.</span>

<span class="sd">        **kwargs: passed to `get_col_onset_offset_indices`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">onsets</span><span class="p">,</span> <span class="n">offsets</span> <span class="o">=</span> <span class="n">get_col_onset_offset_indices</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">possible_col_names</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>
    <span class="n">onset_times</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">time_s</span><span class="p">[</span><span class="n">onsets</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">offset_times</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">time_s</span><span class="p">[</span><span class="n">offsets</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="k">return</span> <span class="n">onset_times</span><span class="p">,</span> <span class="n">offset_times</span></div>


<div class="viewcode-block" id="find_last_true"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.find_last_true">[docs]</a><span class="k">def</span> <span class="nf">find_last_true</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="c1"># TODO specify behavior + test in case there are NO True values</span>
    <span class="c1"># (probably just raise ValueError)</span>
    <span class="sd">&quot;&quot;&quot;Returns the index of the last `True` in 1-dimensional `x`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;input must be 1-dimensional&#39;</span><span class="p">)</span>

    <span class="c1"># may need to generalize this type checking...</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;input must be of dtype bool&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">x</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span></div>


<span class="c1"># TODO add (fn specific?) cacheing util (decorator?) so that df can be generated</span>
<span class="c1"># automatically w/ thorsync dir input here / in assign_frames*, but so the df</span>
<span class="c1"># loaded in the background can be shared across these calls?</span>
<span class="c1"># TODO delete frame out name handling after forcing it to be a constant name in</span>
<span class="c1"># load_thorsync_hdf5</span>
<div class="viewcode-block" id="get_frame_times"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.get_frame_times">[docs]</a><span class="k">def</span> <span class="nf">get_frame_times</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">thorimage_dir</span><span class="p">,</span> <span class="n">time_ref</span><span class="o">=</span><span class="s1">&#39;mid&#39;</span><span class="p">,</span>
    <span class="n">min_block_duration_s</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">acquisition_trigger_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">_debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">_wont_use_df_after</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns seconds from start of ThorSync recording for each frame.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        df: as returned by `load_thorsync_hdf5`</span>

<span class="sd">        thorimage_dir: path to ThorImage directory to load metadata from</span>

<span class="sd">        time_ref (&#39;mid&#39; | &#39;end&#39;)</span>

<span class="sd">        min_block_duration_s (float): (default=1.0) minimum time (in seconds) between</span>
<span class="sd">            onset and offset of acquisition trigger. Shorter blocks that precede all</span>
<span class="sd">            acceptable-length blocks will simply be disregarding, with a warning.</span>
<span class="sd">            Shorter blocks following any acceptable-length blocks will currently trigger</span>
<span class="sd">            an error.</span>

<span class="sd">    Returns a `np.array` that should be of length equal to the number of frames</span>
<span class="sd">    actually saved by ThorImage (i.e. `&lt;output&gt;.shape` should be equal to</span>
<span class="sd">    `(movie.shape[0],)`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># NOTE: initially I was planning on basing this off of one of the ThorLabs</span>
    <span class="c1"># supplied MATLAB scripts (see GenerateFrameTime.m referenced in ThorSync</span>
    <span class="c1"># manual), but it seems to not be behaving correctly (or my data does not</span>
    <span class="c1"># have the values for Frame_In that this script expects, as all of mine are</span>
    <span class="c1"># purely 0). even excluding the AND w/ Frame_In, however, the shape of</span>
    <span class="c1"># the `indexes` variable in this MATLAB script would not seem to be what I&#39;d</span>
    <span class="c1"># expect (i.e. length is not equal to number of frames) for at least some of</span>
    <span class="c1"># my data (tried 2021-03-07/1/SyncData002).</span>
    <span class="c1"># If I had to guess, Frame_In is supposed to function as our copy of the</span>
    <span class="c1"># recording trigger does, but digital.</span>
    <span class="c1"># TODO try to make sure we are maintaining the same behavior as the official</span>
    <span class="c1"># thor provided matlab scripts (eh... nvm. see other comments explaining how</span>
    <span class="c1"># i don&#39;t think they are working correctly, with regards to Frame_In and</span>
    <span class="c1"># perhaps some other things):</span>
    <span class="c1"># From red &quot;Note:&quot; box on p37 of ThorSync3.0 user guide:</span>
    <span class="c1"># &quot;Importing data into Matlab will automatically maintain the correct frame</span>
    <span class="c1"># reference by removing any unintended image frame(s) acquired during the</span>
    <span class="c1"># Trigger Out phase.&quot;</span>

    <span class="k">if</span> <span class="n">time_ref</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;mid&#39;</span><span class="p">,</span> <span class="s1">&#39;end&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;time_ref must be either &#39;mid&#39; or &#39;end&#39;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">time_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">time_col</span><span class="si">}</span><span class="s1"> not in df.columns&#39;</span><span class="p">)</span>

    <span class="c1"># TODO TODO if frame_in can be recovered / configured to be saved in the</span>
    <span class="c1"># future, and it does indeed serve the same function as our</span>
    <span class="c1"># &quot;scope_pin&quot;/whatever, replace this with that (at least if it&#39;s available</span>
    <span class="c1"># in current data)</span>
    <span class="k">if</span> <span class="n">acquisition_trigger_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">acquisition_trigger_names</span> <span class="o">=</span> <span class="n">_acquisition_trigger_names</span>

    <span class="c1"># ~28% of time (kernprof on one test input)</span>
    <span class="n">acq_onsets</span><span class="p">,</span> <span class="n">acq_offsets</span> <span class="o">=</span> <span class="n">get_col_onset_offset_indices</span><span class="p">(</span><span class="n">df</span><span class="p">,</span>
        <span class="n">acquisition_trigger_names</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">ANALOG_0_TO_5V_THRESHOLD</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">acq_onsets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;no recording periods found in ThorSync data&#39;</span><span class="p">)</span>

    <span class="c1"># weirdly, in my one test case so far, this 1st line took ~9% of time and 2nd ~0%</span>
    <span class="n">acq_onset_times</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">time_s</span><span class="p">[</span><span class="n">acq_onsets</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">acq_offset_times</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">time_s</span><span class="p">[</span><span class="n">acq_offsets</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

    <span class="n">first_real_block_onset_s</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">block_idx</span><span class="p">,</span> <span class="p">(</span><span class="n">on</span><span class="p">,</span> <span class="n">off</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">acq_onset_times</span><span class="p">,</span> <span class="n">acq_offset_times</span><span class="p">)):</span>

        <span class="k">if</span> <span class="n">off</span> <span class="o">-</span> <span class="n">on</span> <span class="o">&gt;=</span> <span class="n">min_block_duration_s</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">first_real_block_onset_s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">first_real_block_onset_s</span> <span class="o">=</span> <span class="n">on</span>
                <span class="n">first_real_block_idx</span> <span class="o">=</span> <span class="n">block_idx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">first_real_block_onset_s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;block shorter than min_block_duration_s &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">min_block_duration_s</span><span class="si">}</span><span class="s1">:.1f) after first acceptable-length block&#39;</span>
                <span class="p">)</span>

    <span class="k">if</span> <span class="n">first_real_block_onset_s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;no blocks longer than min_block_duration_s &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">min_block_duration_s</span><span class="si">}</span><span class="s1">:.1f)&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">warn</span> <span class="ow">and</span> <span class="n">first_real_block_idx</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;dropping data up to block with index </span><span class="si">{</span><span class="n">first_real_block_idx</span><span class="si">}</span><span class="s1">, &#39;</span>
            <span class="s1">&#39;because earlier &quot;blocks&quot; were shorter than min_block_duration_s &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">min_block_duration_s</span><span class="si">:</span><span class="s1">.1f</span><span class="si">}</span><span class="s1">)&#39;</span>
        <span class="p">)</span>

    <span class="c1"># Considerably faster than:</span>
    <span class="c1"># `df = df[df.time_s &gt;= first_real_block_onset_s]`</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">time_s</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">first_real_block_onset_s</span><span class="p">):]</span>

    <span class="c1"># I did some tests where I defined old_frame_out_[on/off]sets as below, just</span>
    <span class="c1"># computed before subsetting the DataFrame on the line above, and these held true:</span>
    <span class="c1"># np.array_equal(old_frame_out_onsets[3:] - new_first_thorsync_idx,</span>
    <span class="c1">#     frame_out_onsets</span>
    <span class="c1"># )</span>
    <span class="c1"># np.array_equal(old_frame_out_offsets[3:] - new_first_thorsync_idx,</span>
    <span class="c1">#     frame_out_offsets</span>
    <span class="c1"># )</span>
    <span class="c1"># (the 3 is just because that&#39;s how many spurious frame out pulses were filtered out</span>
    <span class="c1"># for the data I was testing this on)</span>
    <span class="n">new_first_thorsync_idx</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">acq_onsets</span> <span class="o">=</span> <span class="n">acq_onsets</span><span class="p">[</span><span class="n">first_real_block_idx</span><span class="p">:]</span> <span class="o">-</span> <span class="n">new_first_thorsync_idx</span>
    <span class="n">acq_offsets</span> <span class="o">=</span> <span class="n">acq_offsets</span><span class="p">[</span><span class="n">first_real_block_idx</span><span class="p">:]</span> <span class="o">-</span> <span class="n">new_first_thorsync_idx</span>

    <span class="c1"># ~37% of time (kernprof on one test input)</span>
    <span class="c1"># If we could guarantee we wouldn&#39;t use the dataframe after, we could do this</span>
    <span class="c1"># inplace and save all of that time, but it&#39;s not worth the possible bugs.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_wont_use_df_after</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">_debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;subsetting dataframe to rows where time_s &gt;= &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">first_real_block_onset_s</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="p">)</span>

    <span class="c1"># TODO refactor &#39;frame_out&#39; and other hardcoded col name strings to top w/ variable</span>
    <span class="c1"># (user renameable) ones</span>
    <span class="c1"># ~24% of time (kernprof on one test input)</span>
    <span class="n">frame_out_onsets</span><span class="p">,</span> <span class="n">frame_out_offsets</span> <span class="o">=</span> <span class="n">get_col_onset_offset_indices</span><span class="p">(</span><span class="n">df</span><span class="p">,</span>
        <span class="s1">&#39;frame_out&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">DIGITAL_THRESHOLD</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">_debug</span><span class="p">:</span>
        <span class="c1"># TODO delete if not useful</span>
        <span class="n">frame_out_lens</span> <span class="o">=</span> <span class="n">frame_out_offsets</span> <span class="o">-</span> <span class="n">frame_out_onsets</span>

        <span class="n">frame_out_onsets_s</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">time_s</span><span class="p">[</span><span class="n">frame_out_onsets</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">frame_out_offsets_s</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">time_s</span><span class="p">[</span><span class="n">frame_out_offsets</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">frame_out_lens_s</span> <span class="o">=</span> <span class="n">frame_out_offsets_s</span> <span class="o">-</span> <span class="n">frame_out_onsets_s</span>

        <span class="c1"># TODO probably replace w/ median / something (if used...)</span>
        <span class="n">mean_frame_out_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">frame_out_lens</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;mean_frame_out_len:&#39;</span><span class="p">,</span> <span class="n">mean_frame_out_len</span><span class="p">)</span>
        <span class="n">mean_frame_out_len_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">frame_out_lens_s</span><span class="p">)</span>

        <span class="n">min_frame_out_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">frame_out_lens</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;min_frame_out_len:&#39;</span><span class="p">,</span> <span class="n">min_frame_out_len</span><span class="p">)</span>

        <span class="n">max_frame_out_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">frame_out_lens</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;max_frame_out_len:&#39;</span><span class="p">,</span> <span class="n">max_frame_out_len</span><span class="p">)</span>
        <span class="n">max_frame_out_len_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">frame_out_lens_s</span><span class="p">)</span>

        <span class="n">sorted_fo_lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">frame_out_lens</span><span class="p">)</span>
        <span class="n">sfo_n</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;min </span><span class="si">{</span><span class="n">sfo_n</span><span class="si">}</span><span class="s1"> frame_out_lens:&#39;</span><span class="p">,</span> <span class="n">sorted_fo_lens</span><span class="p">[:</span><span class="n">sfo_n</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;max </span><span class="si">{</span><span class="n">sfo_n</span><span class="si">}</span><span class="s1"> frame_out_lens:&#39;</span><span class="p">,</span> <span class="n">sorted_fo_lens</span><span class="p">[</span><span class="o">-</span><span class="n">sfo_n</span><span class="p">:])</span>

    <span class="c1"># NOTE: in all the single block data i&#39;ve tested so far (though both of</span>
    <span class="c1"># these also happen to have been acquired downstairs...) the max is actually</span>
    <span class="c1"># ~= the mean, whereas that&#39;s not the case for the other data tested so far.</span>
    <span class="c1"># TODO check whether this explains why this data didn&#39;t work w/ matlab</span>
    <span class="c1"># provided GetFrameTimes.m / related</span>
    <span class="c1">#</span>
    <span class="c1"># min &lt; mean ~= max:</span>
    <span class="c1"># - 2021-03-07/1</span>
    <span class="c1">#   - image: glomeruli_diagnostics_192</span>
    <span class="c1">#     sync: SyncData001</span>
    <span class="c1">#   - image: t2h_single_plane</span>
    <span class="c1">#     sync: SyncData002</span>
    <span class="c1">#</span>
    <span class="c1"># min ~= mean &lt; max:</span>
    <span class="c1"># - 2019-01-23/6</span>
    <span class="c1">#   - image: _001</span>
    <span class="c1">#     sync: SyncData001</span>
    <span class="c1"># - 2020-04-01/2</span>
    <span class="c1">#   - image: fn_002</span>
    <span class="c1">#     sync: SyncData002</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n_flyback</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">xml</span> <span class="o">=</span> <span class="n">load_thorimage_metadata</span><span class="p">(</span><span class="n">thorimage_dir</span><span class="p">,</span>
        <span class="n">return_xml</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>

    <span class="c1"># Number of XY frames, even in the volumetric case. This is however, the</span>
    <span class="c1"># number of frames AFTER any frame averaging.</span>
    <span class="n">n_frames</span> <span class="o">=</span> <span class="n">get_thorimage_n_frames</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span>

    <span class="n">z_total</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="n">n_flyback</span>

    <span class="c1"># TODO delete after figuring out what should really be used</span>
    <span class="c1">#compare_to_acq_off = &#39;offset&#39;</span>
    <span class="n">compare_to_acq_off</span> <span class="o">=</span> <span class="s1">&#39;onset&#39;</span>
    <span class="k">assert</span> <span class="n">compare_to_acq_off</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;onset&#39;</span><span class="p">,</span> <span class="s1">&#39;offset&#39;</span><span class="p">)</span>

    <span class="n">n_orig_frame_out_pulses</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_out_onsets</span><span class="p">)</span>
    <span class="c1">#</span>

    <span class="n">n_averaged_frames</span> <span class="o">=</span> <span class="n">get_thorimage_n_averaged_frames_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span>

    <span class="c1"># TODO fix wrt yangs data</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    if n_averaged_frames &gt; 1:</span>
<span class="sd">        assert z_total == 1, (&#39;ThorImage does not support averaging while &#39;</span>
<span class="sd">            &#39;recording fast Z&#39;</span>
<span class="sd">        )</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># &quot;Frame save groups&quot; are either frames to be averaged to a single frame or</span>
    <span class="c1"># frames that together make up a volume (including any flyback frames!)</span>
    <span class="n">n_frames_per_save_group</span> <span class="o">=</span> <span class="n">n_averaged_frames</span> <span class="o">*</span> <span class="n">z_total</span> <span class="o">*</span> <span class="n">c</span>

    <span class="k">if</span> <span class="n">_debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;n_blocks:&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">acq_onsets</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;z_total:&#39;</span><span class="p">,</span> <span class="n">z_total</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;n_averaged_frames:&#39;</span><span class="p">,</span> <span class="n">n_averaged_frames</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;N_FRAMES_PER_SAVE_GROUP:&#39;</span><span class="p">,</span> <span class="n">n_frames_per_save_group</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_frames_per_save_group</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;comparing frame_out_</span><span class="si">{</span><span class="n">compare_to_acq_off</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="s1">&#39; to acq_offsets&#39;</span>
            <span class="p">)</span>

    <span class="n">not_saved_bool</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">on</span> <span class="o">=</span> <span class="n">acq_onsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">off</span><span class="p">,</span> <span class="n">next_on</span> <span class="ow">in</span> <span class="n">zip_longest</span><span class="p">(</span><span class="n">acq_offsets</span><span class="p">,</span> <span class="n">acq_onsets</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="k">if</span> <span class="n">n_averaged_frames</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">z_total</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">compare_to_acq_off</span> <span class="o">==</span> <span class="s1">&#39;onset&#39;</span><span class="p">:</span>
                <span class="n">curr_not_saved_bool</span> <span class="o">=</span> <span class="n">off</span> <span class="o">&lt;</span> <span class="n">frame_out_onsets</span>

            <span class="k">elif</span> <span class="n">compare_to_acq_off</span> <span class="o">==</span> <span class="s1">&#39;offset&#39;</span><span class="p">:</span>
                <span class="n">curr_not_saved_bool</span> <span class="o">=</span> <span class="n">off</span> <span class="o">&lt;</span> <span class="n">frame_out_offsets</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">next_on</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Shouldn&#39;t matter which of the onsets/offsets we use to compare</span>
                <span class="c1"># to next_on.</span>
                <span class="n">curr_not_saved_bool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                    <span class="n">curr_not_saved_bool</span><span class="p">,</span> <span class="n">frame_out_offsets</span> <span class="o">&lt;</span> <span class="n">next_on</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO TODO check whether we also need to do some advance filtering</span>
            <span class="c1"># in either of these cases (likely based on length of a given frame</span>
            <span class="c1"># out pulse, but also perhaps could always filter last one [/two] or</span>
            <span class="c1"># perhaps actually still need to do something things in relation to</span>
            <span class="c1"># acquisition trigger [sometimes])</span>

            <span class="n">curr_not_saved_bool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">frame_out_onsets</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span>
            <span class="p">)</span>

            <span class="n">curr_frame_out_onsets_mask</span> <span class="o">=</span> <span class="n">on</span> <span class="o">&lt;</span> <span class="n">frame_out_onsets</span>

            <span class="k">if</span> <span class="n">next_on</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">curr_frame_out_onsets_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                    <span class="n">curr_frame_out_onsets_mask</span><span class="p">,</span> <span class="n">frame_out_onsets</span> <span class="o">&lt;</span> <span class="n">next_on</span>
                <span class="p">)</span>

            <span class="n">curr_n_frame_out_pulses</span> <span class="o">=</span> <span class="n">curr_frame_out_onsets_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="n">n_completed_frame_save_groups</span><span class="p">,</span> <span class="n">n_trailing_unsaved_frames</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span>
                <span class="n">curr_n_frame_out_pulses</span><span class="p">,</span> <span class="n">n_frames_per_save_group</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">_debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;curr_n_frame_out_pulses:&#39;</span><span class="p">,</span> <span class="n">curr_n_frame_out_pulses</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;n_completed_frame_save_groups:&#39;</span><span class="p">,</span>
                    <span class="n">n_completed_frame_save_groups</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;n_trailing_unsaved_frames:&#39;</span><span class="p">,</span> <span class="n">n_trailing_unsaved_frames</span><span class="p">)</span>

            <span class="c1"># NOTE: hack to get number of frames to work out correctly</span>
            <span class="c1"># Seemed to solve all issues on data from 2021-03-07 and 2021-03-08</span>
            <span class="c1"># TODO TODO TODO test on more data! any cases this fails? and if so, how to</span>
            <span class="c1"># handle differently?</span>
            <span class="k">if</span> <span class="n">n_trailing_unsaved_frames</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">n_trailing_unsaved_frames</span> <span class="o">+=</span> <span class="n">n_frames_per_save_group</span>

                <span class="k">if</span> <span class="n">_debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;increasing n_trailing_unsaved_frames by &#39;</span>
                        <span class="s1">&#39;n_frames_per_save_group!!!&#39;</span>
                    <span class="p">)</span>

            <span class="c1"># TODO TODO TODO try to find test cases where there are exactly</span>
            <span class="c1"># an even number of frame out pulses (both including and excluding</span>
            <span class="c1"># the very last one), in both averaging and fast-Z cases</span>
            <span class="c1"># (as another means of trying to find cases where an additional</span>
            <span class="c1"># filtering step is required)</span>

            <span class="k">if</span> <span class="n">n_trailing_unsaved_frames</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">last_curr_idx</span> <span class="o">=</span> <span class="n">find_last_true</span><span class="p">(</span><span class="n">curr_frame_out_onsets_mask</span><span class="p">)</span>
                <span class="n">i0</span> <span class="o">=</span> <span class="n">last_curr_idx</span> <span class="o">-</span> <span class="n">n_trailing_unsaved_frames</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">curr_not_saved_bool</span><span class="p">[</span><span class="n">i0</span><span class="p">:(</span><span class="n">last_curr_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">curr_n_dropped</span> <span class="o">=</span> <span class="n">curr_not_saved_bool</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="k">assert</span> <span class="n">curr_n_dropped</span> <span class="o">==</span> <span class="n">n_trailing_unsaved_frames</span><span class="p">,</span> \
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">curr_n_dropped</span><span class="si">}</span><span class="s1"> != </span><span class="si">{</span><span class="n">n_trailing_unsaved_frames</span><span class="si">}</span><span class="s1">&#39;</span>

        <span class="k">if</span> <span class="n">_debug</span><span class="p">:</span>
            <span class="c1"># TODO also print which index is not saved</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;curr_not_saved_bool.sum():&#39;</span><span class="p">,</span> <span class="n">curr_not_saved_bool</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">()</span>

        <span class="c1"># TODO assert that curr_not_saved_bool has no overlap with the stuff marked to</span>
        <span class="c1"># not be saved in any other iterations (if not already doing something like</span>
        <span class="c1"># this...)</span>

        <span class="n">on</span> <span class="o">=</span> <span class="n">next_on</span>

        <span class="k">if</span> <span class="n">not_saved_bool</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">not_saved_bool</span> <span class="o">=</span> <span class="n">curr_not_saved_bool</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">not_saved_bool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">not_saved_bool</span><span class="p">,</span> <span class="n">curr_not_saved_bool</span><span class="p">)</span>

    <span class="n">not_saved_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">not_saved_bool</span><span class="p">)</span>
    <span class="n">frame_out_onsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">frame_out_onsets</span><span class="p">,</span> <span class="n">not_saved_indices</span><span class="p">)</span>
    <span class="n">frame_out_offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">frame_out_offsets</span><span class="p">,</span> <span class="n">not_saved_indices</span><span class="p">)</span>

    <span class="c1"># NOTE: without the .values call here, the &#39;mid&#39; case below does not work</span>
    <span class="c1"># because pandas tries to align the series.</span>
    <span class="n">onset_times</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">frame_out_onsets</span><span class="p">]</span>
    <span class="n">offset_times</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">frame_out_offsets</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">time_ref</span> <span class="o">==</span> <span class="s1">&#39;end&#39;</span><span class="p">:</span>
        <span class="n">frame_times</span> <span class="o">=</span> <span class="n">offset_times</span>

    <span class="k">elif</span> <span class="n">time_ref</span> <span class="o">==</span> <span class="s1">&#39;mid&#39;</span><span class="p">:</span>
        <span class="n">frame_times</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset_times</span> <span class="o">-</span> <span class="n">onset_times</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">onset_times</span>

    <span class="k">if</span> <span class="n">_debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;n_orig_frame_out_pulses:&#39;</span><span class="p">,</span> <span class="n">n_orig_frame_out_pulses</span><span class="p">)</span>

        <span class="n">n_frames_before_averaging</span> <span class="o">=</span> <span class="n">n_frames</span> <span class="o">*</span> <span class="n">n_averaged_frames</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;n_frames_before_averaging (from ThorImage XML):&#39;</span><span class="p">,</span>
            <span class="n">n_frames_before_averaging</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;n_frames_after_dropping:&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_times</span><span class="p">))</span>
        <span class="n">e1</span> <span class="o">=</span> <span class="n">n_frames_before_averaging</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_times</span><span class="p">)</span>

        <span class="n">n_frame_outs_to_drop</span> <span class="o">=</span> \
            <span class="n">n_orig_frame_out_pulses</span> <span class="o">-</span> <span class="n">n_frames_before_averaging</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;n_frame_outs_to_drop (how many *should* be dropped):&#39;</span><span class="p">,</span>
            <span class="n">n_frame_outs_to_drop</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;n_actually_dropped (how many we are actually planning to drop):&#39;</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">not_saved_indices</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">e2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">not_saved_indices</span><span class="p">)</span> <span class="o">-</span> <span class="n">n_frame_outs_to_drop</span>
        <span class="k">assert</span> <span class="n">e1</span> <span class="o">==</span> <span class="n">e2</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;EXCESS FRAMES DROPPED:&#39;</span><span class="p">,</span> <span class="n">e1</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n_averaged_frames</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">frame_times</span> <span class="o">=</span> <span class="n">frame_times</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_averaged_frames</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_times</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_frames</span><span class="p">,</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">frame_times</span><span class="p">)</span><span class="si">}</span><span class="s1"> (how many the code &#39;</span>
        <span class="sa">f</span><span class="s1">&#39;thinks there were, from the ThorSync HDF5 data) != </span><span class="si">{</span><span class="n">n_frames</span><span class="si">}</span><span class="s1"> (from &#39;</span>
        <span class="s1">&#39;ThorImage XML)&#39;</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">flyback_indices</span> <span class="o">=</span> <span class="n">get_flyback_indices</span><span class="p">(</span><span class="n">n_frames</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n_flyback</span><span class="p">,</span>
            <span class="n">frame_times</span>
        <span class="p">)</span>

        <span class="c1"># https://stackoverflow.com/questions/47540800</span>
        <span class="c1"># This will raise `IndexError` if any exceed size of frame_times</span>
        <span class="c1"># (though it shouldn&#39;t unless I made a mistake)</span>
        <span class="n">frame_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">frame_times</span><span class="p">,</span> <span class="n">flyback_indices</span><span class="p">)</span>

        <span class="c1"># TODO change these two AssertionErrors into a custom error</span>

        <span class="c1"># (we basically already know, but just for the sake of it...)</span>
        <span class="n">n_volumes</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">frame_times</span><span class="p">),</span> <span class="n">z</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">remainder</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="n">frame_times</span> <span class="o">=</span> <span class="n">frame_times</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_times</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_volumes</span>

    <span class="k">return</span> <span class="n">frame_times</span></div>


<div class="viewcode-block" id="assign_frame_times_to_blocks"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.assign_frame_times_to_blocks">[docs]</a><span class="k">def</span> <span class="nf">assign_frame_times_to_blocks</span><span class="p">(</span><span class="n">frame_times</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes array of frame times to (start, stop) indices for each block.</span>

<span class="sd">    Args:</span>
<span class="sd">        frame_times (np.array): as output by `get_frame_times`.</span>
<span class="sd">            should have a `shape` of `(movie.shape[0],)`.</span>

<span class="sd">        rtol (float): (optional, default=1.5) time differences between frames must</span>
<span class="sd">            be at least this multiplied by the median time difference in order for</span>
<span class="sd">            a block to be called there.</span>

<span class="sd">    Notes:</span>
<span class="sd">    This function defines blocks (periods of continuous acquisition) by regions</span>
<span class="sd">    of `frame_times` where the time difference between frames remains</span>
<span class="sd">    essentially constant. Large jumps in the time between two frames defines the</span>
<span class="sd">    start of a new block. Indices returned would be suitable to index the first</span>
<span class="sd">    dimension of the `movie`, the output of `get_frame_times`, etc. `stop`</span>
<span class="sd">    indices are included as part of the block, so you should add one when using</span>
<span class="sd">    them as the end of a slice.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">frame_times</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="n">frame_times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">median_dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">dts</span><span class="p">)</span>

    <span class="c1"># This should have &lt;# of block&gt; - 1 elements</span>
    <span class="n">discontinuities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dts</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">rtol</span> <span class="o">*</span> <span class="n">median_dt</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># This should contain the indices of the frames immediately AFTER each</span>
    <span class="c1"># discontinuity (as well as a 0 that I add to the front).</span>
    <span class="n">start_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">discontinuities</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">end_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">discontinuities</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_times</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># TODO TODO (optional extra args+) tests involving checks of # of blocks</span>
    <span class="c1"># determined here against # of blocks measured via</span>
    <span class="c1"># get_col_onset_offset_indices or something like that. at least this, but</span>
    <span class="c1"># could maybe check additional things too.</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">start_frames</span><span class="p">,</span> <span class="n">end_frames</span><span class="p">))</span></div>


<div class="viewcode-block" id="assign_frames_to_blocks"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.assign_frames_to_blocks">[docs]</a><span class="k">def</span> <span class="nf">assign_frames_to_blocks</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">thorimage_dir</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes ThorSync+Image data to (start, stop) indices for each block.</span>

<span class="sd">    Args:</span>
<span class="sd">    df: as output by `load_thorsync_hdf5`</span>

<span class="sd">    thorimage_dir: path to a directory created by ThorImage</span>

<span class="sd">    **kwargs: passed through to `get_frame_times`</span>

<span class="sd">    See documentation of `assign_frame_times_to_blocks` for more details on the</span>
<span class="sd">    definition of blocks and the properties of the output.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">frame_times</span> <span class="o">=</span> <span class="n">get_frame_times</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">thorimage_dir</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">assign_frame_times_to_blocks</span><span class="p">(</span><span class="n">frame_times</span><span class="p">)</span></div>


<span class="c1"># TODO maybe move this function to util or something?</span>
<span class="c1"># TODO provide kwargs to crop (end of?) ranges so that all have same number of</span>
<span class="c1"># frames? might also be some cases where something similar is needed at start,</span>
<span class="c1"># especially when we have multiple blocks</span>
<span class="c1"># TODO maybe just take frame_times + odor_col instead? or rename in a way that</span>
<span class="c1"># makes what input should be more clear?</span>
<div class="viewcode-block" id="assign_frames_to_odor_presentations"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.assign_frames_to_odor_presentations">[docs]</a><span class="k">def</span> <span class="nf">assign_frames_to_odor_presentations</span><span class="p">(</span><span class="n">thorsync_input</span><span class="p">,</span> <span class="n">thorimage_dir</span><span class="p">,</span>
    <span class="n">odor_onset_to_frame_rel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">odor_onset_to_frame_const</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">odor_timing_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">check_all_frames_assigned</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">check_no_discontinuity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns list of (start, first_odor_frame, end) frame indices</span>

<span class="sd">    One 3-tuple per odor presentation.</span>

<span class="sd">    Frames are indexed as they are along the first dimension of the movie,</span>
<span class="sd">    including for volumetric data (where a scalar index of this dimension will</span>
<span class="sd">    produce a volume) and/or data collected via frame averaging.</span>

<span class="sd">    End frames are included in range, and thus getting a presentation must be</span>
<span class="sd">    done like `movie[start_i:(end_i + 1)]` rather  than `movie[start_i:end_i]`.</span>

<span class="sd">    Not all frames necessarily included. No overlap.</span>

<span class="sd">    Args:</span>
<span class="sd">        thorsync_input (str | pd.DataFrame): path to directory created by ThorSync</span>
<span class="sd">            or a dataframe as would be created by passing such a directory to</span>
<span class="sd">            `load_thorsync_hdf5`.</span>

<span class="sd">        thorimage_dir (str): path to directory created by ThorImage that corresponds</span>
<span class="sd">            to the same experiment as the ThorSync data in `thorsync_input`.</span>

<span class="sd">        odor_onset_to_frame_rel (float): (NOT IMPLEMENTED) factor of averaged</span>
<span class="sd">            volumes/frames per second used to determine how long after odor onset to</span>
<span class="sd">            call first odor frame.</span>

<span class="sd">            No first odor frames will be before: (odor onset time +</span>
<span class="sd">            odor_onset_to_frame_rel * averaged volumes/frames per second +</span>
<span class="sd">            odor_onset_to_frame_const)</span>

<span class="sd">        odor_onset_to_frame_const (float): (NOT IMPLEMENTED) seconds after odor onset to</span>
<span class="sd">            call first odor frame. mainly to compensate for known lag between valve</span>
<span class="sd">            opening and odor arriving at the animal.</span>

<span class="sd">        **kwargs: passed through to `get_frame_times`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">odor_onset_to_frame_rel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">if</span> <span class="n">odor_onset_to_frame_const</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">if</span> <span class="n">odor_timing_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">odor_timing_names</span> <span class="o">=</span> <span class="n">_odor_timing_names</span>

    <span class="c1"># This also actually works w/ stuff of type np.str_, which old comparison did not.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">thorsync_input</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">)):</span>
        <span class="c1"># Just assuming it&#39;s an appropriate DataFrame input in this case.</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">thorsync_input</span>
        <span class="n">df_was_passed_in</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># TODO maybe unify definition of these cols w/ default dataset names loaded in</span>
        <span class="c1"># load_thorsync_hdf5 (fn that takes kwargs to override certain manually-named</span>
        <span class="c1"># names?)</span>
        <span class="n">dataset_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;gctr&#39;</span><span class="p">,</span> <span class="s1">&#39;frame_out&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">odor_timing_names</span><span class="p">)</span>

        <span class="c1"># Since this might be passed as a kwarg to this function, in which case it</span>
        <span class="c1"># would just get passed through to `get_frame_times`.</span>
        <span class="n">acq_trigger_names</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;acquisition_trigger_names&#39;</span><span class="p">,</span>
            <span class="n">_acquisition_trigger_names</span>
        <span class="p">)</span>
        <span class="n">dataset_names</span> <span class="o">+=</span> <span class="n">acq_trigger_names</span>

        <span class="c1"># ~78% of time (if called)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">load_thorsync_hdf5</span><span class="p">(</span><span class="n">thorsync_input</span><span class="p">,</span> <span class="n">datasets</span><span class="o">=</span><span class="n">dataset_names</span><span class="p">)</span>

        <span class="n">df_was_passed_in</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">del</span> <span class="n">thorsync_input</span>


    <span class="c1"># (when the valve(s) are given the signal to open)</span>
    <span class="n">odor_onsets</span> <span class="o">=</span> <span class="n">get_col_onset_indices</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">odor_timing_names</span><span class="p">,</span>
        <span class="n">threshold</span><span class="o">=</span><span class="n">ANALOG_0_TO_5V_THRESHOLD</span>
    <span class="p">)</span>
    <span class="n">odor_onset_times</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">odor_onsets</span><span class="p">]</span>

    <span class="c1"># unsafe if caller has a reference to `df`, but can save a small amount of time if</span>
    <span class="c1"># they don&#39;t (i.e. if we loaded it in this function)</span>
    <span class="n">_wont_use_df_after</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">df_was_passed_in</span>

    <span class="c1"># assuming load_thorsync_hdf5 is called in this fn, this is ~19% of the time,</span>
    <span class="c1"># and ~2/3rd that if _wont_use_df_after=True</span>
    <span class="n">frame_times</span> <span class="o">=</span> <span class="n">get_frame_times</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">thorimage_dir</span><span class="p">,</span>
        <span class="n">_wont_use_df_after</span><span class="o">=</span><span class="n">_wont_use_df_after</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>
    <span class="k">del</span> <span class="n">df</span>

    <span class="n">block_ranges</span> <span class="o">=</span> <span class="n">assign_frame_times_to_blocks</span><span class="p">(</span><span class="n">frame_times</span><span class="p">)</span>

    <span class="c1"># TODO assert all odor_onset_times are in one of the block ranges somewhere</span>

    <span class="n">start_frames</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">first_odor_frames</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">end_frames</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">curr_index_offset</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">block_ranges</span><span class="p">:</span>
        <span class="n">start_s</span> <span class="o">=</span> <span class="n">frame_times</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
        <span class="n">end_s</span> <span class="o">=</span> <span class="n">frame_times</span><span class="p">[</span><span class="n">end</span><span class="p">]</span>

        <span class="n">curr_frame_times</span> <span class="o">=</span> <span class="n">frame_times</span><span class="p">[</span><span class="n">start</span><span class="p">:(</span><span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="n">curr_odor_onset_times</span> <span class="o">=</span> <span class="n">odor_onset_times</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="n">start_s</span> <span class="o">&lt;=</span> <span class="n">odor_onset_times</span><span class="p">,</span> <span class="n">odor_onset_times</span> <span class="o">&lt;=</span> <span class="n">end_s</span>
        <span class="p">)]</span>

        <span class="c1"># Assuming we can use the amount of time continuously recording before the first</span>
        <span class="c1"># odor onset as the duration before each odor presentation that should be</span>
        <span class="c1"># assigned to each following odor presentation, within this block.</span>
        <span class="n">first_frame_to_odor_s</span> <span class="o">=</span> <span class="n">curr_odor_onset_times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">start_s</span>
        <span class="n">curr_start_times</span> <span class="o">=</span> <span class="n">curr_odor_onset_times</span> <span class="o">-</span> <span class="n">first_frame_to_odor_s</span>

        <span class="c1"># Using this function because `curr_start_times` are generally not going to</span>
        <span class="c1"># actually exactly equal to any times in `curr_frame_times`. If tied, seems to</span>
        <span class="c1"># provide index that would insert the new element at the earlier position.</span>
        <span class="n">curr_start_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">curr_frame_times</span><span class="p">,</span> <span class="n">curr_start_times</span><span class="p">)</span>

        <span class="c1"># TODO TODO TODO maybe (option to?) calculate/lookup (averaged) frames/volumes</span>
        <span class="c1"># per second and require the first odor frame be either a full / half duration</span>
        <span class="c1"># of that past odor onset???</span>
        <span class="c1"># TODO TODO TODO need to correct output of np.searchsorted to ensure it is AFTER</span>
        <span class="c1"># the odor onset, or not?</span>
        <span class="n">curr_first_odor_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">curr_frame_times</span><span class="p">,</span>
            <span class="n">curr_odor_onset_times</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_start_frames</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_first_odor_frames</span><span class="p">)</span>

        <span class="c1"># TODO maybe refactor to share w/ one other place that does this now?</span>
        <span class="c1"># Inclusive (so can NOT be used as the end of slices directly. need to</span>
        <span class="c1"># add one because slice ends are not inclusive.)</span>
        <span class="n">curr_end_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">curr_start_frames</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_frame_times</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">curr_start_frames</span><span class="p">,</span> <span class="n">curr_first_odor_frames</span><span class="p">,</span> <span class="n">curr_end_frames</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">o</span> <span class="o">&lt;</span> <span class="n">e</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">o</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s1">)&#39;</span>

        <span class="c1"># NOTE: i&#39;m not sure there is a guarantee this will currently always be true,</span>
        <span class="c1"># but it has been for my data so far. may also be ok for it not to be true, but</span>
        <span class="c1"># may need to re-evaluate.</span>
        <span class="c1"># If this is True, and the frame times is assigned to the middle of all</span>
        <span class="c1"># corresponding &quot;Frame Out&quot; pulses, then at least &gt;half of the time should have</span>
        <span class="c1"># been after the odor onset (or at least when the valve was triggered).</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">curr_frame_times</span><span class="p">[</span><span class="n">curr_first_odor_frames</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">curr_odor_onset_times</span><span class="p">)</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        # TODO delete</span>
<span class="sd">        print(&#39;odor_onset_times:&#39;, odor_onset_times)</span>
<span class="sd">        print(&#39;first odor frame times:&#39;, )</span>
<span class="sd">        #</span>
<span class="sd">        # TODO maybe put this behind some _debug / verbose flag or something</span>
<span class="sd">        print(&#39;onset to first odor frame (s):&#39;,</span>
<span class="sd">            curr_frame_times[curr_first_odor_frames] - odor_onset_times</span>
<span class="sd">        )</span>
<span class="sd">        import ipdb; ipdb.set_trace()</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">start_frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_start_frames</span> <span class="o">+</span> <span class="n">curr_index_offset</span><span class="p">)</span>
        <span class="n">first_odor_frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_first_odor_frames</span> <span class="o">+</span> <span class="n">curr_index_offset</span><span class="p">)</span>
        <span class="n">end_frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_end_frames</span> <span class="o">+</span> <span class="n">curr_index_offset</span><span class="p">)</span>

        <span class="n">curr_index_offset</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_frame_times</span><span class="p">)</span>

    <span class="n">start_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">start_frames</span><span class="p">)</span>
    <span class="n">first_odor_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">first_odor_frames</span><span class="p">)</span>
    <span class="n">end_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">end_frames</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">check_all_frames_assigned</span><span class="p">:</span>
        <span class="c1"># TODO better name</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">start_frames</span><span class="p">,</span> <span class="n">end_frames</span><span class="p">):</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

        <span class="c1"># TODO TODO TODO which of the 2022-10-07 data was triggering this again?</span>
        <span class="c1"># 1/megamat0_part2? what is correct handling there?</span>
        <span class="c1"># TODO TODO TODO replace assertion w/ raising NotAllFramesAssigned</span>
        <span class="c1"># (+ adapt any calling code that currently catches AssertionError)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_times</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_times</span><span class="p">),</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">thorimage_dir</span><span class="si">}</span><span class="s1">: not &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;all frames were assigned (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">frame_times</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span><span class="si">=}</span><span class="s1"> != &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">frame_times</span><span class="p">)</span><span class="si">=}</span><span class="s1">)&#39;</span>
        <span class="p">)</span>

        <span class="c1"># TODO delete try/except</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        try:</span>
<span class="sd">            assert len(frame_times[indices]) == len(frame_times), \</span>
<span class="sd">                f&#39;{thorimage_dir}: not all frames were assigned&#39;</span>

<span class="sd">        except AssertionError:</span>
<span class="sd">            print(f&#39;{thorimage_dir=}&#39;)</span>
<span class="sd">            print(f&#39;{len(frame_times[indices])=}&#39;)</span>
<span class="sd">            print(f&#39;{len(frame_times)=}&#39;)</span>
<span class="sd">            import ipdb; ipdb.set_trace()</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> \
            <span class="s1">&#39;nonunique (probably overlapping ranges of) indices&#39;</span>

    <span class="k">if</span> <span class="n">check_no_discontinuity</span><span class="p">:</span>
        <span class="c1"># Mainly intending to check for large discontinuitie that might arise</span>
        <span class="c1"># if, for example, the last odor presentation in one acquisition period</span>
        <span class="c1"># was also assigned the first frame in the next acquisition period.</span>

        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">start_frames</span><span class="p">,</span> <span class="n">end_frames</span><span class="p">):</span>
            <span class="n">curr_odor_times</span> <span class="o">=</span> <span class="n">frame_times</span><span class="p">[</span><span class="n">s</span><span class="p">:(</span><span class="n">e</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
            <span class="n">dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">curr_odor_times</span><span class="p">)</span>
            <span class="n">median_dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">dts</span><span class="p">)</span>
            <span class="n">max_dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dts</span><span class="p">)</span>

            <span class="k">assert</span> <span class="n">max_dt</span> <span class="o">&lt;</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">median_dt</span><span class="p">,</span> \
                <span class="s1">&#39;discontinuity larger than usual frame delta t&#39;</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">start_frames</span><span class="p">,</span> <span class="n">first_odor_frames</span><span class="p">,</span> <span class="n">end_frames</span><span class="p">))</span></div>


<span class="c1"># TODO rename to indicate it&#39;s parsing from directory name?</span>
<div class="viewcode-block" id="old_fmt_thorimage_num"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.old_fmt_thorimage_num">[docs]</a><span class="k">def</span> <span class="nf">old_fmt_thorimage_num</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="c1"># TODO provide example(s) of format in docstring</span>

    <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;_&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>


<span class="c1"># TODO rename to indicate it&#39;s parsing from directory name?</span>
<div class="viewcode-block" id="new_fmt_thorimage_num"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.new_fmt_thorimage_num">[docs]</a><span class="k">def</span> <span class="nf">new_fmt_thorimage_num</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="c1"># TODO provide example(s) of format in docstring</span>

    <span class="n">parts</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>


<span class="n">thorsync_dir_prefix</span> <span class="o">=</span> <span class="s1">&#39;SyncData&#39;</span>
<div class="viewcode-block" id="thorsync_num"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.thorsync_num">[docs]</a><span class="k">def</span> <span class="nf">thorsync_num</span><span class="p">(</span><span class="n">thorsync_dir</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns number in suffix of ThorSync output directory name as an int.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">thorsync_dir</span><span class="p">)[</span><span class="nb">len</span><span class="p">(</span><span class="n">thorsync_dir_prefix</span><span class="p">):])</span></div>


<div class="viewcode-block" id="is_thorsync_dir"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.is_thorsync_dir">[docs]</a><span class="k">def</span> <span class="nf">is_thorsync_dir</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;True if dir has expected ThorSync outputs, False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isdir</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># No matter how many directory levels `d` contains, `listdir` only returns</span>
    <span class="c1"># the basename of each file, not any preceding part of the path.</span>
    <span class="n">files</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">listdir</span><span class="p">(</span><span class="n">d</span><span class="p">)}</span>

    <span class="n">have_settings</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">have_h5</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="n">thorsync_xml_basename</span><span class="p">:</span>
            <span class="n">have_settings</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">is_thorsync_h5</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="n">have_h5</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;have_settings:&#39;</span><span class="p">,</span> <span class="n">have_settings</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;have_h5:&#39;</span><span class="p">,</span> <span class="n">have_h5</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">have_h5</span> <span class="ow">and</span> <span class="n">have_settings</span></div>


<div class="viewcode-block" id="is_thorimage_raw"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.is_thorimage_raw">[docs]</a><span class="k">def</span> <span class="nf">is_thorimage_raw</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;True if filename indicates file is ThorImage raw output.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">f_basename</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="c1"># Needs to match at least &#39;Image_0001_0001.raw&#39; and &#39;Image_001_001.raw&#39;</span>
    <span class="k">if</span> <span class="n">f_basename</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Image_00&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">f_basename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;001.raw&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="is_thorimage_dir"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.is_thorimage_dir">[docs]</a><span class="k">def</span> <span class="nf">is_thorimage_dir</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;True if dir has expected ThorImage outputs, False otherwise.</span>

<span class="sd">    Looks for .raw not any TIFFs now.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isdir</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># No matter how many directory levels `d` contains, `listdir` only returns</span>
    <span class="c1"># the basename of each file, not any preceding part of the path.</span>
    <span class="n">files</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">listdir</span><span class="p">(</span><span class="n">d</span><span class="p">)}</span>

    <span class="n">have_xml</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">have_raw</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># TODO support tif output case(s) as well</span>
    <span class="n">have_tiff</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="n">thorimage_xml_basename</span><span class="p">:</span>
            <span class="n">have_xml</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># TODO TODO would probably fail if experiment was configured to save</span>
        <span class="c1"># TIFF output? or does it also save .raw in that case? fix if not.</span>
        <span class="k">elif</span> <span class="n">is_thorimage_raw</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="n">have_raw</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># TODO replace w/ regex that also matches number parts in middle</span>
        <span class="c1"># (though exact number of digits may vary between 3 and 4, and not sure number</span>
        <span class="c1"># of parts is always 4)</span>
        <span class="k">elif</span> <span class="n">f</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;ChanA_&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.tif&#39;</span><span class="p">):</span>
            <span class="n">have_tiff</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">have_xml</span> <span class="ow">and</span> <span class="p">(</span><span class="n">have_raw</span> <span class="ow">or</span> <span class="n">have_tiff</span><span class="p">):</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;have_xml:&#39;</span><span class="p">,</span> <span class="n">have_xml</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;have_raw:&#39;</span><span class="p">,</span> <span class="n">have_raw</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;have_tiff:&#39;</span><span class="p">,</span> <span class="n">have_tiff</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">have_xml</span> <span class="ow">and</span> <span class="p">(</span><span class="n">have_raw</span> <span class="ow">or</span> <span class="n">have_tiff</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<span class="c1"># TODO some way to type hint the fact that if filter_funcs is a fn (not an iterable of</span>
<span class="c1"># them), the output will also be ~&quot;squeezed&quot;? otherwise it might be useful to change</span>
<span class="c1"># type to always be consistent idk</span>
<span class="k">def</span> <span class="nf">_filtered_subdirs</span><span class="p">(</span><span class="n">parent_dir</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">,</span> <span class="n">filter_funcs</span><span class="p">,</span> <span class="n">exclusive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes dir and indicator func(s) to subdirs satisfying them.</span>

<span class="sd">    Output is a flat list of directories if filter_funcs is a function.</span>

<span class="sd">    If it is a list of funcs, output has the same length, with each element</span>
<span class="sd">    a list of satisfying directories.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parent_dir</span> <span class="o">=</span> <span class="n">normpath</span><span class="p">(</span><span class="n">parent_dir</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">_</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">filter_funcs</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">filter_funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">filter_funcs</span><span class="p">]</span>

    <span class="c1"># [[]] * len(filter_funcs) was the inital way I tried this, but the inner</span>
    <span class="c1"># lists all end up referring to the same object.</span>
    <span class="n">all_filtered_subdirs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">filter_funcs</span><span class="p">)):</span>
        <span class="n">all_filtered_subdirs</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">parent_dir</span><span class="si">}{</span><span class="n">sep</span><span class="si">}</span><span class="s1">*</span><span class="si">{</span><span class="n">sep</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">fn</span><span class="p">,</span> <span class="n">filtered_subdirs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">filter_funcs</span><span class="p">,</span> <span class="n">all_filtered_subdirs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">val</span><span class="p">:</span>
                <span class="n">filtered_subdirs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">exclusive</span><span class="p">:</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filter_funcs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">all_filtered_subdirs</span> <span class="o">=</span> <span class="n">all_filtered_subdirs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">all_filtered_subdirs</span>


<div class="viewcode-block" id="thorimage_subdirs"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.thorimage_subdirs">[docs]</a><span class="k">def</span> <span class="nf">thorimage_subdirs</span><span class="p">(</span><span class="n">parent_dir</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Path</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of any immediate child directories of `parent_dir` that have</span>
<span class="sd">    all expected ThorImage outputs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_filtered_subdirs</span><span class="p">(</span><span class="n">parent_dir</span><span class="p">,</span> <span class="n">is_thorimage_dir</span><span class="p">)</span></div>


<div class="viewcode-block" id="thorsync_subdirs"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.thorsync_subdirs">[docs]</a><span class="k">def</span> <span class="nf">thorsync_subdirs</span><span class="p">(</span><span class="n">parent_dir</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Path</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Returns a list of any immediate child directories of `parent_dir`</span>
<span class="sd">    that have all expected ThorSync outputs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_filtered_subdirs</span><span class="p">(</span><span class="n">parent_dir</span><span class="p">,</span> <span class="n">is_thorsync_dir</span><span class="p">)</span></div>


<div class="viewcode-block" id="thor_subdirs"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.thor_subdirs">[docs]</a><span class="k">def</span> <span class="nf">thor_subdirs</span><span class="p">(</span><span class="n">parent_dir</span><span class="p">:</span> <span class="n">Pathlike</span><span class="p">,</span> <span class="n">absolute_paths</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Path</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Path</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a length-2 tuple, where the first element is all ThorImage children</span>
<span class="sd">    and the second element is all ThorSync children (of `parent_dir`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">thorimage_dirs</span><span class="p">,</span> <span class="n">thorsync_dirs</span> <span class="o">=</span> <span class="n">_filtered_subdirs</span><span class="p">(</span><span class="n">parent_dir</span><span class="p">,</span>
        <span class="p">(</span><span class="n">is_thorimage_dir</span><span class="p">,</span> <span class="n">is_thorsync_dir</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">absolute_paths</span><span class="p">:</span>
        <span class="n">thorimage_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="n">split</span><span class="p">(</span><span class="n">d</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">thorimage_dirs</span><span class="p">]</span>
        <span class="n">thorsync_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="n">split</span><span class="p">(</span><span class="n">d</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">thorsync_dirs</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">thorimage_dirs</span><span class="p">,</span> <span class="n">thorsync_dirs</span></div>


<span class="c1"># TODO TODO generalize / wrap in a way that also allows associating with</span>
<span class="c1"># stimulus files / arbitrary other files.</span>
<div class="viewcode-block" id="pair_thor_dirs"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.pair_thor_dirs">[docs]</a><span class="k">def</span> <span class="nf">pair_thor_dirs</span><span class="p">(</span><span class="n">thorimage_dirs</span><span class="p">,</span> <span class="n">thorsync_dirs</span><span class="p">,</span> <span class="n">use_mtime</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_ranking</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">check_against_naming_conv</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">check_unique_thorimage_nums</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ignore_prepairing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">PathPair</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes lists (not necessarily same len) of dirs, and returns a list of</span>
<span class="sd">    lists of matching (ThorImage, ThorSync) dirs (sorted by experiment time).</span>

<span class="sd">    Args:</span>
<span class="sd">        check_against_naming_conv (bool): (default=False) If True, check ordering</span>
<span class="sd">            from pairing is consistent with ordering derived from our naming</span>
<span class="sd">            conventions for Thor software output.</span>

<span class="sd">        check_unique_thorimage_nums (bool): If True, check numbers parsed from</span>
<span class="sd">            ThorImage directory names, as-per convention, are unique.</span>
<span class="sd">            Requires check_against_naming_conv to be True. Defaults to True if</span>
<span class="sd">            check_against_naming_conv is True, else defaults to False.</span>

<span class="sd">        ignore_prepairing (None | iterable of str): An optional iterable of substrings.</span>
<span class="sd">            If any are present in the name of a Thor directory, that directory will be</span>
<span class="sd">            excluded from consideration in pairing. This is mainly to keep the (fragile)</span>
<span class="sd">            implementation that requires equal numbers of ThorImage and ThorSync</span>
<span class="sd">            directories for pairing working if some particular experiments named a</span>
<span class="sd">            certain way only have data from one. Will also be try appending these to</span>
<span class="sd">            `ignore` if uneven numbers of directories and `use_ranking=True`.</span>

<span class="sd">        ignore (None | iterable of str): As `ignore_prepairing`, but ignore will happen</span>
<span class="sd">            after pairing. Both the ThorImage and ThorSync directories of a pair will be</span>
<span class="sd">            checked for these substrings and if any match the pair is not returned. This</span>
<span class="sd">            is mainly intended to ignore known-bad data.</span>

<span class="sd">    Raises ValueError if two dirs of one type match to the same one of the</span>
<span class="sd">    other, but just returns shorter list of pairs if some matches can not be</span>
<span class="sd">    made. These errors currently just cause skipping of pairing for the</span>
<span class="sd">    particular (date, fly) pair above (though maybe this should change?).</span>

<span class="sd">    Raises AssertionError when assumptions are violated in a way that should</span>
<span class="sd">    trigger re-evaluating the code.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ignore_prepairing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">orig_thorimage_dirs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">thorimage_dirs</span><span class="p">)</span>
        <span class="n">orig_thorsync_dirs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">thorsync_dirs</span><span class="p">)</span>

        <span class="n">thorimage_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">thorimage_dirs</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">sub_str</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">sub_str</span> <span class="ow">in</span> <span class="n">ignore_prepairing</span><span class="p">])</span>
        <span class="p">]</span>
        <span class="n">thorsync_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">thorsync_dirs</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">sub_str</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">sub_str</span> <span class="ow">in</span> <span class="n">ignore_prepairing</span><span class="p">])</span>
        <span class="p">]</span>

    <span class="k">if</span> <span class="n">use_ranking</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">thorimage_dirs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">thorsync_dirs</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">ignore_prepairing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ignore</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ignore</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ignore</span><span class="p">)</span>

                <span class="n">ignore</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ignore_prepairing</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">pair_thor_dirs</span><span class="p">(</span><span class="n">orig_thorimage_dirs</span><span class="p">,</span> <span class="n">orig_thorsync_dirs</span><span class="p">,</span>
                    <span class="n">use_mtime</span><span class="o">=</span><span class="n">use_mtime</span><span class="p">,</span> <span class="n">use_ranking</span><span class="o">=</span><span class="n">use_ranking</span><span class="p">,</span>
                    <span class="n">check_against_naming_conv</span><span class="o">=</span><span class="n">check_against_naming_conv</span><span class="p">,</span>
                    <span class="n">check_unique_thorimage_nums</span><span class="o">=</span><span class="n">check_unique_thorimage_nums</span><span class="p">,</span>
                    <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">ignore_prepairing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="n">ignore</span>
                <span class="p">)</span>

            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;can only pair with ranking when equal # dirs.</span><span class="se">\n\n</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;thorimage_dirs (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">thorimage_dirs</span><span class="p">)</span><span class="si">}</span><span class="s1">):</span><span class="se">\n</span><span class="si">{</span><span class="n">pformat</span><span class="p">(</span><span class="n">thorimage_dirs</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">thorsync_dirs (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">thorsync_dirs</span><span class="p">)</span><span class="si">}</span><span class="s1">):</span><span class="se">\n</span><span class="si">{</span><span class="n">pformat</span><span class="p">(</span><span class="n">thorsync_dirs</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">check_unique_thorimage_nums</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">check_against_naming_conv</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;check_unique_thorimage_nums=True requires &#39;</span>
            <span class="s1">&#39;check_against_naming_conv=True&#39;</span>
        <span class="p">)</span>

    <span class="c1"># So that we don&#39;t need to explicitly disable both of these flags if we want</span>
    <span class="c1"># to disable these checks. Just need to set check_against_naming_conv=False</span>
    <span class="k">if</span> <span class="n">check_unique_thorimage_nums</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">check_against_naming_conv</span><span class="p">:</span>
        <span class="n">check_unique_thorimage_nums</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">thorimage_times</span> <span class="o">=</span> <span class="p">{</span><span class="n">d</span><span class="p">:</span> <span class="n">get_thorimage_time</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">thorimage_dirs</span><span class="p">}</span>

    <span class="c1"># TODO should get_thorsync_time not implement/take the same use_mtime kwarg?</span>
    <span class="n">thorsync_times</span> <span class="o">=</span> <span class="p">{</span><span class="n">d</span><span class="p">:</span> <span class="n">get_thorsync_time</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">thorsync_dirs</span><span class="p">}</span>

    <span class="n">thorimage_dirs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="nb">sorted</span><span class="p">(</span><span class="n">thorimage_dirs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">thorimage_times</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="p">)</span>
    <span class="n">thorsync_dirs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="nb">sorted</span><span class="p">(</span><span class="n">thorsync_dirs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">thorsync_times</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">use_ranking</span><span class="p">:</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">thorimage_dirs</span><span class="p">,</span> <span class="n">thorsync_dirs</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">linear_sum_assignment</span>

        <span class="c1"># TODO maybe call scipy func on pandas obj w/ dirs as labels?</span>
        <span class="n">costs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">thorimage_dirs</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">thorsync_dirs</span><span class="p">)))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">thorimage_dirs</span><span class="p">):</span>
            <span class="n">ti_time</span> <span class="o">=</span> <span class="n">thorimage_times</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;tid:&#39;</span><span class="p">,</span> <span class="n">tid</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ti_time:&#39;</span><span class="p">,</span> <span class="n">ti_time</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">tsd</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">thorsync_dirs</span><span class="p">):</span>
                <span class="n">ts_time</span> <span class="o">=</span> <span class="n">thorsync_times</span><span class="p">[</span><span class="n">tsd</span><span class="p">]</span>

                <span class="n">cost</span> <span class="o">=</span> <span class="p">(</span><span class="n">ts_time</span> <span class="o">-</span> <span class="n">ti_time</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; tsd:&#39;</span><span class="p">,</span> <span class="n">tsd</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  ts_time:&#39;</span><span class="p">,</span> <span class="n">ts_time</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  cost (ts - ti):&#39;</span><span class="p">,</span> <span class="n">cost</span><span class="p">)</span>

                <span class="c1"># Since ts time should be larger, but only if comparing XML TI</span>
                <span class="c1"># time w/ TS mtime (which gets changed as XML seems to be</span>
                <span class="c1"># written as experiment is finishing / in progress).</span>
                <span class="k">if</span> <span class="n">use_mtime</span><span class="p">:</span>
                    <span class="n">cost</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">cost</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># TODO will probably just need to make this a large const</span>
                    <span class="c1"># inf seems to make the scipy imp fail. some imp it works</span>
                    <span class="c1"># with?</span>
                    <span class="c1">#cost = np.inf</span>
                    <span class="n">cost</span> <span class="o">=</span> <span class="mf">1e7</span>

                <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="n">ti_idx</span><span class="p">,</span> <span class="n">ts_idx</span> <span class="o">=</span> <span class="n">linear_sum_assignment</span><span class="p">(</span><span class="n">costs</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">costs</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">ti_idx</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">ts_idx</span><span class="p">)</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">thorimage_dirs</span><span class="p">[</span><span class="n">ti_idx</span><span class="p">],</span> <span class="n">thorsync_dirs</span><span class="p">[</span><span class="n">ts_idx</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">check_against_naming_conv</span><span class="p">:</span>
        <span class="n">ti_last_parts</span> <span class="o">=</span> <span class="p">[</span><span class="n">split</span><span class="p">(</span><span class="n">tid</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">tid</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">]</span>

        <span class="n">thorimage_nums</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">not_all_old_fmt</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="n">ti_last_parts</span><span class="p">:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">old_fmt_thorimage_num</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
                <span class="n">not_all_old_fmt</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
            <span class="n">thorimage_nums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

        <span class="n">disable_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">You may disable this check by setting &#39;</span>
            <span class="s1">&#39;check_against_naming_conv=False&#39;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">not_all_old_fmt</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">thorimage_nums</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_fmt_thorimage_num</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ti_last_parts</span>
                <span class="p">]</span>
            <span class="c1"># If ALL ThorImage directories are not in old naming convention,</span>
            <span class="c1"># then we assume they will ALL be named according to the new</span>
            <span class="c1"># convention.</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># (changing error type so it isn&#39;t caught, w/ other ValueErrors)</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;check against naming convention failed, &#39;</span>
                    <span class="s1">&#39;because a new_fmt_thorimage_num parse call failed with: &#39;</span> <span class="o">+</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">+</span> <span class="n">disable_msg</span>
                <span class="p">)</span>

        <span class="c1"># TODO TODO need to stable (arg)sort if not going to check this, but</span>
        <span class="c1"># still checking ordering below??? (or somehow ordering by naming</span>
        <span class="c1"># convention, so that fn comes before fn_0000, etc?)</span>

        <span class="c1"># Call from mb_team_gsheet disables this, so that fn / fn_0000 don&#39;t</span>
        <span class="c1"># cause a failure even though both have ThorImage num of 0, because fn</span>
        <span class="c1"># should always be dropped after the pairing in this case (should be</span>
        <span class="c1"># checked in mb_team_gsheet after, since it will then not be checked</span>
        <span class="c1"># here).</span>
        <span class="k">if</span> <span class="n">check_unique_thorimage_nums</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">thorimage_nums</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">thorimage_nums</span><span class="p">)):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Directories where pairing failed:&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ThorImage:&#39;</span><span class="p">)</span>
                <span class="n">pprint</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">thorimage_dirs</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Extracted thorimage_nums:&#39;</span><span class="p">)</span>
                <span class="n">pprint</span><span class="p">(</span><span class="n">thorimage_nums</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ThorSync:&#39;</span><span class="p">)</span>
                <span class="n">pprint</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">thorsync_dirs</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;thorimage nums were not unique&#39;</span><span class="p">)</span>

        <span class="n">thorsync_nums</span> <span class="o">=</span> <span class="p">[</span><span class="n">thorsync_num</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">tsd</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">tsd</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">]</span>

        <span class="c1"># Ranking rather than straight comparison in case there is an offset.</span>
        <span class="n">ti_rankings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">thorimage_nums</span><span class="p">)</span>
        <span class="n">ts_rankings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">thorsync_nums</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">ti_rankings</span><span class="p">,</span> <span class="n">ts_rankings</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;time based rankings inconsistent w/ &#39;</span>
                <span class="s1">&#39;file name convention rankings&#39;</span> <span class="o">+</span> <span class="n">disable_msg</span>
            <span class="p">)</span>
        <span class="c1"># TODO maybe also re-order pairs by these rankings? or by their own,</span>
        <span class="c1"># to also include case where not check_against... ?</span>

    <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ti</span><span class="p">,</span> <span class="n">ts</span><span class="p">)</span> <span class="k">for</span> <span class="n">ti</span><span class="p">,</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">pairs</span> <span class="k">if</span> <span class="ow">not</span>
            <span class="nb">any</span><span class="p">([(</span><span class="n">sub_str</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">ti</span><span class="p">)</span> <span class="ow">or</span> <span class="n">sub_str</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span> <span class="k">for</span> <span class="n">sub_str</span> <span class="ow">in</span> <span class="n">ignore</span><span class="p">])</span>
        <span class="p">]</span>

    <span class="k">return</span> <span class="n">pairs</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    thorimage_times = {d: get_thorimage_time(d) for d in thorimage_dirs}</span>
<span class="sd">    thorsync_times = {d: get_thorsync_time(d) for d in thorsync_dirs}</span>

<span class="sd">    image_and_sync_pairs = []</span>
<span class="sd">    matched_dirs = set()</span>
<span class="sd">    # TODO make sure this order is going the way i want</span>
<span class="sd">    for tid in sorted(thorimage_dirs, key=lambda x: thorimage_times[x]):</span>
<span class="sd">        ti_time = thorimage_times[tid]</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(&#39;tid:&#39;, tid)</span>
<span class="sd">            print(&#39;ti_time:&#39;, ti_time)</span>

<span class="sd">        # Seems ThorImage time (from TI XML) is always before ThorSync time</span>
<span class="sd">        # (from mtime of TS XML), so going to look for closest mtime.</span>
<span class="sd">        # TODO could also warn / fail if closest ti mtime to ts mtime</span>
<span class="sd">        # is inconsistent? or just use that?</span>
<span class="sd">        # TODO or just use numbers in names? or default to that / warn/fail if</span>
<span class="sd">        # not consistent?</span>

<span class="sd">        # TODO TODO would need to modify this alg to handle many cases</span>
<span class="sd">        # where there are mismatched #&#39;s of recordings</span>
<span class="sd">        # (first tid will get the tsd, even if another tid is closer)</span>
<span class="sd">        # scipy.optimize.linear_sum_assignment looks interesting, but</span>
<span class="sd">        # not sure it can handle</span>

<span class="sd">        min_positive_td = None</span>
<span class="sd">        closest_tsd = None</span>
<span class="sd">        for tsd in thorsync_dirs:</span>
<span class="sd">            ts_time = thorsync_times[tsd]</span>
<span class="sd">            td = (ts_time - ti_time).total_seconds()</span>

<span class="sd">            if verbose:</span>
<span class="sd">                print(&#39; tsd:&#39;, tsd)</span>
<span class="sd">                print(&#39;  ts_time:&#39;, ts_time)</span>
<span class="sd">                print(&#39;  td (ts - ti):&#39;, td)</span>

<span class="sd">            # Since ts_time should be larger.</span>
<span class="sd">            if td &lt; 0:</span>
<span class="sd">                continue</span>

<span class="sd">            if min_positive_td is None or td &lt; min_positive_td:</span>
<span class="sd">                min_positive_td = td</span>
<span class="sd">                closest_tsd = tsd</span>

<span class="sd">            &#39;&#39;&#39;</span>
<span class="sd">            # didn&#39;t seem to work at all for newer output ~10/2019</span>
<span class="sd">            if abs(td) &lt; time_mismatch_cutoff_s:</span>
<span class="sd">                if tid in matched_dirs or tsd in matched_dirs:</span>
<span class="sd">                    raise ValueError(f&#39;either {tid} or {tsd} was already &#39;</span>
<span class="sd">                        f&#39;matched. existing pairs:\n{matched_dirs}&#39;)</span>

<span class="sd">                image_and_sync_pairs.append((tid, tsd))</span>
<span class="sd">                matched_dirs.add(tid)</span>
<span class="sd">                matched_dirs.add(tsd)</span>
<span class="sd">            &#39;&#39;&#39;</span>

<span class="sd">            matched_dirs.add(tid)</span>
<span class="sd">            matched_dirs.add(tsd)</span>

<span class="sd">        if verbose:</span>
<span class="sd">            print(&#39;&#39;)</span>

<span class="sd">    return image_and_sync_pairs</span>
<span class="sd">    &quot;&quot;&quot;</span></div>


<span class="c1"># TODO maybe allow calling a fn &#39;pair_thor_dirs&#39; with either this interface of</span>
<span class="c1"># that of current &#39;pair_thor_dirs&#39;, detecting type from args</span>
<div class="viewcode-block" id="pair_thor_subdirs"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.pair_thor_subdirs">[docs]</a><span class="k">def</span> <span class="nf">pair_thor_subdirs</span><span class="p">(</span><span class="n">parent_dir</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">PathPair</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Raises ValueError/AssertionError when pair_thor_dirs does.</span>

<span class="sd">    Above, the former causes skipping of automatic pairing, whereas the latter</span>
<span class="sd">    is not handled and will intentionally cause failure, to prevent incorrect</span>
<span class="sd">    assumptions from leading to incorrect results.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO TODO need to handle case where maybe one thorimage/sync dir doesn&#39;t</span>
    <span class="c1"># have all output, and then that would maybe offset the pairing? test!</span>
    <span class="c1"># (change filter fns to include a minimal set of data, s.t. all such cases</span>
    <span class="c1"># still are counted?)</span>
    <span class="n">thorimage_dirs</span><span class="p">,</span> <span class="n">thorsync_dirs</span> <span class="o">=</span> <span class="n">thor_subdirs</span><span class="p">(</span><span class="n">parent_dir</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;thorimage_dirs:&#39;</span><span class="p">)</span>
        <span class="n">pprint</span><span class="p">(</span><span class="n">thorimage_dirs</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;thorsync_dirs:&#39;</span><span class="p">)</span>
        <span class="n">pprint</span><span class="p">(</span><span class="n">thorsync_dirs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pair_thor_dirs</span><span class="p">(</span><span class="n">thorimage_dirs</span><span class="p">,</span> <span class="n">thorsync_dirs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="c1"># TODO maybe delete / refactor to use fns above</span>
<span class="c1"># TODO move this to gui.py if that&#39;s the only place i&#39;d use it</span>
<span class="c1"># (or project/analysis specific repo/submodule)</span>
<div class="viewcode-block" id="tif2xml_root"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.tif2xml_root">[docs]</a><span class="k">def</span> <span class="nf">tif2xml_root</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns etree root of ThorImage XML settings from TIFF filename,</span>
<span class="sd">    assuming TIFF was named and placed according to a certain convention.</span>

<span class="sd">    Path can be to analysis output directory, as long as raw data directory</span>
<span class="sd">    exists.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">filename</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">analysis_output_root</span><span class="p">()):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">analysis_output_root</span><span class="p">(),</span> <span class="n">raw_data_root</span><span class="p">())</span>

    <span class="n">parts</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    <span class="n">thorimage_id</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">xml_fname</span> <span class="o">=</span> <span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">thorimage_id</span><span class="p">,</span> <span class="n">thorimage_xml_basename</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">xmlroot</span><span class="p">(</span><span class="n">xml_fname</span><span class="p">)</span></div>


<span class="c1"># TODO TODO rename this one to make it clear why it&#39;s diff from above</span>
<span class="c1"># + how to use it (or just delete one...)</span>
<span class="c1"># TODO + also likely refactor this outside here as mentioned for tif2... above</span>
<div class="viewcode-block" id="fps_from_thor"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.fps_from_thor">[docs]</a><span class="k">def</span> <span class="nf">fps_from_thor</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes a DataFrame and returns fps from ThorImage XML.</span>

<span class="sd">    df must have a &#39;thorimage_dir&#39; column (that can be either a relative or</span>
<span class="sd">    absolute path, as long as it&#39;s under raw_data_root), which is expected to</span>
<span class="sd">    only contain one unique value.</span>

<span class="sd">    Only the path in the first row is used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO assert unique first?</span>
    <span class="n">thorimage_dir</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;thorimage_path&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># TODO maybe factor into something that ensures path has a certain prefix</span>
    <span class="c1"># that maybe also validates right # parts?</span>
    <span class="n">thorimage_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">raw_data_root</span><span class="p">(),</span> <span class="o">*</span><span class="n">thorimage_dir</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">3</span><span class="p">:])</span>
    <span class="n">fps</span> <span class="o">=</span> <span class="n">get_thorimage_fps</span><span class="p">(</span><span class="n">thorimage_dir</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fps</span></div>


<span class="c1"># TODO likely refactor to an analysis/cnmf-interface specific submodule</span>
<span class="c1"># TODO at least rename to indicate input is tiff filename</span>
<div class="viewcode-block" id="cnmf_metadata_from_thor"><a class="viewcode-back" href="../../apidoc/hong2p.thor.html#hong2p.thor.cnmf_metadata_from_thor">[docs]</a><span class="k">def</span> <span class="nf">cnmf_metadata_from_thor</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes TIF filename to key settings from XML needed for CNMF.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xml_root</span> <span class="o">=</span> <span class="n">tif2xml_root</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">fps</span> <span class="o">=</span> <span class="n">get_thorimage_fps_xml</span><span class="p">(</span><span class="n">xml_root</span><span class="p">)</span>
    <span class="c1"># &quot;spatial resolution of FOV in pixels per um&quot; &quot;(float, float)&quot;</span>
    <span class="c1"># TODO do they really mean pixel/um, not um/pixel?</span>
    <span class="n">pixels_per_um</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">get_thorimage_pixelsize_um</span><span class="p">(</span><span class="n">xml_root</span><span class="p">)</span>
    <span class="n">dxy</span> <span class="o">=</span> <span class="p">(</span><span class="n">pixels_per_um</span><span class="p">,</span> <span class="n">pixels_per_um</span><span class="p">)</span>
    <span class="c1"># TODO maybe load dims anyway?</span>
    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;fr&#39;</span><span class="p">:</span> <span class="n">fps</span><span class="p">,</span> <span class="s1">&#39;dxy&#39;</span><span class="p">:</span> <span class="n">dxy</span><span class="p">}</span></div>

</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2022, Tom O&#39;Connell.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>